.
├── .gitattributes
├── AI_model.py
     ↓↓↓ FILE CONTENT ↓↓↓
     import os
     import cv2
     from ultralytics import YOLO
     
     # Load YOLO model once
     model = YOLO('best.pt')
     print("[INFO] Model loaded. Classes:", model.names)
     
     def process_frame(frame):
         results = model(frame)
         for result in results:
             for box in result.boxes:
                 x1, y1, x2, y2 = map(int, box.xyxy[0])
                 conf = box.conf[0].item()
                 cls = int(box.cls[0].item())
                 class_name = model.names.get(cls, f'Class {cls}')
                 label = f'{class_name} {conf:.2f}'
     
                 cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
                 (w, h), _ = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.7, 2)
                 cv2.rectangle(frame, (x1, y1 - h - 5), (x1 + w, y1), (0, 255, 0), -1)
                 cv2.putText(frame, label, (x1, y1), cv2.FONT_HERSHEY_SIMPLEX,
                             0.7, (0, 0, 0), 2, cv2.LINE_AA)
         return frame
     
     def process_images_in_directory(input_dir, output_dir):
         os.makedirs(output_dir, exist_ok=True)
         supported_ext = ['.jpg', '.jpeg', '.png', '.bmp']
     
         for filename in os.listdir(input_dir):
             if any(filename.lower().endswith(ext) for ext in supported_ext):
                 image_path = os.path.join(input_dir, filename)
                 frame = cv2.imread(image_path)
                 if frame is None:
                     print(f"[WARNING] Couldn't read {filename}, skipping.")
                     continue
     
                 processed_frame = process_frame(frame)
                 output_path = os.path.join(output_dir, filename)
                 cv2.imwrite(output_path, processed_frame)
                 print(f"[INFO] Processed and saved: {output_path}")
     
     if __name__ == '__main__':
         process_images_in_directory('input', 'static/predictions')
     ↑↑↑ END OF FILE ↑↑↑

├── __pycache__
│   ├── AI_model.cpython-312.pyc
│   ├── AI_model.cpython-313.pyc
│   ├── dashboard.cpython-312.pyc
│   ├── dashboard.cpython-313.pyc
│   ├── database_setup.cpython-312.pyc
│   ├── database_setup.cpython-313.pyc
│   ├── network.cpython-312.pyc
│   ├── network.cpython-313.pyc
│   ├── weightedAverage.cpython-312.pyc
│   └── weightedAverage.cpython-313.pyc
├── app.py
     ↓↓↓ FILE CONTENT ↓↓↓
     from flask import Flask, render_template, request, jsonify, url_for, redirect, session
     from database_setup import Base, engine
     from dashboard import dashboard_bp
     from network_utils.status import status_bp
     from network import receive_sensor_data
     from AI_model import process_images_in_directory
     import os
     from network_utils.config_handler import load_config, save_config
     from network_utils.user_control import handle_manual_control
     from network_utils.auth import auth_bp
     # from datetime import timedelta  ❌ Remove if no longer using permanent sessions
     
     app = Flask(__name__)
     app.secret_key = "8e0b7a6e4fa24739b0a05c1e5dc889d1f6d49b91ce9b213ec2af3b110d9376b9s"
     # app.permanent_session_lifetime = timedelta(minutes=1)  ❌ Disable this to rely on browser session cookies
     
     Base.metadata.create_all(bind=engine)
     
     app.register_blueprint(auth_bp)
     app.register_blueprint(dashboard_bp)
     app.register_blueprint(status_bp)
     
     INPUT_DIR = 'input'
     OUTPUT_DIR = 'static/predictions'
     
     @app.route('/')
     def index():
         print("[DEBUG] Current session:", dict(session))  # Optional debugging
         if "user_id" not in session:
             return redirect(url_for("auth.login"))
         return render_template('index.html')
     
     @app.route('/run', methods=['POST'])
     def run_yolo():
         process_images_in_directory(INPUT_DIR, OUTPUT_DIR)
         return redirect(url_for('ai_model'))
     
     @app.route('/results')
     def ai_model():
         images = [
             f for f in os.listdir(OUTPUT_DIR)
             if f.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp'))
         ]
         return render_template('ai_model.html', images=images)
     
     @app.route('/receive', methods=['POST'])
     def receive_data():
         return receive_sensor_data(request)
     
     @app.route('/get_thresholds')
     def get_thresholds():
         return jsonify(load_config())
     
     @app.route('/set_thresholds', methods=['POST'])
     def set_thresholds():
         data = request.get_json()
         try:
             config = load_config()
             config["TEMP_THRESHOLD"] = int(data.get("temp_threshold", config["TEMP_THRESHOLD"]))
             config["HUM_THRESHOLD"] = int(data.get("hum_threshold", config["HUM_THRESHOLD"]))
             config["SOIL_MOISTURE_THRESHOLD"] = int(data.get("soil_moisture_threshold", config["SOIL_MOISTURE_THRESHOLD"]))
             save_config(config)
             print("[DEBUG] Thresholds updated:", config)
             return jsonify({"message": "Thresholds updated successfully."})
         except Exception as e:
             return jsonify({"message": f"Error: {str(e)}"}), 400
     
     @app.route("/manual-control", methods=["POST"])
     def manual_control():
         payload = request.get_json()
         result = handle_manual_control(payload)
         return jsonify(result), 200 if result.get("status") == "success" else 400
     
     
     @app.route('/about')
     def aboutus():
         return render_template("aboutus.html")
     
     @app.route("/logout")
     def logout():
         session.clear()
         return redirect(url_for("auth.login"))
     
     
     if __name__ == '__main__':
         app.run(host='0.0.0.0', port=5000)
     ↑↑↑ END OF FILE ↑↑↑

├── dashboard.py
     ↓↓↓ FILE CONTENT ↓↓↓
     from flask import Blueprint, render_template, jsonify
     from database_setup import SessionLocal, SensorData, KalmanFilterFusionData, WeightedAverageFusionData
     from collections import defaultdict
     import json
     
     dashboard_bp = Blueprint('dashboard', __name__)
     
     sensor_labels = {
         2001: "Temperature - DHT1 Internal",
         2002: "Humidity - DHT1 Internal",
         2003: "Temperature - DHT2 Internal",
         2004: "Humidity - DHT2 Internal",
         2005: "Soil Moisture - Plant 1",
         3001: "Temperature - DHT3 Internal",
         3002: "Humidity - DHT3 Internal",
         3003: "Temperature - DHT4 External",
         3004: "Humidity - DHT4 External",
         3005: "Soil Moisture - Plant 2"
     }
     
     @dashboard_bp.route("/dashboard")
     def dashboard():
         return render_template("dashboard.html")
     
     
     @dashboard_bp.route("/api/dashboard-data")
     def dashboard_data():
         session = SessionLocal()
         try:
             # --- RAW SENSOR DATA ---
             raw_data = session.query(SensorData).order_by(SensorData.Timestamp).limit(100).all()
             grouped_raw = defaultdict(list)
             for entry in raw_data:
                 grouped_raw[entry.SensorID].append({
                     "timestamp": entry.Timestamp.isoformat(),
                     "value": entry.Value
                 })
     
             raw_plot_data = [
                 {
                     "label": sensor_labels.get(sensor_id, f"Sensor {sensor_id}"),
                     "sensor_id": sensor_id,
                     "timestamps": [d["timestamp"] for d in data],
                     "values": [d["value"] for d in data]
                 }
                 for sensor_id, data in grouped_raw.items()
             ]
     
             # --- KALMAN FILTER FUSION DATA ---
             kalman_data = session.query(KalmanFilterFusionData).order_by(KalmanFilterFusionData.Timestamp).limit(100).all()
             grouped_kalman = defaultdict(list)
             for entry in kalman_data:
                 grouped_kalman[entry.SensorID].append({
                     "timestamp": entry.Timestamp.isoformat(),
                     "value": entry.FusedValue
                 })
             kalman_plot_data = [
                 {
                     "label": sensor_labels.get(sensor_id, f"Sensor {sensor_id}"),
                     "sensor_id": sensor_id,
                     "timestamps": [d["timestamp"] for d in data],
                     "values": [d["value"] for d in data]
                 }
                 for sensor_id, data in grouped_kalman.items()
             ]
     
             # --- WEIGHTED AVERAGE FUSION DATA ---
             weighted_data = session.query(WeightedAverageFusionData).order_by(WeightedAverageFusionData.Timestamp).limit(100).all()
             grouped_weighted = defaultdict(list)
             for entry in weighted_data:
                 grouped_weighted[entry.SensorType].append({
                     "timestamp": entry.Timestamp.isoformat(),
                     "value": entry.FusedValue
                 })
             weighted_plot_data = [
                 {
                     "sensor_type": sensor_type,
                     "timestamps": [d["timestamp"] for d in data],
                     "values": [d["value"] for d in data]
                 }
                 for sensor_type, data in grouped_weighted.items()
             ]
     
             return jsonify({
                 "raw": raw_plot_data,
                 "kalman": kalman_plot_data,
                 "weighted": weighted_plot_data
             })
     
         finally:
             session.close()
     ↑↑↑ END OF FILE ↑↑↑

├── data_retrival.py
     ↓↓↓ FILE CONTENT ↓↓↓
     from sqlalchemy.orm import sessionmaker
     from database_setup import engine, Actuator, UserInteraction
     import pandas as pd
     
     # Create session
     Session = sessionmaker(bind=engine)
     session = Session()
     
     # === Fetch last row from Actuator table ===
     last_actuator = (
         session.query(Actuator)
         .order_by(Actuator.LastUpdated.desc())
         .first()
     )
     
     # Convert to dict
     actuator_data = {
         "ActuatorID": last_actuator.ActuatorID,
         "ActuatorName": last_actuator.ActuatorName,
         "Status": last_actuator.Status,
         "LastUpdated": last_actuator.LastUpdated,
         "UserID": last_actuator.UserID,
         "DeviceID": last_actuator.DeviceID
     } if last_actuator else {}
     
     # === Fetch last row from UserInteraction table ===
     last_interaction = (
         session.query(UserInteraction)
         .order_by(UserInteraction.Timestamp.desc())
         .first()
     )
     
     # Convert to dict
     interaction_data = {
         "InteractionID": last_interaction.InteractionID,
         "UserID": last_interaction.UserID,
         "DeviceID": last_interaction.DeviceID,
         "ActuatorID": last_interaction.ActuatorID,
         "Action": last_interaction.Action,
         "Timestamp": last_interaction.Timestamp
     } if last_interaction else {}
     
     # Close session
     session.close()
     
     # Print output
     print("\n=== Last Actuator Entry ===")
     print(pd.DataFrame([actuator_data]))
     
     print("\n=== Last UserInteraction Entry ===")
     print(pd.DataFrame([interaction_data]))
     ↑↑↑ END OF FILE ↑↑↑

├── databaseTests
│   ├── Initialize_greenhouse_db.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from sqlalchemy.orm import Session, sessionmaker, DeclarativeBase
│        from database_setup import engine, Device, SensorData
│        
│        Session = sessionmaker(bind=engine)
│        session = Session()
│        
│        #  Example: Insert multiple temperature readings at once
│        sensor_readings = [
│            {"DeviceID": 1, "SensorType": "humidity", "Value": 21.2},
│            {"DeviceID": 2, "SensorType": "humidity", "Value": 22.2},
│            {"DeviceID": 3, "SensorType": "humidity", "Value": 23.4},
│            {"DeviceID": 4, "SensorType": "humidity", "Value": 24.4},
│            {"DeviceID": 5, "SensorType": "temperature", "Value": 42.2},
│            {"DeviceID": 6, "SensorType": "temperature", "Value": 41.2},
│            {"DeviceID": 7, "SensorType": "temperature", "Value": 43.4},
│            {"DeviceID": 8, "SensorType": "temperature", "Value": 45.4},
│            {"DeviceID": 9, "SensorType": "soil_moisture", "Value": 50.2},
│            {"DeviceID": 10, "SensorType": "soil_moisture", "Value": 54.4}
│        ]
│        
│        
│        # Convert dictionary list to SQLAlchemy objects
│        sensor_objects = [SensorData(**reading) for reading in sensor_readings]
│        
│        #  Bulk insert all rows at once
│        session.bulk_save_objects(sensor_objects)
│        session.commit()
│        session.close()
│        
│        print("\n Batch data inserted successfully!")
│        # Compare this snippet from webdevelopment/Initialize_greenhouse_db.py:
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── data_Intialization.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        import random
│        from datetime import datetime, timedelta
│        from sqlalchemy.orm import Session
│        from faker import Faker
│        from database_setup import (
│            Base, engine, SessionLocal,
│            UserCredentials, Device, Sensor,
│            SensorData, KalmanFilterFusionData,
│            Actuator
│        )
│        
│        fake = Faker()
│        
│        # Use same sensor IDs from your fusion logic
│        TEMP_SENSOR_IDS = [2099, 2092, 3093]
│        HUM_SENSOR_IDS = [2091, 2034, 3027]
│        ALL_SENSOR_IDS = TEMP_SENSOR_IDS + HUM_SENSOR_IDS
│        
│        def create_dummy_user(session: Session):
│            user = UserCredentials(
│                Username="test_user",
│                PasswordHash="hashed_password",
│                Email="test@example.com",
│                FullName="Test User"
│            )
│            session.add(user)
│            session.flush()  # get UserID for foreign keys
│            return user
│        
│        def create_dummy_devices(session: Session):
│            devices = []
│            for i in range(1, 4):
│                device = Device(
│                    DeviceID=1000 + i,
│                    DeviceName=f"Device_{i}",
│                    Location=fake.city()
│                )
│                session.add(device)
│                devices.append(device)
│            session.flush()
│            return devices
│        
│        def create_dummy_sensors(session: Session, devices):
│            sensors = []
│            sensor_definitions = [
│                (TEMP_SENSOR_IDS[0], devices[0], "Temperature"),
│                (TEMP_SENSOR_IDS[1], devices[1], "Temperature"),
│                (TEMP_SENSOR_IDS[2], devices[2], "Temperature"),
│                (HUM_SENSOR_IDS[0], devices[0], "Humidity"),
│                (HUM_SENSOR_IDS[1], devices[1], "Humidity"),
│                (HUM_SENSOR_IDS[2], devices[2], "Humidity"),
│            ]
│            for sensor_id, device, sensor_type in sensor_definitions:
│                sensor = Sensor(
│                    SensorID=sensor_id,
│                    DeviceID=device.DeviceID,
│                    SensorType=sensor_type,
│                    Location=device.Location
│                )
│                session.add(sensor)
│                sensors.append(sensor)
│            session.flush()
│            return sensors
│        
│        def insert_sensor_data(session: Session, sensors):
│            now = datetime.utcnow()
│            for sensor in sensors:
│                for i in range(3):  # 3 entries per sensor
│                    timestamp = now - timedelta(minutes=i)
│                    value = round(random.uniform(20.0, 35.0), 2) if "Temp" in sensor.SensorType else round(random.uniform(30.0, 80.0), 2)
│        
│                    # Raw sensor data
│                    sensor_data = SensorData(
│                        SensorID=sensor.SensorID,
│                        Timestamp=timestamp,
│                        Value=value
│                    )
│                    session.add(sensor_data)
│        
│                    # Simulated Kalman output (slightly smoothed)
│                    kalman_value = round(value + random.uniform(-1.0, 1.0), 2)
│                    kalman_data = KalmanFilterFusionData(
│                        SensorID=sensor.SensorID,
│                        Timestamp=timestamp,
│                        FusedValue=kalman_value
│                    )
│                    session.add(kalman_data)
│        
│        def create_dummy_actuators(session: Session, user, devices):
│            for i, device in enumerate(devices):
│                actuator = Actuator(
│                    ActuatorName=f"Pump_{i+1}",
│                    Status="Active" if i % 2 == 0 else "Inactive",
│                    UserID=user.UserID,
│                    DeviceID=device.DeviceID
│                )
│                session.add(actuator)
│        
│        def main():
│            Base.metadata.create_all(engine)
│            session = SessionLocal()
│        
│            try:
│                print("[INFO] Populating database with dummy data...")
│        
│                user = create_dummy_user(session)
│                devices = create_dummy_devices(session)
│                sensors = create_dummy_sensors(session, devices)
│                insert_sensor_data(session, sensors)
│                create_dummy_actuators(session, user, devices)
│        
│                session.commit()
│                print("[SUCCESS] Database populated successfully.")
│        
│            except Exception as e:
│                session.rollback()
│                print(f"[ERROR] Failed to populate database: {e}")
│            finally:
│                session.close()
│        
│        if __name__ == "__main__":
│            main()
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── database.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, ForeignKey
│        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
│        from datetime import datetime
│        
│        # ✅ SQLite Database Connection
│        DATABASE_URL = "sqlite:///greenhouse.db"
│        engine = create_engine(DATABASE_URL, echo=True)  # `echo=True` shows SQL logs
│        
│        # ✅ Base Model
│        class Base(DeclarativeBase):
│            pass
│        
│        # ✅ Devices Table (ESP32, ESP32-CAM, Raspberry Pi)
│        class Device(Base):
│            __tablename__ = "devices"
│        
│            id = Column(Integer, primary_key=True)
│            name = Column(String, unique=True)
│            type = Column(String)  # e.g., "ESP32", "ESP32-CAM", "Raspberry Pi"
│            location = Column(String)  # e.g., "Greenhouse Zone 1"
│        
│            sensors = relationship("Sensor", back_populates="device")
│        
│        # ✅ Sensors Table (Temperature, Humidity, Soil Moisture)
│        class Sensor(Base):
│            __tablename__ = "sensors"
│        
│            id = Column(Integer, primary_key=True)
│            device_id = Column(Integer, ForeignKey("devices.id"))
│            type = Column(String)  # e.g., "temperature", "humidity", "soil_moisture"
│            unit = Column(String)  # e.g., "°C", "%", "VWC"
│        
│            device = relationship("Device", back_populates="sensors")
│            readings = relationship("SensorReading", back_populates="sensor")
│        
│        # ✅ Sensor Readings Table
│        class SensorReading(Base):
│            __tablename__ = "sensor_readings"
│        
│            id = Column(Integer, primary_key=True)
│            sensor_id = Column(Integer, ForeignKey("sensors.id"))
│            value = Column(Float)
│            timestamp = Column(DateTime, default=datetime.utcnow)
│        
│            sensor = relationship("Sensor", back_populates="readings")
│        
│        # ✅ Users Table
│        class User(Base):
│            __tablename__ = "users"
│        
│            id = Column(Integer, primary_key=True)
│            username = Column(String, unique=True)
│            role = Column(String)  # e.g., "admin", "user"
│            email = Column(String, unique=True)
│        
│            actions = relationship("UserAction", back_populates="user")
│        
│        # ✅ User Actions Table
│        class UserAction(Base):
│            __tablename__ = "user_actions"
│        
│            id = Column(Integer, primary_key=True)
│            user_id = Column(Integer, ForeignKey("users.id"))
│            action_type = Column(String)  # e.g., "turn_on_fan", "water_plants"
│            action_value = Column(String)  # Any additional info (e.g., duration)
│            timestamp = Column(DateTime, default=datetime.utcnow)
│        
│            user = relationship("User", back_populates="actions")
│        
│        # ✅ Weighted Averages Table (For Dashboards)
│        class WeightedAverage(Base):
│            __tablename__ = "weighted_averages"
│        
│            id = Column(Integer, primary_key=True)
│            sensor_type = Column(String)  # "temperature", "humidity", "soil_moisture"
│            weighted_value = Column(Float)
│            timestamp = Column(DateTime, default=datetime.utcnow)
│        
│        # ✅ Create Tables in SQLite
│        Base.metadata.create_all(engine)
│        
│        # ✅ Insert Test Data
│        Session = sessionmaker(bind=engine)
│        session = Session()
│        
│        # Adding sample devices
│        device1 = Device(name="ESP32_1", type="ESP32", location="Greenhouse Zone 1")
│        session.add(device1)
│        
│        # Adding sample sensors
│        sensor1 = Sensor(device=device1, type="temperature", unit="°C")
│        session.add(sensor1)
│        
│        # Adding sample sensor reading
│        reading1 = SensorReading(sensor=sensor1, value=25.6)
│        session.add(reading1)
│        
│        # Adding a test user
│        user1 = User(username="admin", role="admin", email="admin@example.com")
│        session.add(user1)
│        
│        # Adding a test user action
│        action1 = UserAction(user=user1, action_type="water_plants", action_value="5 seconds")
│        session.add(action1)
│        
│        # Committing the session
│        session.commit()
│        session.close()
│        
│        print("\n✅ Database setup complete!")
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── dbTest.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        import sqlite3
│        
│        # Connect to the database
│        conn = sqlite3.connect("greenhouse.db")
│        cursor = conn.cursor()
│        
│        # Function to print column details for a given table
│        def show_table_structure(table_name):
│            cursor.execute(f"PRAGMA table_info({table_name});")
│            columns = cursor.fetchall()
│            print(f"\n Structure of '{table_name}' table:")
│            for col in columns:
│                print(f"Column: {col[1]} | Type: {col[2]}")
│        
│        # Get all table names
│        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
│        tables = cursor.fetchall()
│        
│        # Print structure for each table
│        for table in tables:
│            show_table_structure(table[0])
│        
│        conn.close()
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── greenhouseprev.db
│   └── simplifiedDatabase.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, ForeignKey
│        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
│        from datetime import datetime
│        
│        #  SQLite Database Connection
│        DATABASE_URL = "sqlite:///greenhouse.db"
│        engine = create_engine(DATABASE_URL, echo=True)  # `echo=True` shows SQL logs
│        
│        #  Base Model
│        class Base(DeclarativeBase):
│            pass
│        
│        #  Devices Table
│        class Device(Base):
│            __tablename__ = "devices"
│        
│            DeviceID = Column(Integer, primary_key=True)
│            DeviceName = Column(String(50), nullable=False)
│            Location = Column(String(100))
│            Status = Column(String(20))  # e.g., "Active", "Inactive"
│            Type = Column(String(50))  # e.g., "ESP32", "Raspberry Pi"
│        
│            sensor_data = relationship("SensorData", back_populates="device")
│            user_interactions = relationship("UserInteraction", back_populates="device")
│        
│        #  SensorData Table
│        class SensorData(Base):
│            __tablename__ = "sensor_data"
│        
│            DataID = Column(Integer, primary_key=True)
│            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
│            Timestamp = Column(DateTime, default=datetime.utcnow)
│            SensorType = Column(String(50))  # e.g., "temperature", "humidity"
│            Value = Column(Float)  # Sensor reading value
│        
│            device = relationship("Device", back_populates="sensor_data")
│        
│        #  UserInteractions Table
│        class UserInteraction(Base):
│            __tablename__ = "user_interactions"
│        
│            InteractionID = Column(Integer, primary_key=True)
│            UserID = Column(Integer)  # Assuming users are stored elsewhere
│            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
│            Action = Column(String(20), nullable=False)  # e.g., "Turn On", "Turn Off"
│            Timestamp = Column(DateTime, default=datetime.utcnow)
│        
│            device = relationship("Device", back_populates="user_interactions")
│        
│        #  Create Tables in SQLite
│        Base.metadata.create_all(engine)
│        
│        print("\n Greenhouse database structure created successfully!")
│        ↑↑↑ END OF FILE ↑↑↑

├── database_setup.py
     ↓↓↓ FILE CONTENT ↓↓↓
     from sqlalchemy import (
         create_engine, Column, Integer, Float, String, DateTime,
         ForeignKey, Boolean, Index
     )
     from sqlalchemy.orm import relationship, sessionmaker, declarative_base
     from datetime import datetime
     
     # Database connection
     DATABASE_URL = "sqlite:///greenhouse.db"
     engine = create_engine(DATABASE_URL, echo=True)
     SessionLocal = sessionmaker(bind=engine)
     
     # Base class
     Base = declarative_base()
     
     # UserCredentials Table
     class UserCredentials(Base):
         __tablename__ = "user_credentials"
     
         UserID = Column(Integer, primary_key=True)
         Username = Column(String(50), nullable=False, unique=True)
         PasswordHash = Column(String(128), nullable=False)
         Email = Column(String(100), nullable=False, unique=True)
         FullName = Column(String(100))
         CreatedAt = Column(DateTime, default=datetime.utcnow)
         IsActive = Column(Boolean, default=True)
     
         interactions = relationship("UserInteraction", back_populates="user", cascade="all, delete-orphan")
         actuators = relationship("Actuator", back_populates="user")
     
         def __repr__(self):
             return f"<UserCredentials(Username={self.Username}, Email={self.Email})>"
     
     # Devices Table
     class Device(Base):
         __tablename__ = "devices"
     
         DeviceID = Column(Integer, primary_key=True, autoincrement=False)
         DeviceName = Column(String(50), nullable=False)
         Location = Column(String(100))
         Status = Column(String(20), default="Active")
     
         sensors = relationship("Sensor", back_populates="device", cascade="all, delete-orphan")
         user_interactions = relationship("UserInteraction", back_populates="device", cascade="all, delete-orphan")
         actuators = relationship("Actuator", back_populates="device", cascade="all, delete-orphan")
     
         def __repr__(self):
             return f"<Device(Name={self.DeviceName}, Location={self.Location})>"
     
     # Sensors Table — NO UNIQUE CONSTRAINTS
     class Sensor(Base):
         __tablename__ = "sensors"
     
         SensorID = Column(Integer, primary_key=True, autoincrement=False)
         DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
         SensorType = Column(String(50), nullable=False)
         Location = Column(String(100))
         Status = Column(String(20), default="Active")
     
         device = relationship("Device", back_populates="sensors")
         sensor_data = relationship("SensorData", back_populates="sensor", cascade="all, delete-orphan")
         kalmanFilterFusionData = relationship("KalmanFilterFusionData", back_populates="sensor", cascade="all, delete-orphan")
     
         def __repr__(self):
             return f"<Sensor(SensorID={self.SensorID}, Type={self.SensorType}, Location={self.Location})>"
     
     # Sensor Data Table
     class SensorData(Base):
         __tablename__ = "sensor_data"
         __table_args__ = (
             Index("ix_sensor_data_sensorid_timestamp", "SensorID", "Timestamp"),
         )
     
         DataID = Column(Integer, primary_key=True)
         SensorID = Column(Integer, ForeignKey("sensors.SensorID"), nullable=False)
         Timestamp = Column(DateTime, default=datetime.utcnow)
         Value = Column(Float, nullable=False)
     
         sensor = relationship("Sensor", back_populates="sensor_data")
     
         def __repr__(self):
             return f"<SensorData(SensorID={self.SensorID}, Value={self.Value})>"
     
     # Kalman Filter Fusion Table
     class KalmanFilterFusionData(Base):
         __tablename__ = "kalman_filter_fusion"
     
         FusionID = Column(Integer, primary_key=True)
         SensorID = Column(Integer, ForeignKey("sensors.SensorID"), nullable=False)
         Timestamp = Column(DateTime, default=datetime.utcnow)
         FusedValue = Column(Float, nullable=False)
     
         sensor = relationship("Sensor", back_populates="kalmanFilterFusionData")
     
         def __repr__(self):
             return f"<KalmanFusion(SensorID={self.SensorID}, Value={self.FusedValue})>"
     
     # Weighted Average Fusion Table
     class WeightedAverageFusionData(Base):
         __tablename__ = "weighted_average_fusion"
     
         FusionID = Column(Integer, primary_key=True)
         SensorType = Column(String(50), nullable=False)
         Timestamp = Column(DateTime, default=datetime.utcnow)
         FusedValue = Column(Float, nullable=False)
     
         def __repr__(self):
             return f"<WeightedFusion(SensorType={self.SensorType}, Value={self.FusedValue})>"
     
     # Actuators Table
     class Actuator(Base):
         __tablename__ = "actuators"
     
         ActuatorID = Column(Integer, primary_key=True)
         ActuatorName = Column(String(50), nullable=False, unique=True)
         Status = Column(String(20), nullable=False, default="Inactive")
         LastUpdated = Column(DateTime, default=datetime.utcnow)
         UserID = Column(Integer, ForeignKey("user_credentials.UserID"))
         DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
     
         interactions = relationship("UserInteraction", back_populates="actuator")
         user = relationship("UserCredentials", back_populates="actuators")
         device = relationship("Device", back_populates="actuators")
     
         def __repr__(self):
             return f"<Actuator(Name={self.ActuatorName}, Status={self.Status})>"
     
     # User Interactions Table
     class UserInteraction(Base):
         __tablename__ = "user_interactions"
     
         InteractionID = Column(Integer, primary_key=True)
         UserID = Column(Integer, ForeignKey("user_credentials.UserID"), nullable=False)
         DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
         ActuatorID = Column(Integer, ForeignKey("actuators.ActuatorID"))
         Action = Column(String(20), nullable=False)
         Timestamp = Column(DateTime, default=datetime.utcnow)
     
         user = relationship("UserCredentials", back_populates="interactions")
         device = relationship("Device", back_populates="user_interactions")
         actuator = relationship("Actuator", back_populates="interactions")
     
         def __repr__(self):
             return f"<UserInteraction(UserID={self.UserID}, DeviceID={self.DeviceID}, Action={self.Action})>"
     
     # Create all tables
     Base.metadata.create_all(engine)
     ↑↑↑ END OF FILE ↑↑↑

├── directoryvis.py
     ↓↓↓ FILE CONTENT ↓↓↓
     import os
     
     # Set your root directory
     ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
     OUTPUT_FILE = os.path.join(ROOT_DIR, 'project_tree_output.txt')
     
     # File types to include for content printing
     ALLOWED_EXTENSIONS = {
         '.py', '.html', '.json', '.css', '.js', '.txt', '.md', '.csv'
     }
     
     def print_tree(path, prefix='', output_lines=None):
         """Recursively builds a tree view of the directory with file contents."""
         if output_lines is None:
             output_lines = []
     
         try:
             contents = sorted(os.listdir(path))
         except Exception as e:
             output_lines.append(prefix + f"[Error accessing {path}]: {e}")
             return output_lines
     
         pointers = ['├── '] * (len(contents) - 1) + ['└── ']
         for pointer, name in zip(pointers, contents):
             full_path = os.path.join(path, name)
             output_lines.append(prefix + pointer + name)
     
             if os.path.isdir(full_path):
                 extension = '│   ' if pointer == '├── ' else '    '
                 print_tree(full_path, prefix + extension, output_lines)
             else:
                 _, ext = os.path.splitext(name)
                 if ext.lower() in ALLOWED_EXTENSIONS:
                     try:
                         with open(full_path, 'r', encoding='utf-8') as f:
                             output_lines.append(prefix + '     ↓↓↓ FILE CONTENT ↓↓↓')
                             for line in f:
                                 output_lines.append(prefix + '     ' + line.rstrip())
                             output_lines.append(prefix + '     ↑↑↑ END OF FILE ↑↑↑\n')
                     except Exception as e:
                         output_lines.append(prefix + f'     [Error reading file: {e}]\n')
         return output_lines
     
     if __name__ == '__main__':
         tree_output = ['.']
         tree_output = print_tree(ROOT_DIR, output_lines=tree_output)
     
         # Write to file
         with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
             f.write('\n'.join(tree_output))
     
         # Print file content
         with open(OUTPUT_FILE, 'r', encoding='utf-8') as f:
             print(f.read())
     ↑↑↑ END OF FILE ↑↑↑

├── greenhouse.db
├── input
│   ├── imagecapture.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        import cv2
│        import requests
│        import numpy as np
│        import time
│        
│        # MJPEG stream URL
│        url = "http://192.168.200.76:5000/video_feed"
│        
│        # Connect to the stream
│        stream = requests.get(url, stream=True)
│        if stream.status_code != 200:
│            print("❌ Failed to connect to video stream")
│            exit()
│        
│        print("📷 Press 'b' to capture an image, 'q' to quit")
│        
│        bytes_buffer = b""
│        img_count = 0
│        
│        for chunk in stream.iter_content(chunk_size=1024):
│            bytes_buffer += chunk
│            a = bytes_buffer.find(b'\xff\xd8')
│            b = bytes_buffer.find(b'\xff\xd9')
│        
│            if a != -1 and b != -1:
│                jpg = bytes_buffer[a:b+2]
│                bytes_buffer = bytes_buffer[b+2:]
│        
│                img_np = np.frombuffer(jpg, dtype=np.uint8)
│                frame = cv2.imdecode(img_np, cv2.IMREAD_COLOR)
│                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
│        
│                if frame is not None:
│                    cv2.imshow("Live Stream", frame)
│        
│                    key = cv2.waitKey(1) & 0xFF
│                    if key == ord('b'):
│                        filename = f"snapshot_{int(time.time())}.jpg"
│                        cv2.imwrite(filename, frame)
│                        print(f"✅ Saved snapshot as {filename}")
│                    elif key == ord('q'):
│                        print("👋 Exiting...")
│                        break
│        
│        cv2.destroyAllWindows()
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── snapshot_1747066344.jpg
│   ├── snapshot_1747066357.jpg
│   └── snapshot_1747066365.jpg
├── kalman_filter_readings_4_weighted_AVG.py
     ↓↓↓ FILE CONTENT ↓↓↓
     from sqlalchemy.orm import Session
     from datetime import timedelta
     import pandas as pd
     from database_setup import SessionLocal, KalmanFilterFusionData
     
     # Start DB session
     session: Session = SessionLocal()
     
     # Step 1: Get latest timestamp
     latest_entry = session.query(KalmanFilterFusionData).order_by(
         KalmanFilterFusionData.Timestamp.desc()
     ).first()
     
     if latest_entry:
         latest_timestamp = latest_entry.Timestamp
         start_timestamp = latest_timestamp - timedelta(minutes=20)
     
         # Step 2: Query data within the latest 20-minute window
         results = session.query(KalmanFilterFusionData).filter(
             KalmanFilterFusionData.Timestamp.between(start_timestamp, latest_timestamp)
         ).order_by(KalmanFilterFusionData.Timestamp.asc()).all()
     
         # Step 3: Convert to DataFrame
         df = pd.DataFrame([{
             "Timestamp": r.Timestamp,
             f"{r.SensorID}": r.FusedValue
         } for r in results])
     
         # Step 4: Pivot based on SensorID (aggregated on Timestamp)
         df_pivoted = df.pivot_table(
             index="Timestamp",
             aggfunc="first"  # If multiple values exist per sensor & timestamp, take the first
         )
     
         # Optional: sort columns by SensorID
         df_pivoted = df_pivoted[sorted(df_pivoted.columns, key=int)]
     
         # Step 5: Save to CSV
         df_pivoted.to_csv("kalman_latest_20min_pivoted.csv")
         print("✅ Pivoted CSV 'kalman_latest_20min_pivoted.csv' saved.")
     else:
         print("⚠️ No data found in KalmanFilterFusionData.")
     
     # Step 6: Close DB session
     session.close()
     ↑↑↑ END OF FILE ↑↑↑

├── network.py
     ↓↓↓ FILE CONTENT ↓↓↓
     from flask import request, jsonify
     from time import sleep
     from datetime import datetime
     import logging
     
     from network_utils.auth import authenticate_request
     from network_utils.sensor_storage import store_sensor_data
     from network_utils.fusion_utils import get_latest_fused_temperature_humidity, get_fused_values_by_sensors
     from network_utils.actions import action_based_on_sensor
     from network_utils.constants import soil_sensor_1id, soil_sensor_2id
     from database_setup import SessionLocal, Actuator
     
     # Configure logging
     logging.basicConfig(level=logging.INFO)
     logger = logging.getLogger(__name__)
     
     def receive_sensor_data(request):
         if not authenticate_request(request):
             return jsonify({"error": "Unauthorized"}), 401
     
         try:
             data = request.get_json()
             print(f"Recived paylaod: {data}")
             if not data:
                 return jsonify({"error": "Invalid or missing JSON payload"}), 400
     
             time = datetime.utcnow()
             device_id = data.get('DeviceID')
             device_name = data.get('DeviceName')
             actuator_id = data.get('ActuatorID')
             actuator_status = data.get('ActuatorState')
             sensor_ids = data.get("SensorID", [])
     
             temperatures = data.get("temperature", [])
             filtered_temperatures = data.get("filtered_temperature", [])
             humidities = data.get("humidity", [])
             filtered_humidities = data.get("filtered_humidity", [])
             soil_moistures = data.get("soil_moisture", [])
             filtered_soil_moistures = data.get("filtered_soil_moisture", [])
     
             with SessionLocal() as session:
                 for i, sensor_id in enumerate(sensor_ids):
                     if i < len(temperatures) and i < len(filtered_temperatures):
                         if temperatures[i] > 0 and filtered_temperatures[i] > 0:
                             store_sensor_data(session, device_id, device_name, sensor_id,
                                               temperature=temperatures[i],
                                               filtered_temperature=filtered_temperatures[i],
                                               timestamp=time)
     
                     if i < len(humidities) and i < len(filtered_humidities):
                         if humidities[i] > 0 and filtered_humidities[i] > 0:
                             store_sensor_data(session, device_id, device_name, sensor_id,
                                               humidity=humidities[i],
                                               filtered_humidity=filtered_humidities[i],
                                               timestamp=time)
     
                     if i < len(soil_moistures) and i < len(filtered_soil_moistures):
                         if soil_moistures[i] > 0 and filtered_soil_moistures[i] > 0:
                             store_sensor_data(session, device_id, device_name, sensor_id,
                                               soil_moisture=soil_moistures[i],
                                               filtered_soil_moisture=filtered_soil_moistures[i],
                                               timestamp=time)
     
                     logger.info(f"Received data from DeviceID: {device_id}, SensorID: {sensor_id}")
     
                 # Handle actuator state
                 if actuator_id is not None and actuator_status is not None:
                     actuator = session.query(Actuator).filter(Actuator.ActuatorID == actuator_id).first()
                     if actuator:
                         actuator.Status = actuator_status
                         actuator.LastUpdated = time
                         logger.info(f"Updated Actuator {actuator_id} to {actuator_status}")
                         session.commit()
                     else:
                         try:
                             new_actuator = Actuator(
                                 ActuatorID=actuator_id,
                                 ActuatorName=f"Auto_Actuator_{actuator_id}",
                                 Status=actuator_status,
                                 UserID=5000,  # Automatic control
                                 DeviceID=device_id,
                                 LastUpdated=time
                             )
                             session.add(new_actuator)
                             logger.info(f"Created new Actuator with ID {actuator_id} and status {actuator_status}")
                         except Exception as e:
                             session.rollback()
                             logger.warning(f"Failed to insert new actuator — error: {e}")
     
                 action_result = action_based_on_sensor()
     
                 latest = get_latest_fused_temperature_humidity(session)
                 soil_data = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
                 avg_soil = sum(soil_data.values()) / len(soil_data) if soil_data else None
     
                 session.commit()
     
             sleep(5)  # Optional delay
     
             return jsonify({
                 "status": "success",
                 "action": action_result,
                 "temperature": latest.get("temperature"),
                 "humidity": latest.get("humidity"),
                 "soil_moisture": avg_soil
             }), 200
     
         except Exception as e:
             logger.error(f"Failed to receive/process sensor data: {e}")
             return jsonify({"error": "Internal Server Error"}), 500
     
     
     ↑↑↑ END OF FILE ↑↑↑

├── network_utils
│   ├── __init__.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── __pycache__
│   │   ├── __init__.cpython-312.pyc
│   │   ├── __init__.cpython-313.pyc
│   │   ├── actions.cpython-312.pyc
│   │   ├── actions.cpython-313.pyc
│   │   ├── actuator_control.cpython-312.pyc
│   │   ├── actuator_control.cpython-313.pyc
│   │   ├── auth.cpython-312.pyc
│   │   ├── auth.cpython-313.pyc
│   │   ├── config_handler.cpython-312.pyc
│   │   ├── config_handler.cpython-313.pyc
│   │   ├── constants.cpython-312.pyc
│   │   ├── constants.cpython-313.pyc
│   │   ├── device_utils.cpython-312.pyc
│   │   ├── device_utils.cpython-313.pyc
│   │   ├── fusion_utils.cpython-312.pyc
│   │   ├── fusion_utils.cpython-313.pyc
│   │   ├── sensor_storage.cpython-312.pyc
│   │   ├── sensor_storage.cpython-313.pyc
│   │   ├── status.cpython-312.pyc
│   │   ├── status.cpython-313.pyc
│   │   └── user_control.cpython-313.pyc
│   ├── actions.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from .fusion_utils import get_fused_values_by_sensors
│        from .actuator_control import control_actuator
│        from .config_handler import load_config
│        from weightedAverage import process_weighted_fusion
│        from database_setup import SessionLocal, WeightedAverageFusionData
│        from .constants import *
│        
│        
│        def action_based_on_sensor(user_id=DEFAULT_USER_ID):
│            print("[DEBUG] action.py loaded successfully.")
│        
│            # Load dynamic thresholds
│            config = load_config()
│            TEMP_THRESHOLD = config.get("TEMP_THRESHOLD", 27)
│            HUM_THRESHOLD = config.get("HUM_THRESHOLD", 80)
│            SOIL_MOISTURE_THRESHOLD = config.get("SOIL_MOISTURE_THRESHOLD", 4000)
│        
│            with SessionLocal() as session:
│                # Get fused soil moisture readings
│                result = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
│                soil1 = result.get(soil_sensor_1id)
│                soil2 = result.get(soil_sensor_2id)
│                soil_moisture = None
│        
│                if soil1 is not None and soil2 is not None:
│                    avg = (soil1 + soil2) / 2
│                    if 0 <= avg <= 5000:
│                        soil_moisture = avg
│                elif soil1 and 0 <= soil1 <= 5000:
│                    soil_moisture = soil1
│                elif soil2 and 0 <= soil2 <= 5000:
│                    soil_moisture = soil2
│                else:
│                    print("[WARNING] Invalid soil moisture readings, using None.")
│        
│                # Update fusion values
│                process_weighted_fusion(sensor_ids=TEMP_SENSOR_IDS, weights=WEIGHTS, sensor_type="temperature")
│                process_weighted_fusion(sensor_ids=HUM_SENSOR_IDS, weights=WEIGHTS, sensor_type="humidity")
│        
│                # Get latest temperature
│                temperature_record = session.query(WeightedAverageFusionData) \
│                    .filter(WeightedAverageFusionData.SensorType == "temperature") \
│                    .order_by(WeightedAverageFusionData.Timestamp.desc()) \
│                    .first()
│                temperature = temperature_record.FusedValue if temperature_record else None
│                if temperature is None:
│                    print("[WARNING] No temperature data found.")
│        
│                # Get latest humidity
│                humidity_record = session.query(WeightedAverageFusionData) \
│                    .filter(WeightedAverageFusionData.SensorType == "humidity") \
│                    .order_by(WeightedAverageFusionData.Timestamp.desc()) \
│                    .first()
│                humidity = humidity_record.FusedValue if humidity_record else None
│                if humidity is None:
│                    print("[WARNING] No humidity data found.")
│        
│                actions = []
│        
│                try:
│                    # --- VENTILATION CONTROL ---
│                    if temperature is not None and humidity is not None:
│                        if temperature > TEMP_THRESHOLD or humidity > HUM_THRESHOLD:
│                            control_actuator(session, VENTILATION_FAN, "on", user_id)
│                            control_actuator(session, INTAKE_SHUTTER, "on", user_id)
│                            actions.append("Ventilation_ON")
│                        else:
│                            control_actuator(session, VENTILATION_FAN, "off", user_id)
│                            control_actuator(session, INTAKE_SHUTTER, "off", user_id)
│                            actions.append("Ventilation_OFF")
│        
│                    # --- IRRIGATION CONTROL ---
│                    if soil_moisture is not None:
│                        if soil_moisture < SOIL_MOISTURE_THRESHOLD:
│                            control_actuator(session, WATER_PUMP, "on", user_id)
│                            actions.append("Irrigation_ON")
│                        else:
│                            control_actuator(session, WATER_PUMP, "off", user_id)
│                            actions.append("Irrigation_OFF")
│        
│                    session.commit()
│                    print("[DEBUG] actions.py [WORKED]")
│                    print(f"[DEBUG] Thresholds: TEMP={TEMP_THRESHOLD}, HUM={HUM_THRESHOLD}, SOIL={SOIL_MOISTURE_THRESHOLD}")
│                    print(f"[DEBUG] Readings: TEMP={temperature}, HUM={humidity}, SOIL={soil_moisture}")
│                    print(f"[DEBUG] Actions performed: {actions}")
│                    return ", ".join(actions) if actions else "none"
│        
│                except Exception as e:
│                    session.rollback()
│                    print(f"[ERROR] Failed to perform action: {e}")
│                    return "error"
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── actuator_control.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from datetime import datetime
│        from database_setup import Actuator, UserInteraction
│        
│        def log_user_action(session, device_id, action, user_id, actuator_id):
│            print("[DEBUG] actuator_control.py/log_user_action loaded successfully.")
│            session.add(UserInteraction(
│                DeviceID=device_id,
│                Action=action,
│                UserID=user_id,
│                ActuatorID=actuator_id,
│                Timestamp=datetime.utcnow()))
│            print("[DEBUG] actuator_control.py/log_user_action loaded successfully [WORKED].")
│        
│        def control_actuator(session, actuator_name, status, user_id):
│            print("[DEBUG] actuator_control.py/control_actuator loaded successfully.")
│            actuator = session.query(Actuator).filter_by(ActuatorName=actuator_name).first()
│            if not actuator:
│                actuator = Actuator(ActuatorName=actuator_name, Status=status, LastUpdated=datetime.utcnow(), UserID=user_id)
│                session.add(actuator)
│            else:
│                if actuator.Status != status:
│                    actuator.Status = status
│                    actuator.LastUpdated = datetime.utcnow()
│                    actuator.UserID = user_id
│                    log_user_action(session, actuator.ActuatorID, f"{actuator_name}_{status.lower()}", user_id, actuator.ActuatorID)
│            session.commit()
│            print("[DEBUG] actuator_control.py/control_actuator loaded successfully [WORKED].")
│            return actuator
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── auth.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from flask import request, jsonify, Blueprint, render_template, redirect, url_for, flash, session
│        from werkzeug.security import generate_password_hash, check_password_hash
│        from database_setup import SessionLocal, UserCredentials
│        from .constants import credentials
│        
│        def authenticate_request(request):
│            auth = request.authorization
│            print("[DEBUG] auth.py loaded successfully.")
│            if not auth or credentials.get(auth.username) != auth.password:
│                return False
│            return True
│        
│        auth_bp = Blueprint('auth', __name__)
│        
│        @auth_bp.route("/signup", methods=["GET", "POST"])
│        def signup():
│            if request.method == "POST":
│                email = request.form.get("email")
│                username = request.form.get("username")
│                full_name = request.form.get("full_name")
│                password = request.form.get("password")
│        
│                db = SessionLocal()
│                existing_user = db.query(UserCredentials).filter_by(Email=email).first()
│        
│                if existing_user:
│                    flash("Email already exists.", "error")
│                    db.close()
│                    return redirect(url_for("auth.signup"))
│        
│                hashed_pw = generate_password_hash(password)
│                new_user = UserCredentials(
│                    Email=email,
│                    Username=username,
│                    FullName=full_name,
│                    PasswordHash=hashed_pw
│                )
│                db.add(new_user)
│                db.commit()
│                db.close()
│        
│                flash("Account created! Please log in.", "success")
│                return redirect(url_for("auth.login"))
│        
│            return render_template("signup.html",hide_nav=True)
│        
│        @auth_bp.route("/login", methods=["GET", "POST"])
│        def login():
│            if request.method == "POST":
│                email = request.form.get("email")
│                password = request.form.get("password")
│        
│                db = SessionLocal()
│                user = db.query(UserCredentials).filter_by(Email=email).first()
│        
│                if user and check_password_hash(user.PasswordHash, password):
│                    session["user_id"] = user.UserID
│                    session["username"] = user.Username
│                    session.permanent = False  # 🟢 Session ends when browser/tab closes
│                    db.close()
│                    flash("Login successful!", "success")
│                    return redirect(url_for("index"))
│                else:
│                    flash("Invalid email or password.", "error")
│                    db.close()
│                    return redirect(url_for("auth.login"))
│        
│            return render_template("login.html", hide_nav=True)
│        
│        @auth_bp.route("/logout", methods=["GET", "POST"])
│        def logout():
│            session.clear()
│        
│            if request.method == "POST":
│                return "", 204  # for navigator.sendBeacon()
│        
│            flash("Logged out successfully.", "info")
│            return redirect(url_for("auth.login"))
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── config.json
│        ↓↓↓ FILE CONTENT ↓↓↓
│        {
│            "TEMP_THRESHOLD": 39,
│            "HUM_THRESHOLD": 62,
│            "SOIL_MOISTURE_THRESHOLD": 5405
│        }
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── config_handler.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        import json
│        import os
│        
│        CONFIG_PATH = os.path.join(os.path.dirname(__file__), 'config.json')
│        
│        def load_config():
│            if not os.path.exists(CONFIG_PATH):
│                # Return default config if the file doesn't exist
│                return {
│                    "TEMP_THRESHOLD": 27,
│                    "HUM_THRESHOLD": 80,
│                    "SOIL_MOISTURE_THRESHOLD": 4000
│                }
│            with open(CONFIG_PATH, 'r') as file:
│                return json.load(file)
│        
│        def save_config(config):
│            with open(CONFIG_PATH, 'w') as file:
│                json.dump(config, file, indent=4)
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── constants.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        credentials = {
│            "Ventilation_System_ESP": "password",
│            "Irrigation_System_ESP": "password",
│            "web_control": "web_password"
│        }
│        
│        DEFAULT_USER_ID = 5000
│        
│        
│        
│        TEMP_SENSOR_IDS = [2001, 2003, 3001]
│        HUM_SENSOR_IDS = [2002, 2004, 3002]
│        WEIGHTS = [0.5, 0.3, 0.2]
│        
│        INTAKE_SHUTTER = "intake_shutter"
│        WATER_PUMP = "water_pump"
│        VENTILATION_FAN = "ventilation_fan"
│        
│        Ventilation_System_ESP_ID = 2000
│        Irrigation_System_ESP_ID = 3000
│        
│        soil_sensor_1id = 2005
│        soil_sensor_2id = 3005
│        
│        print("[DEBUG] constants.py loaded successfully.")
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── device_utils.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from database_setup import Device, Sensor
│        from sqlalchemy.orm import Session
│        
│        def get_or_create_device(session: Session, device_id, device_name):
│            print("[DEBUG] device_utils.py/get_or_create_device loaded successfully.")
│            device = session.query(Device).filter_by(DeviceID=device_id).first()
│            if not device:
│                device = Device(DeviceID=device_id, DeviceName=device_name, Location="Unknown", Status="Active")
│                session.add(device)
│                session.commit()
│                session.refresh(device)
│            print("[DEBUG] device_utils.py/get_or_create_device[WORKED].")
│            return device
│        
│        def get_or_create_sensor(session: Session, sensor_id, device_id, sensor_type):
│            print("[DEBUG] device_utils.py/get_or_create_sensor loaded successfully.")
│        
│            sensor = session.query(Sensor).filter_by(SensorID=sensor_id).first()
│            if not sensor:
│                # Create new sensor if none exists with this SensorID
│                sensor = Sensor(SensorID=sensor_id, DeviceID=device_id, SensorType=sensor_type, Location="Unknown", Status="Active")
│                session.add(sensor)
│                session.commit()
│                session.refresh(sensor)
│            else:
│                # Optionally update sensor_type or other fields if different
│                if sensor.SensorType != sensor_type:
│                    sensor.SensorType = sensor_type
│                    session.commit()
│        
│            print("[DEBUG] device_utils.py/get_or_create_sensor[WORKED].")
│            return sensor
│        
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── fusion_utils.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from sqlalchemy import desc
│        from database_setup import KalmanFilterFusionData, WeightedAverageFusionData
│        
│        def get_fused_values_by_sensors(session, *sensor_ids):
│            print("[DEBUG] fusion_utils.py/get_fused_values_by_sensors loaded successfully.")
│            print(f"[DEBUG] fusion_utils.py/get_fused_values_by_sensors called with sensor_ids: {sensor_ids}")
│            fused = {}
│            for sensor_id in sensor_ids:
│                fusion = session.query(KalmanFilterFusionData).filter_by(SensorID=sensor_id).order_by(desc(KalmanFilterFusionData.Timestamp)).first()
│                if fusion:
│                    fused[sensor_id] = fusion.FusedValue
│            print("[DEBUG] fusion_utils.py/get_fused_values_by_sensors [WORKED].")
│            return fused
│        
│        def get_latest_fused_temperature_humidity(session):
│            print("[DEBUG] fusion_utils.py/get_latest_fused_temperature_humidity loaded successfully.")
│            temp = session.query(WeightedAverageFusionData).filter_by(SensorType="temperature").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
│            hum = session.query(WeightedAverageFusionData).filter_by(SensorType="humidity").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
│            print("[DEBUG] fusion_utils.py/get_latest_fused_temperature_humidity [WORKED].")
│            return {
│                "temperature": temp.FusedValue if temp else None,
│                "humidity": hum.FusedValue if hum else None
│            }
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── sensor_storage.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from datetime import datetime
│        from database_setup import SensorData, KalmanFilterFusionData
│        from .device_utils import get_or_create_device, get_or_create_sensor
│        
│        def store_sensor_value(session, sensor, value, time):
│            print("[DEBUG] sensor_storage.py/store_sensor_value loaded successfully.")
│            session.add(SensorData(SensorID=sensor.SensorID, Value=value, Timestamp=time))
│            print("[DEBUG] sensor_storage.py/store_sensor_value [WORKED].")
│        
│        def store_sensor_fused_value(session, sensor, value, time):
│            print("[DEBUG] sensor_storage.py/store_sensor_fused_value loaded successfully.")
│            session.add(KalmanFilterFusionData(SensorID=sensor.SensorID, FusedValue=value, Timestamp=time))
│            print("[DEBUG] sensor_storage.py/store_sensor_fused_value [WORKED].")
│        
│        def store_sensor_data(session, device_id, device_name, sensor_id,
│                              temperature=None, filtered_temperature=None,
│                              humidity=None, filtered_humidity=None,
│                              soil_moisture=None, filtered_soil_moisture=None, timestamp=None):
│            get_or_create_device(session, device_id, device_name)
│            print("[DEBUG] sensor_storage.py/store_sensor_data loaded successfully.")
│            if temperature is not None:
│                sensor = get_or_create_sensor(session, sensor_id, device_id, "temperature")
│                store_sensor_value(session, sensor, temperature, timestamp)
│            if filtered_temperature is not None:
│                sensor = get_or_create_sensor(session, sensor_id, device_id, "temperature")
│                store_sensor_fused_value(session, sensor, filtered_temperature, timestamp)
│            if humidity is not None:
│                sensor = get_or_create_sensor(session, sensor_id, device_id, "humidity")
│                store_sensor_value(session, sensor, humidity, timestamp)
│            if filtered_humidity is not None:
│                sensor = get_or_create_sensor(session, sensor_id, device_id, "humidity_filtered")
│                store_sensor_fused_value(session, sensor, filtered_humidity, timestamp)
│            if soil_moisture is not None:
│                sensor = get_or_create_sensor(session, sensor_id, device_id, "soil_moisture")
│                store_sensor_value(session, sensor, soil_moisture,timestamp)
│            if filtered_soil_moisture is not None:
│                sensor = get_or_create_sensor(session, sensor_id, device_id, "soil_moisture_filtered")
│                store_sensor_fused_value(session, sensor, filtered_soil_moisture, timestamp)
│            session.commit()
│            print("[DEBUG] sensor_storage.py/store_sensor_data [WORKED].")
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── status.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from flask import Blueprint, render_template, jsonify
│        from .fusion_utils import get_fused_values_by_sensors
│        from database_setup import SessionLocal, WeightedAverageFusionData
│        from .constants import soil_sensor_1id, soil_sensor_2id
│        
│        status_bp = Blueprint('status', __name__)
│        
│        @status_bp.route("/status")
│        def status_page():
│            return render_template("index.html")
│        
│        @status_bp.route("/api/latest-fused-values")
│        def latest_fused_values():
│            temperature = None
│            humidity = None
│            soil_moisture = None
│        
│            try:
│                with SessionLocal() as session:
│                    # --- Latest Soil Moisture ---
│                    result = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
│                    soil1 = result.get(soil_sensor_1id)
│                    soil2 = result.get(soil_sensor_2id)
│        
│                    valid_soil_values = [v for v in [soil1, soil2] if v is not None and 0 <= v <= 5000]
│                    if valid_soil_values:
│                        soil_moisture = sum(valid_soil_values) / len(valid_soil_values)
│                    else:
│                        print("[WARNING] No valid soil moisture readings found.")
│        
│                    # --- Latest Temperature ---
│                    temp_record = session.query(WeightedAverageFusionData)\
│                        .filter(WeightedAverageFusionData.SensorType == "temperature")\
│                        .order_by(WeightedAverageFusionData.Timestamp.desc())\
│                        .first()
│        
│                    if temp_record:
│                        temperature = temp_record.FusedValue
│                    else:
│                        print("[WARNING] No temperature data found.")
│        
│                    # --- Latest Humidity ---
│                    hum_record = session.query(WeightedAverageFusionData)\
│                        .filter(WeightedAverageFusionData.SensorType == "humidity")\
│                        .order_by(WeightedAverageFusionData.Timestamp.desc())\
│                        .first()
│        
│                    if hum_record:
│                        humidity = hum_record.FusedValue
│                    else:
│                        print("[WARNING] No humidity data found.")
│        
│            except Exception as e:
│                print(f"[ERROR] Failed to fetch latest fused values: {e}")
│        
│            return jsonify({
│                "temperature": temperature,
│                "humidity": humidity,
│                "soil_moisture": soil_moisture
│            })
│        ↑↑↑ END OF FILE ↑↑↑

│   └── user_control.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from datetime import datetime
│        from database_setup import UserInteraction, SessionLocal, Actuator
│        
│        def handle_manual_control(payload):
│        
│            user_id = payload.get("user_id")
│            actuator_id = payload.get("actuator_id")
│            action = payload.get("action")
│            time = datetime.utcnow()
│        
│            if not all([user_id, actuator_id, action]):
│                return {"status": "error", "message": "Missing required fields"}
│        
│            with SessionLocal() as session:
│                actuator = session.query(Actuator).filter(Actuator.ActuatorID == actuator_id).first()
│                if not actuator:
│                    actuator = Actuator(
│                        ActuatorID=actuator_id,
│                        ActuatorName=f"Manual_Actuator_{actuator_id}",
│                        Status=action,
│                        UserID=user_id,
│                        LastUpdated=time
│                    )
│                    session.add(actuator)
│                else:
│                    actuator.Status = action
│                    actuator.UserID = user_id
│                    actuator.LastUpdated = time
│        
│                try:
│                    device_id = actuator.DeviceID if actuator.DeviceID else 1001  # fallback
│                    session.add(UserInteraction(
│                        UserID=user_id,
│                        DeviceID=device_id,
│                        ActuatorID=actuator_id,
│                        Action=action,
│                        Timestamp=time
│                    ))
│                    session.commit()
│                    return {"status": "success", "message": f"Manual action '{action}' recorded."}
│                except Exception as e:
│                    session.rollback()
│                    return {"status": "error", "message": str(e)}
│        ↑↑↑ END OF FILE ↑↑↑

├── project_tree_output.txt
     ↓↓↓ FILE CONTENT ↓↓↓
     .
     ├── .gitattributes
     ├── AI_model.py
          ↓↓↓ FILE CONTENT ↓↓↓
          import os
          import cv2
          from ultralytics import YOLO
     
          # Load YOLO model once
          model = YOLO('best.pt')
          print("[INFO] Model loaded. Classes:", model.names)
     
          def process_frame(frame):
              results = model(frame)
              for result in results:
                  for box in result.boxes:
                      x1, y1, x2, y2 = map(int, box.xyxy[0])
                      conf = box.conf[0].item()
                      cls = int(box.cls[0].item())
                      class_name = model.names.get(cls, f'Class {cls}')
                      label = f'{class_name} {conf:.2f}'
     
                      cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
                      (w, h), _ = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.7, 2)
                      cv2.rectangle(frame, (x1, y1 - h - 5), (x1 + w, y1), (0, 255, 0), -1)
                      cv2.putText(frame, label, (x1, y1), cv2.FONT_HERSHEY_SIMPLEX,
                                  0.7, (0, 0, 0), 2, cv2.LINE_AA)
              return frame
     
          def process_images_in_directory(input_dir, output_dir):
              os.makedirs(output_dir, exist_ok=True)
              supported_ext = ['.jpg', '.jpeg', '.png', '.bmp']
     
              for filename in os.listdir(input_dir):
                  if any(filename.lower().endswith(ext) for ext in supported_ext):
                      image_path = os.path.join(input_dir, filename)
                      frame = cv2.imread(image_path)
                      if frame is None:
                          print(f"[WARNING] Couldn't read {filename}, skipping.")
                          continue
     
                      processed_frame = process_frame(frame)
                      output_path = os.path.join(output_dir, filename)
                      cv2.imwrite(output_path, processed_frame)
                      print(f"[INFO] Processed and saved: {output_path}")
     
          if __name__ == '__main__':
              process_images_in_directory('input', 'static/predictions')
          ↑↑↑ END OF FILE ↑↑↑
     
     ├── __pycache__
     │   ├── AI_model.cpython-313.pyc
     │   ├── dashboard.cpython-313.pyc
     │   ├── database_setup.cpython-313.pyc
     │   ├── network.cpython-313.pyc
     │   └── weightedAverage.cpython-313.pyc
     ├── app.py
          ↓↓↓ FILE CONTENT ↓↓↓
          from flask import Flask, render_template, request, jsonify, url_for, redirect
          from dashboard import dashboard_bp
          from network_utils.status import status_bp
          from network import receive_sensor_data
          from AI_model import process_images_in_directory
          import os
          from network_utils.config_handler import load_config, save_config
     
          app = Flask(__name__)
     
          # Folders for image input/output
          INPUT_DIR = 'input'
          OUTPUT_DIR = 'static/predictions'
     
          # Register blueprints
          app.register_blueprint(dashboard_bp)
          app.register_blueprint(status_bp)
     
          @app.route('/')
          def index():
              return render_template('index.html')
     
          @app.route('/run', methods=['POST'])
          def run_yolo():
              process_images_in_directory(INPUT_DIR, OUTPUT_DIR)
              return redirect(url_for('ai_model'))
     
          @app.route('/results')
          def ai_model():
              images = [
                  f for f in os.listdir(OUTPUT_DIR)
                  if f.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp'))
              ]
              return render_template('ai_model.html', images=images)
     
          @app.route('/receive', methods=['POST'])
          def receive_data():
              return receive_sensor_data(request)
     
          @app.route('/get_thresholds')
          def get_thresholds():
              return jsonify(load_config())
     
          @app.route('/set_thresholds', methods=['POST'])
          def set_thresholds():
              data = request.get_json()
              try:
                  config = load_config()
                  config["TEMP_THRESHOLD"] = int(data.get("temp_threshold", config["TEMP_THRESHOLD"]))
                  config["HUM_THRESHOLD"] = int(data.get("hum_threshold", config["HUM_THRESHOLD"]))
                  config["SOIL_MOISTURE_THRESHOLD"] = int(data.get("soil_moisture_threshold", config["SOIL_MOISTURE_THRESHOLD"]))
                  save_config(config)
                  print("[DEBUG] Thresholds updated:", config)
                  return jsonify({"message": "Thresholds updated successfully."})
              except Exception as e:
                  return jsonify({"message": f"Error: {str(e)}"}), 400
     
          if __name__ == '__main__':
              app.run(host='0.0.0.0', port=5000)
          ↑↑↑ END OF FILE ↑↑↑
     
     ├── best.pt
     ├── dashboard.py
          ↓↓↓ FILE CONTENT ↓↓↓
          from flask import Blueprint, render_template, jsonify
          from database_setup import SessionLocal, SensorData, KalmanFilterFusionData, WeightedAverageFusionData
          from collections import defaultdict
          import json
     
          dashboard_bp = Blueprint('dashboard', __name__)
     
          sensor_labels = {
              2001: "Temperature - DHT1 Internal",
              2002: "Humidity - DHT1 Internal",
              2003: "Temperature - DHT2 Internal",
              2004: "Humidity - DHT2 Internal",
              2005: "Soil Moisture - Plant 1",
              3001: "Temperature - DHT3 Internal",
              3002: "Humidity - DHT3 Internal",
              3003: "Temperature - DHT4 External",
              3004: "Humidity - DHT4 External",
              3005: "Soil Moisture - Plant 2"
          }
     
          @dashboard_bp.route("/dashboard")
          def dashboard():
              return render_template("dashboard.html")
     
     
          @dashboard_bp.route("/api/dashboard-data")
          def dashboard_data():
              session = SessionLocal()
              try:
                  # --- RAW SENSOR DATA ---
                  raw_data = session.query(SensorData).order_by(SensorData.Timestamp).limit(100).all()
                  grouped_raw = defaultdict(list)
                  for entry in raw_data:
                      grouped_raw[entry.SensorID].append({
                          "timestamp": entry.Timestamp.isoformat(),
                          "value": entry.Value
                      })
     
                  raw_plot_data = [
                      {
                          "label": sensor_labels.get(sensor_id, f"Sensor {sensor_id}"),
                          "sensor_id": sensor_id,
                          "timestamps": [d["timestamp"] for d in data],
                          "values": [d["value"] for d in data]
                      }
                      for sensor_id, data in grouped_raw.items()
                  ]
     
                  # --- KALMAN FILTER FUSION DATA ---
                  kalman_data = session.query(KalmanFilterFusionData).order_by(KalmanFilterFusionData.Timestamp).limit(100).all()
                  grouped_kalman = defaultdict(list)
                  for entry in kalman_data:
                      grouped_kalman[entry.SensorID].append({
                          "timestamp": entry.Timestamp.isoformat(),
                          "value": entry.FusedValue
                      })
                  kalman_plot_data = [
                      {
                          "label": sensor_labels.get(sensor_id, f"Sensor {sensor_id}"),
                          "sensor_id": sensor_id,
                          "timestamps": [d["timestamp"] for d in data],
                          "values": [d["value"] for d in data]
                      }
                      for sensor_id, data in grouped_kalman.items()
                  ]
     
                  # --- WEIGHTED AVERAGE FUSION DATA ---
                  weighted_data = session.query(WeightedAverageFusionData).order_by(WeightedAverageFusionData.Timestamp).limit(100).all()
                  grouped_weighted = defaultdict(list)
                  for entry in weighted_data:
                      grouped_weighted[entry.SensorType].append({
                          "timestamp": entry.Timestamp.isoformat(),
                          "value": entry.FusedValue
                      })
                  weighted_plot_data = [
                      {
                          "sensor_type": sensor_type,
                          "timestamps": [d["timestamp"] for d in data],
                          "values": [d["value"] for d in data]
                      }
                      for sensor_type, data in grouped_weighted.items()
                  ]
     
                  return jsonify({
                      "raw": raw_plot_data,
                      "kalman": kalman_plot_data,
                      "weighted": weighted_plot_data
                  })
     
              finally:
                  session.close()
          ↑↑↑ END OF FILE ↑↑↑
     
     ├── data_retrival.py
          ↓↓↓ FILE CONTENT ↓↓↓
          from sqlalchemy.orm import sessionmaker
          from database_setup import engine, Actuator, UserInteraction
          import pandas as pd
     
          # Create session
          Session = sessionmaker(bind=engine)
          session = Session()
     
          # === Fetch last row from Actuator table ===
          last_actuator = (
              session.query(Actuator)
              .order_by(Actuator.LastUpdated.desc())
              .first()
          )
     
          # Convert to dict
          actuator_data = {
              "ActuatorID": last_actuator.ActuatorID,
              "ActuatorName": last_actuator.ActuatorName,
              "Status": last_actuator.Status,
              "LastUpdated": last_actuator.LastUpdated,
              "UserID": last_actuator.UserID,
              "DeviceID": last_actuator.DeviceID
          } if last_actuator else {}
     
          # === Fetch last row from UserInteraction table ===
          last_interaction = (
              session.query(UserInteraction)
              .order_by(UserInteraction.Timestamp.desc())
              .first()
          )
     
          # Convert to dict
          interaction_data = {
              "InteractionID": last_interaction.InteractionID,
              "UserID": last_interaction.UserID,
              "DeviceID": last_interaction.DeviceID,
              "ActuatorID": last_interaction.ActuatorID,
              "Action": last_interaction.Action,
              "Timestamp": last_interaction.Timestamp
          } if last_interaction else {}
     
          # Close session
          session.close()
     
          # Print output
          print("\n=== Last Actuator Entry ===")
          print(pd.DataFrame([actuator_data]))
     
          print("\n=== Last UserInteraction Entry ===")
          print(pd.DataFrame([interaction_data]))
          ↑↑↑ END OF FILE ↑↑↑
     
     ├── databaseTests
     │   ├── Initialize_greenhouse_db.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from sqlalchemy.orm import Session, sessionmaker, DeclarativeBase
     │        from database_setup import engine, Device, SensorData
     │
     │        Session = sessionmaker(bind=engine)
     │        session = Session()
     │
     │        #  Example: Insert multiple temperature readings at once
     │        sensor_readings = [
     │            {"DeviceID": 1, "SensorType": "humidity", "Value": 21.2},
     │            {"DeviceID": 2, "SensorType": "humidity", "Value": 22.2},
     │            {"DeviceID": 3, "SensorType": "humidity", "Value": 23.4},
     │            {"DeviceID": 4, "SensorType": "humidity", "Value": 24.4},
     │            {"DeviceID": 5, "SensorType": "temperature", "Value": 42.2},
     │            {"DeviceID": 6, "SensorType": "temperature", "Value": 41.2},
     │            {"DeviceID": 7, "SensorType": "temperature", "Value": 43.4},
     │            {"DeviceID": 8, "SensorType": "temperature", "Value": 45.4},
     │            {"DeviceID": 9, "SensorType": "soil_moisture", "Value": 50.2},
     │            {"DeviceID": 10, "SensorType": "soil_moisture", "Value": 54.4}
     │        ]
     │
     │
     │        # Convert dictionary list to SQLAlchemy objects
     │        sensor_objects = [SensorData(**reading) for reading in sensor_readings]
     │
     │        #  Bulk insert all rows at once
     │        session.bulk_save_objects(sensor_objects)
     │        session.commit()
     │        session.close()
     │
     │        print("\n Batch data inserted successfully!")
     │        # Compare this snippet from webdevelopment/Initialize_greenhouse_db.py:
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── data_Intialization.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        import random
     │        from datetime import datetime, timedelta
     │        from sqlalchemy.orm import Session
     │        from faker import Faker
     │        from database_setup import (
     │            Base, engine, SessionLocal,
     │            UserCredentials, Device, Sensor,
     │            SensorData, KalmanFilterFusionData,
     │            Actuator
     │        )
     │
     │        fake = Faker()
     │
     │        # Use same sensor IDs from your fusion logic
     │        TEMP_SENSOR_IDS = [2099, 2092, 3093]
     │        HUM_SENSOR_IDS = [2091, 2034, 3027]
     │        ALL_SENSOR_IDS = TEMP_SENSOR_IDS + HUM_SENSOR_IDS
     │
     │        def create_dummy_user(session: Session):
     │            user = UserCredentials(
     │                Username="test_user",
     │                PasswordHash="hashed_password",
     │                Email="test@example.com",
     │                FullName="Test User"
     │            )
     │            session.add(user)
     │            session.flush()  # get UserID for foreign keys
     │            return user
     │
     │        def create_dummy_devices(session: Session):
     │            devices = []
     │            for i in range(1, 4):
     │                device = Device(
     │                    DeviceID=1000 + i,
     │                    DeviceName=f"Device_{i}",
     │                    Location=fake.city()
     │                )
     │                session.add(device)
     │                devices.append(device)
     │            session.flush()
     │            return devices
     │
     │        def create_dummy_sensors(session: Session, devices):
     │            sensors = []
     │            sensor_definitions = [
     │                (TEMP_SENSOR_IDS[0], devices[0], "Temperature"),
     │                (TEMP_SENSOR_IDS[1], devices[1], "Temperature"),
     │                (TEMP_SENSOR_IDS[2], devices[2], "Temperature"),
     │                (HUM_SENSOR_IDS[0], devices[0], "Humidity"),
     │                (HUM_SENSOR_IDS[1], devices[1], "Humidity"),
     │                (HUM_SENSOR_IDS[2], devices[2], "Humidity"),
     │            ]
     │            for sensor_id, device, sensor_type in sensor_definitions:
     │                sensor = Sensor(
     │                    SensorID=sensor_id,
     │                    DeviceID=device.DeviceID,
     │                    SensorType=sensor_type,
     │                    Location=device.Location
     │                )
     │                session.add(sensor)
     │                sensors.append(sensor)
     │            session.flush()
     │            return sensors
     │
     │        def insert_sensor_data(session: Session, sensors):
     │            now = datetime.utcnow()
     │            for sensor in sensors:
     │                for i in range(3):  # 3 entries per sensor
     │                    timestamp = now - timedelta(minutes=i)
     │                    value = round(random.uniform(20.0, 35.0), 2) if "Temp" in sensor.SensorType else round(random.uniform(30.0, 80.0), 2)
     │
     │                    # Raw sensor data
     │                    sensor_data = SensorData(
     │                        SensorID=sensor.SensorID,
     │                        Timestamp=timestamp,
     │                        Value=value
     │                    )
     │                    session.add(sensor_data)
     │
     │                    # Simulated Kalman output (slightly smoothed)
     │                    kalman_value = round(value + random.uniform(-1.0, 1.0), 2)
     │                    kalman_data = KalmanFilterFusionData(
     │                        SensorID=sensor.SensorID,
     │                        Timestamp=timestamp,
     │                        FusedValue=kalman_value
     │                    )
     │                    session.add(kalman_data)
     │
     │        def create_dummy_actuators(session: Session, user, devices):
     │            for i, device in enumerate(devices):
     │                actuator = Actuator(
     │                    ActuatorName=f"Pump_{i+1}",
     │                    Status="Active" if i % 2 == 0 else "Inactive",
     │                    UserID=user.UserID,
     │                    DeviceID=device.DeviceID
     │                )
     │                session.add(actuator)
     │
     │        def main():
     │            Base.metadata.create_all(engine)
     │            session = SessionLocal()
     │
     │            try:
     │                print("[INFO] Populating database with dummy data...")
     │
     │                user = create_dummy_user(session)
     │                devices = create_dummy_devices(session)
     │                sensors = create_dummy_sensors(session, devices)
     │                insert_sensor_data(session, sensors)
     │                create_dummy_actuators(session, user, devices)
     │
     │                session.commit()
     │                print("[SUCCESS] Database populated successfully.")
     │
     │            except Exception as e:
     │                session.rollback()
     │                print(f"[ERROR] Failed to populate database: {e}")
     │            finally:
     │                session.close()
     │
     │        if __name__ == "__main__":
     │            main()
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── database.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, ForeignKey
     │        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
     │        from datetime import datetime
     │
     │        # ✅ SQLite Database Connection
     │        DATABASE_URL = "sqlite:///greenhouse.db"
     │        engine = create_engine(DATABASE_URL, echo=True)  # `echo=True` shows SQL logs
     │
     │        # ✅ Base Model
     │        class Base(DeclarativeBase):
     │            pass
     │
     │        # ✅ Devices Table (ESP32, ESP32-CAM, Raspberry Pi)
     │        class Device(Base):
     │            __tablename__ = "devices"
     │
     │            id = Column(Integer, primary_key=True)
     │            name = Column(String, unique=True)
     │            type = Column(String)  # e.g., "ESP32", "ESP32-CAM", "Raspberry Pi"
     │            location = Column(String)  # e.g., "Greenhouse Zone 1"
     │
     │            sensors = relationship("Sensor", back_populates="device")
     │
     │        # ✅ Sensors Table (Temperature, Humidity, Soil Moisture)
     │        class Sensor(Base):
     │            __tablename__ = "sensors"
     │
     │            id = Column(Integer, primary_key=True)
     │            device_id = Column(Integer, ForeignKey("devices.id"))
     │            type = Column(String)  # e.g., "temperature", "humidity", "soil_moisture"
     │            unit = Column(String)  # e.g., "°C", "%", "VWC"
     │
     │            device = relationship("Device", back_populates="sensors")
     │            readings = relationship("SensorReading", back_populates="sensor")
     │
     │        # ✅ Sensor Readings Table
     │        class SensorReading(Base):
     │            __tablename__ = "sensor_readings"
     │
     │            id = Column(Integer, primary_key=True)
     │            sensor_id = Column(Integer, ForeignKey("sensors.id"))
     │            value = Column(Float)
     │            timestamp = Column(DateTime, default=datetime.utcnow)
     │
     │            sensor = relationship("Sensor", back_populates="readings")
     │
     │        # ✅ Users Table
     │        class User(Base):
     │            __tablename__ = "users"
     │
     │            id = Column(Integer, primary_key=True)
     │            username = Column(String, unique=True)
     │            role = Column(String)  # e.g., "admin", "user"
     │            email = Column(String, unique=True)
     │
     │            actions = relationship("UserAction", back_populates="user")
     │
     │        # ✅ User Actions Table
     │        class UserAction(Base):
     │            __tablename__ = "user_actions"
     │
     │            id = Column(Integer, primary_key=True)
     │            user_id = Column(Integer, ForeignKey("users.id"))
     │            action_type = Column(String)  # e.g., "turn_on_fan", "water_plants"
     │            action_value = Column(String)  # Any additional info (e.g., duration)
     │            timestamp = Column(DateTime, default=datetime.utcnow)
     │
     │            user = relationship("User", back_populates="actions")
     │
     │        # ✅ Weighted Averages Table (For Dashboards)
     │        class WeightedAverage(Base):
     │            __tablename__ = "weighted_averages"
     │
     │            id = Column(Integer, primary_key=True)
     │            sensor_type = Column(String)  # "temperature", "humidity", "soil_moisture"
     │            weighted_value = Column(Float)
     │            timestamp = Column(DateTime, default=datetime.utcnow)
     │
     │        # ✅ Create Tables in SQLite
     │        Base.metadata.create_all(engine)
     │
     │        # ✅ Insert Test Data
     │        Session = sessionmaker(bind=engine)
     │        session = Session()
     │
     │        # Adding sample devices
     │        device1 = Device(name="ESP32_1", type="ESP32", location="Greenhouse Zone 1")
     │        session.add(device1)
     │
     │        # Adding sample sensors
     │        sensor1 = Sensor(device=device1, type="temperature", unit="°C")
     │        session.add(sensor1)
     │
     │        # Adding sample sensor reading
     │        reading1 = SensorReading(sensor=sensor1, value=25.6)
     │        session.add(reading1)
     │
     │        # Adding a test user
     │        user1 = User(username="admin", role="admin", email="admin@example.com")
     │        session.add(user1)
     │
     │        # Adding a test user action
     │        action1 = UserAction(user=user1, action_type="water_plants", action_value="5 seconds")
     │        session.add(action1)
     │
     │        # Committing the session
     │        session.commit()
     │        session.close()
     │
     │        print("\n✅ Database setup complete!")
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── dbTest.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        import sqlite3
     │
     │        # Connect to the database
     │        conn = sqlite3.connect("greenhouse.db")
     │        cursor = conn.cursor()
     │
     │        # Function to print column details for a given table
     │        def show_table_structure(table_name):
     │            cursor.execute(f"PRAGMA table_info({table_name});")
     │            columns = cursor.fetchall()
     │            print(f"\n Structure of '{table_name}' table:")
     │            for col in columns:
     │                print(f"Column: {col[1]} | Type: {col[2]}")
     │
     │        # Get all table names
     │        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
     │        tables = cursor.fetchall()
     │
     │        # Print structure for each table
     │        for table in tables:
     │            show_table_structure(table[0])
     │
     │        conn.close()
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── greenhouseprev.db
     │   └── simplifiedDatabase.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, ForeignKey
     │        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
     │        from datetime import datetime
     │
     │        #  SQLite Database Connection
     │        DATABASE_URL = "sqlite:///greenhouse.db"
     │        engine = create_engine(DATABASE_URL, echo=True)  # `echo=True` shows SQL logs
     │
     │        #  Base Model
     │        class Base(DeclarativeBase):
     │            pass
     │
     │        #  Devices Table
     │        class Device(Base):
     │            __tablename__ = "devices"
     │
     │            DeviceID = Column(Integer, primary_key=True)
     │            DeviceName = Column(String(50), nullable=False)
     │            Location = Column(String(100))
     │            Status = Column(String(20))  # e.g., "Active", "Inactive"
     │            Type = Column(String(50))  # e.g., "ESP32", "Raspberry Pi"
     │
     │            sensor_data = relationship("SensorData", back_populates="device")
     │            user_interactions = relationship("UserInteraction", back_populates="device")
     │
     │        #  SensorData Table
     │        class SensorData(Base):
     │            __tablename__ = "sensor_data"
     │
     │            DataID = Column(Integer, primary_key=True)
     │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
     │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │            SensorType = Column(String(50))  # e.g., "temperature", "humidity"
     │            Value = Column(Float)  # Sensor reading value
     │
     │            device = relationship("Device", back_populates="sensor_data")
     │
     │        #  UserInteractions Table
     │        class UserInteraction(Base):
     │            __tablename__ = "user_interactions"
     │
     │            InteractionID = Column(Integer, primary_key=True)
     │            UserID = Column(Integer)  # Assuming users are stored elsewhere
     │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
     │            Action = Column(String(20), nullable=False)  # e.g., "Turn On", "Turn Off"
     │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │
     │            device = relationship("Device", back_populates="user_interactions")
     │
     │        #  Create Tables in SQLite
     │        Base.metadata.create_all(engine)
     │
     │        print("\n Greenhouse database structure created successfully!")
     │        ↑↑↑ END OF FILE ↑↑↑
     
     ├── database_setup.py
          ↓↓↓ FILE CONTENT ↓↓↓
          from sqlalchemy import (
              create_engine, Column, Integer, Float, String, DateTime,
              ForeignKey, Boolean, Index
          )
          from sqlalchemy.orm import relationship, sessionmaker, declarative_base
          from datetime import datetime
     
          # Database connection
          DATABASE_URL = "sqlite:///greenhouse.db"
          engine = create_engine(DATABASE_URL, echo=True)
          SessionLocal = sessionmaker(bind=engine)
     
          # Base class
          Base = declarative_base()
     
          # UserCredentials Table
          class UserCredentials(Base):
              __tablename__ = "user_credentials"
     
              UserID = Column(Integer, primary_key=True)
              Username = Column(String(50), nullable=False, unique=True)
              PasswordHash = Column(String(128), nullable=False)
              Email = Column(String(100), nullable=False, unique=True)
              FullName = Column(String(100))
              CreatedAt = Column(DateTime, default=datetime.utcnow)
              IsActive = Column(Boolean, default=True)
     
              interactions = relationship("UserInteraction", back_populates="user", cascade="all, delete-orphan")
              actuators = relationship("Actuator", back_populates="user")
     
              def __repr__(self):
                  return f"<UserCredentials(Username={self.Username}, Email={self.Email})>"
     
          # Devices Table
          class Device(Base):
              __tablename__ = "devices"
     
              DeviceID = Column(Integer, primary_key=True, autoincrement=False)
              DeviceName = Column(String(50), nullable=False)
              Location = Column(String(100))
              Status = Column(String(20), default="Active")
     
              sensors = relationship("Sensor", back_populates="device", cascade="all, delete-orphan")
              user_interactions = relationship("UserInteraction", back_populates="device", cascade="all, delete-orphan")
              actuators = relationship("Actuator", back_populates="device", cascade="all, delete-orphan")
     
              def __repr__(self):
                  return f"<Device(Name={self.DeviceName}, Location={self.Location})>"
     
          # Sensors Table — NO UNIQUE CONSTRAINTS
          class Sensor(Base):
              __tablename__ = "sensors"
     
              SensorID = Column(Integer, primary_key=True, autoincrement=False)
              DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
              SensorType = Column(String(50), nullable=False)
              Location = Column(String(100))
              Status = Column(String(20), default="Active")
     
              device = relationship("Device", back_populates="sensors")
              sensor_data = relationship("SensorData", back_populates="sensor", cascade="all, delete-orphan")
              kalmanFilterFusionData = relationship("KalmanFilterFusionData", back_populates="sensor", cascade="all, delete-orphan")
     
              def __repr__(self):
                  return f"<Sensor(SensorID={self.SensorID}, Type={self.SensorType}, Location={self.Location})>"
     
          # Sensor Data Table
          class SensorData(Base):
              __tablename__ = "sensor_data"
              __table_args__ = (
                  Index("ix_sensor_data_sensorid_timestamp", "SensorID", "Timestamp"),
              )
     
              DataID = Column(Integer, primary_key=True)
              SensorID = Column(Integer, ForeignKey("sensors.SensorID"), nullable=False)
              Timestamp = Column(DateTime, default=datetime.utcnow)
              Value = Column(Float, nullable=False)
     
              sensor = relationship("Sensor", back_populates="sensor_data")
     
              def __repr__(self):
                  return f"<SensorData(SensorID={self.SensorID}, Value={self.Value})>"
     
          # Kalman Filter Fusion Table
          class KalmanFilterFusionData(Base):
              __tablename__ = "kalman_filter_fusion"
     
              FusionID = Column(Integer, primary_key=True)
              SensorID = Column(Integer, ForeignKey("sensors.SensorID"), nullable=False)
              Timestamp = Column(DateTime, default=datetime.utcnow)
              FusedValue = Column(Float, nullable=False)
     
              sensor = relationship("Sensor", back_populates="kalmanFilterFusionData")
     
              def __repr__(self):
                  return f"<KalmanFusion(SensorID={self.SensorID}, Value={self.FusedValue})>"
     
          # Weighted Average Fusion Table
          class WeightedAverageFusionData(Base):
              __tablename__ = "weighted_average_fusion"
     
              FusionID = Column(Integer, primary_key=True)
              SensorType = Column(String(50), nullable=False)
              Timestamp = Column(DateTime, default=datetime.utcnow)
              FusedValue = Column(Float, nullable=False)
     
              def __repr__(self):
                  return f"<WeightedFusion(SensorType={self.SensorType}, Value={self.FusedValue})>"
     
          # Actuators Table
          class Actuator(Base):
              __tablename__ = "actuators"
     
              ActuatorID = Column(Integer, primary_key=True)
              ActuatorName = Column(String(50), nullable=False, unique=True)
              Status = Column(String(20), nullable=False, default="Inactive")
              LastUpdated = Column(DateTime, default=datetime.utcnow)
              UserID = Column(Integer, ForeignKey("user_credentials.UserID"))
              DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
     
              interactions = relationship("UserInteraction", back_populates="actuator")
              user = relationship("UserCredentials", back_populates="actuators")
              device = relationship("Device", back_populates="actuators")
     
              def __repr__(self):
                  return f"<Actuator(Name={self.ActuatorName}, Status={self.Status})>"
     
          # User Interactions Table
          class UserInteraction(Base):
              __tablename__ = "user_interactions"
     
              InteractionID = Column(Integer, primary_key=True)
              UserID = Column(Integer, ForeignKey("user_credentials.UserID"), nullable=False)
              DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
              ActuatorID = Column(Integer, ForeignKey("actuators.ActuatorID"))
              Action = Column(String(20), nullable=False)
              Timestamp = Column(DateTime, default=datetime.utcnow)
     
              user = relationship("UserCredentials", back_populates="interactions")
              device = relationship("Device", back_populates="user_interactions")
              actuator = relationship("Actuator", back_populates="interactions")
     
              def __repr__(self):
                  return f"<UserInteraction(UserID={self.UserID}, DeviceID={self.DeviceID}, Action={self.Action})>"
     
          # Create all tables
          Base.metadata.create_all(engine)
          ↑↑↑ END OF FILE ↑↑↑
     
     ├── directoryvis.py
          ↓↓↓ FILE CONTENT ↓↓↓
          import os
     
          # Set your root directory
          ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
          OUTPUT_FILE = os.path.join(ROOT_DIR, 'project_tree_output.txt')
     
          # File types to include for content printing
          ALLOWED_EXTENSIONS = {
              '.py', '.html', '.json', '.css', '.js', '.txt', '.md', '.csv'
          }
     
          def print_tree(path, prefix='', output_lines=None):
              """Recursively builds a tree view of the directory with file contents."""
              if output_lines is None:
                  output_lines = []
     
              try:
                  contents = sorted(os.listdir(path))
              except Exception as e:
                  output_lines.append(prefix + f"[Error accessing {path}]: {e}")
                  return output_lines
     
              pointers = ['├── '] * (len(contents) - 1) + ['└── ']
              for pointer, name in zip(pointers, contents):
                  full_path = os.path.join(path, name)
                  output_lines.append(prefix + pointer + name)
     
                  if os.path.isdir(full_path):
                      extension = '│   ' if pointer == '├── ' else '    '
                      print_tree(full_path, prefix + extension, output_lines)
                  else:
                      _, ext = os.path.splitext(name)
                      if ext.lower() in ALLOWED_EXTENSIONS:
                          try:
                              with open(full_path, 'r', encoding='utf-8') as f:
                                  output_lines.append(prefix + '     ↓↓↓ FILE CONTENT ↓↓↓')
                                  for line in f:
                                      output_lines.append(prefix + '     ' + line.rstrip())
                                  output_lines.append(prefix + '     ↑↑↑ END OF FILE ↑↑↑\n')
                          except Exception as e:
                              output_lines.append(prefix + f'     [Error reading file: {e}]\n')
              return output_lines
     
          if __name__ == '__main__':
              tree_output = ['.']
              tree_output = print_tree(ROOT_DIR, output_lines=tree_output)
     
              # Write to file
              with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
                  f.write('\n'.join(tree_output))
     
              # Print file content
              with open(OUTPUT_FILE, 'r', encoding='utf-8') as f:
                  print(f.read())
          ↑↑↑ END OF FILE ↑↑↑
     
     ├── greenhouse.db
     ├── input
     │   ├── imagecapture.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        import cv2
     │        import requests
     │        import numpy as np
     │        import time
     │
     │        # MJPEG stream URL
     │        url = "http://192.168.200.76:5000/video_feed"
     │
     │        # Connect to the stream
     │        stream = requests.get(url, stream=True)
     │        if stream.status_code != 200:
     │            print("❌ Failed to connect to video stream")
     │            exit()
     │
     │        print("📷 Press 'b' to capture an image, 'q' to quit")
     │
     │        bytes_buffer = b""
     │        img_count = 0
     │
     │        for chunk in stream.iter_content(chunk_size=1024):
     │            bytes_buffer += chunk
     │            a = bytes_buffer.find(b'\xff\xd8')
     │            b = bytes_buffer.find(b'\xff\xd9')
     │
     │            if a != -1 and b != -1:
     │                jpg = bytes_buffer[a:b+2]
     │                bytes_buffer = bytes_buffer[b+2:]
     │
     │                img_np = np.frombuffer(jpg, dtype=np.uint8)
     │                frame = cv2.imdecode(img_np, cv2.IMREAD_COLOR)
     │                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
     │
     │                if frame is not None:
     │                    cv2.imshow("Live Stream", frame)
     │
     │                    key = cv2.waitKey(1) & 0xFF
     │                    if key == ord('b'):
     │                        filename = f"snapshot_{int(time.time())}.jpg"
     │                        cv2.imwrite(filename, frame)
     │                        print(f"✅ Saved snapshot as {filename}")
     │                    elif key == ord('q'):
     │                        print("👋 Exiting...")
     │                        break
     │
     │        cv2.destroyAllWindows()
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── snapshot_1747066344.jpg
     │   ├── snapshot_1747066357.jpg
     │   └── snapshot_1747066365.jpg
     ├── kalman_filter_readings_4_weighted_AVG.py
          ↓↓↓ FILE CONTENT ↓↓↓
          from sqlalchemy.orm import Session
          from datetime import timedelta
          import pandas as pd
          from database_setup import SessionLocal, KalmanFilterFusionData
     
          # Start DB session
          session: Session = SessionLocal()
     
          # Step 1: Get latest timestamp
          latest_entry = session.query(KalmanFilterFusionData).order_by(
              KalmanFilterFusionData.Timestamp.desc()
          ).first()
     
          if latest_entry:
              latest_timestamp = latest_entry.Timestamp
              start_timestamp = latest_timestamp - timedelta(minutes=20)
     
              # Step 2: Query data within the latest 20-minute window
              results = session.query(KalmanFilterFusionData).filter(
                  KalmanFilterFusionData.Timestamp.between(start_timestamp, latest_timestamp)
              ).order_by(KalmanFilterFusionData.Timestamp.asc()).all()
     
              # Step 3: Convert to DataFrame
              df = pd.DataFrame([{
                  "Timestamp": r.Timestamp,
                  f"{r.SensorID}": r.FusedValue
              } for r in results])
     
              # Step 4: Pivot based on SensorID (aggregated on Timestamp)
              df_pivoted = df.pivot_table(
                  index="Timestamp",
                  aggfunc="first"  # If multiple values exist per sensor & timestamp, take the first
              )
     
              # Optional: sort columns by SensorID
              df_pivoted = df_pivoted[sorted(df_pivoted.columns, key=int)]
     
              # Step 5: Save to CSV
              df_pivoted.to_csv("kalman_latest_20min_pivoted.csv")
              print("✅ Pivoted CSV 'kalman_latest_20min_pivoted.csv' saved.")
          else:
              print("⚠️ No data found in KalmanFilterFusionData.")
     
          # Step 6: Close DB session
          session.close()
          ↑↑↑ END OF FILE ↑↑↑
     
     ├── network.py
          ↓↓↓ FILE CONTENT ↓↓↓
          from flask import request, jsonify
          from time import sleep
          from datetime import datetime
          import logging
     
     
          from network_utils.auth import authenticate_request
          from network_utils.sensor_storage import store_sensor_data
          from network_utils.fusion_utils import get_latest_fused_temperature_humidity, get_fused_values_by_sensors
          from network_utils.actions import action_based_on_sensor
          from network_utils.constants import soil_sensor_1id, soil_sensor_2id
          from database_setup import SessionLocal, Actuator
     
          # Configure logging
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)
     
          def receive_sensor_data(request):
              if not authenticate_request(request):
                  return jsonify({"error": "Unauthorized"}), 401
     
              try:
                  data = request.get_json()
                  print(f"Recived paylaod: {data}")
                  if not data:
                      return jsonify({"error": "Invalid or missing JSON payload"}), 400
     
                  time = datetime.utcnow()
                  device_id = data.get('DeviceID')
                  device_name = data.get('DeviceName')
                  actuator_id = data.get('ActuatorID')
                  actuator_status = data.get('ActuatorState')
                  sensor_ids = data.get("SensorID", [])
     
                  temperatures = data.get("temperature", [])
                  filtered_temperatures = data.get("filtered_temperature", [])
                  humidities = data.get("humidity", [])
                  filtered_humidities = data.get("filtered_humidity", [])
                  soil_moistures = data.get("soil_moisture", [])
                  filtered_soil_moistures = data.get("filtered_soil_moisture", [])
     
                  with SessionLocal() as session:
                      for i, sensor_id in enumerate(sensor_ids):
                          if i < len(temperatures) and i < len(filtered_temperatures):
                              if temperatures[i] > 0 and filtered_temperatures[i] > 0:
                                  store_sensor_data(session, device_id, device_name, sensor_id,
                                                    temperature=temperatures[i],
                                                    filtered_temperature=filtered_temperatures[i],
                                                    timestamp=time)
     
                          if i < len(humidities) and i < len(filtered_humidities):
                              if humidities[i] > 0 and filtered_humidities[i] > 0:
                                  store_sensor_data(session, device_id, device_name, sensor_id,
                                                    humidity=humidities[i],
                                                    filtered_humidity=filtered_humidities[i],
                                                    timestamp=time)
     
                          if i < len(soil_moistures) and i < len(filtered_soil_moistures):
                              if soil_moistures[i] > 0 and filtered_soil_moistures[i] > 0:
                                  store_sensor_data(session, device_id, device_name, sensor_id,
                                                    soil_moisture=soil_moistures[i],
                                                    filtered_soil_moisture=filtered_soil_moistures[i],
                                                    timestamp=time)
     
                          logger.info(f"Received data from DeviceID: {device_id}, SensorID: {sensor_id}")
     
                      #  Handle actuator state
                      if actuator_id is not None and actuator_status is not None:
     
                          actuator = session.query(Actuator).filter(Actuator.ActuatorID == actuator_id).first()
                          if actuator:
                              actuator.Status = actuator_status
                              actuator.LastUpdated = time
                              logger.info(f"Updated Actuator {actuator_id} to {actuator_status}")
                              session.commit()
                          else:
                              try:
                                  new_actuator = Actuator(
                                      ActuatorID=actuator_id,
                                      ActuatorName=f"Auto_Actuator_{actuator_id}",
                                      Status=actuator_status,
                                      UserID=5000,  # Adjust as needed
                                      DeviceID=device_id,
                                      LastUpdated=time
                                  )
     
                                  session.add(new_actuator)
                                  logger.info(f"Created new Actuator with ID {actuator_id} and status {actuator_status}")
                              except Exception as e:
                                  session.rollback()
                                  logger.warning(f"Failed to insert new actuator — error: {e}")
     
     
                      action_result = action_based_on_sensor()
     
     
                      latest = get_latest_fused_temperature_humidity(session)
                      soil_data = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
                      avg_soil = sum(soil_data.values()) / len(soil_data) if soil_data else None
     
                      session.commit()
     
                  sleep(5)  # Optional delay
                  print("Belo")
                  print({
                      "status": "success",
                      "action": action_result,
                      "temperature": latest.get("temperature"),
                      "humidity": latest.get("humidity"),
                      "soil_moisture": avg_soil
                  })
                  return jsonify({
                      "status": "success",
                      "action": action_result,
                      "temperature": latest.get("temperature"),
                      "humidity": latest.get("humidity"),
                      "soil_moisture": avg_soil
                  }), 200
     
     
     
              except Exception as e:
                  logger.error(f"Failed to receive/process sensor data: {e}")
                  return jsonify({"error": "Internal Server Error"}), 500
          ↑↑↑ END OF FILE ↑↑↑
     
     ├── network_utils
     │   ├── __init__.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── __pycache__
     │   │   ├── __init__.cpython-313.pyc
     │   │   ├── actions.cpython-313.pyc
     │   │   ├── actuator_control.cpython-313.pyc
     │   │   ├── auth.cpython-313.pyc
     │   │   ├── config_handler.cpython-313.pyc
     │   │   ├── constants.cpython-313.pyc
     │   │   ├── device_utils.cpython-313.pyc
     │   │   ├── fusion_utils.cpython-313.pyc
     │   │   ├── sensor_storage.cpython-313.pyc
     │   │   └── status.cpython-313.pyc
     │   ├── actions.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from .fusion_utils import get_fused_values_by_sensors
     │        from .actuator_control import control_actuator
     │        from .config_handler import load_config
     │        from weightedAverage import process_weighted_fusion
     │        from database_setup import SessionLocal, WeightedAverageFusionData
     │        from .constants import *
     │
     │
     │        def action_based_on_sensor(user_id=DEFAULT_USER_ID):
     │            print("[DEBUG] action.py loaded successfully.")
     │
     │            # Load dynamic thresholds
     │            config = load_config()
     │            TEMP_THRESHOLD = config.get("TEMP_THRESHOLD", 27)
     │            HUM_THRESHOLD = config.get("HUM_THRESHOLD", 80)
     │            SOIL_MOISTURE_THRESHOLD = config.get("SOIL_MOISTURE_THRESHOLD", 4000)
     │
     │            with SessionLocal() as session:
     │                # Get fused soil moisture readings
     │                result = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
     │                soil1 = result.get(soil_sensor_1id)
     │                soil2 = result.get(soil_sensor_2id)
     │                soil_moisture = None
     │
     │                if soil1 is not None and soil2 is not None:
     │                    avg = (soil1 + soil2) / 2
     │                    if 0 <= avg <= 5000:
     │                        soil_moisture = avg
     │                elif soil1 and 0 <= soil1 <= 5000:
     │                    soil_moisture = soil1
     │                elif soil2 and 0 <= soil2 <= 5000:
     │                    soil_moisture = soil2
     │                else:
     │                    print("[WARNING] Invalid soil moisture readings, using None.")
     │
     │                # Update fusion values
     │                process_weighted_fusion(sensor_ids=TEMP_SENSOR_IDS, weights=WEIGHTS, sensor_type="temperature")
     │                process_weighted_fusion(sensor_ids=HUM_SENSOR_IDS, weights=WEIGHTS, sensor_type="humidity")
     │
     │                # Get latest temperature
     │                temperature_record = session.query(WeightedAverageFusionData) \
     │                    .filter(WeightedAverageFusionData.SensorType == "temperature") \
     │                    .order_by(WeightedAverageFusionData.Timestamp.desc()) \
     │                    .first()
     │                temperature = temperature_record.FusedValue if temperature_record else None
     │                if temperature is None:
     │                    print("[WARNING] No temperature data found.")
     │
     │                # Get latest humidity
     │                humidity_record = session.query(WeightedAverageFusionData) \
     │                    .filter(WeightedAverageFusionData.SensorType == "humidity") \
     │                    .order_by(WeightedAverageFusionData.Timestamp.desc()) \
     │                    .first()
     │                humidity = humidity_record.FusedValue if humidity_record else None
     │                if humidity is None:
     │                    print("[WARNING] No humidity data found.")
     │
     │                actions = []
     │
     │                try:
     │                    # --- VENTILATION CONTROL ---
     │                    if temperature is not None and humidity is not None:
     │                        if temperature > TEMP_THRESHOLD or humidity > HUM_THRESHOLD:
     │                            control_actuator(session, VENTILATION_FAN, "on", user_id)
     │                            control_actuator(session, INTAKE_SHUTTER, "on", user_id)
     │                            actions.append("Ventilation_ON")
     │                        else:
     │                            control_actuator(session, VENTILATION_FAN, "off", user_id)
     │                            control_actuator(session, INTAKE_SHUTTER, "off", user_id)
     │                            actions.append("Ventilation_OFF")
     │
     │                    # --- IRRIGATION CONTROL ---
     │                    if soil_moisture is not None:
     │                        if soil_moisture < SOIL_MOISTURE_THRESHOLD:
     │                            control_actuator(session, WATER_PUMP, "on", user_id)
     │                            actions.append("Irrigation_ON")
     │                        else:
     │                            control_actuator(session, WATER_PUMP, "off", user_id)
     │                            actions.append("Irrigation_OFF")
     │
     │                    session.commit()
     │                    print("[DEBUG] actions.py [WORKED]")
     │                    print(f"[DEBUG] Thresholds: TEMP={TEMP_THRESHOLD}, HUM={HUM_THRESHOLD}, SOIL={SOIL_MOISTURE_THRESHOLD}")
     │                    print(f"[DEBUG] Readings: TEMP={temperature}, HUM={humidity}, SOIL={soil_moisture}")
     │                    print(f"[DEBUG] Actions performed: {actions}")
     │                    return ", ".join(actions) if actions else "none"
     │
     │                except Exception as e:
     │                    session.rollback()
     │                    print(f"[ERROR] Failed to perform action: {e}")
     │                    return "error"
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── actuator_control.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from datetime import datetime
     │        from database_setup import Actuator, UserInteraction
     │
     │        def log_user_action(session, device_id, action, user_id, actuator_id):
     │            print("[DEBUG] actuator_control.py/log_user_action loaded successfully.")
     │            session.add(UserInteraction(
     │                DeviceID=device_id,
     │                Action=action,
     │                UserID=user_id,
     │                ActuatorID=actuator_id,
     │                Timestamp=datetime.utcnow()))
     │            print("[DEBUG] actuator_control.py/log_user_action loaded successfully [WORKED].")
     │
     │        def control_actuator(session, actuator_name, status, user_id):
     │            print("[DEBUG] actuator_control.py/control_actuator loaded successfully.")
     │            actuator = session.query(Actuator).filter_by(ActuatorName=actuator_name).first()
     │            if not actuator:
     │                actuator = Actuator(ActuatorName=actuator_name, Status=status, LastUpdated=datetime.utcnow(), UserID=user_id)
     │                session.add(actuator)
     │            else:
     │                if actuator.Status != status:
     │                    actuator.Status = status
     │                    actuator.LastUpdated = datetime.utcnow()
     │                    actuator.UserID = user_id
     │                    log_user_action(session, actuator.ActuatorID, f"{actuator_name}_{status.lower()}", user_id, actuator.ActuatorID)
     │            session.commit()
     │            print("[DEBUG] actuator_control.py/control_actuator loaded successfully [WORKED].")
     │            return actuator
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── auth.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from flask import request, jsonify
     │        from .constants import credentials
     │
     │        def authenticate_request(request):
     │            auth = request.authorization
     │            # ... your auth functions
     │
     │            print("[DEBUG] auth.py loaded successfully.")
     │
     │            if not auth or credentials.get(auth.username) != auth.password:
     │                return False
     │            return True
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── config.json
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        {
     │            "TEMP_THRESHOLD": 44,
     │            "HUM_THRESHOLD": 80,
     │            "SOIL_MOISTURE_THRESHOLD": 4000
     │        }
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── config_handler.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        import json
     │        import os
     │
     │        CONFIG_PATH = os.path.join(os.path.dirname(__file__), 'config.json')
     │
     │        def load_config():
     │            if not os.path.exists(CONFIG_PATH):
     │                # Return default config if the file doesn't exist
     │                return {
     │                    "TEMP_THRESHOLD": 27,
     │                    "HUM_THRESHOLD": 80,
     │                    "SOIL_MOISTURE_THRESHOLD": 4000
     │                }
     │            with open(CONFIG_PATH, 'r') as file:
     │                return json.load(file)
     │
     │        def save_config(config):
     │            with open(CONFIG_PATH, 'w') as file:
     │                json.dump(config, file, indent=4)
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── constants.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        credentials = {
     │            "Ventilation_System_ESP": "password",
     │            "Irrigation_System_ESP": "password",
     │            "web_control": "web_password"
     │        }
     │
     │        DEFAULT_USER_ID = 5000
     │
     │
     │
     │        TEMP_SENSOR_IDS = [2001, 2003, 3001]
     │        HUM_SENSOR_IDS = [2002, 2004, 3002]
     │        WEIGHTS = [0.5, 0.3, 0.2]
     │
     │        INTAKE_SHUTTER = "intake_shutter"
     │        WATER_PUMP = "water_pump"
     │        VENTILATION_FAN = "ventilation_fan"
     │
     │        Ventilation_System_ESP_ID = 2000
     │        Irrigation_System_ESP_ID = 3000
     │
     │        soil_sensor_1id = 2005
     │        soil_sensor_2id = 3005
     │
     │        print("[DEBUG] constants.py loaded successfully.")
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── device_utils.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from database_setup import Device, Sensor
     │        from sqlalchemy.orm import Session
     │
     │        def get_or_create_device(session: Session, device_id, device_name):
     │            print("[DEBUG] device_utils.py/get_or_create_device loaded successfully.")
     │            device = session.query(Device).filter_by(DeviceID=device_id).first()
     │            if not device:
     │                device = Device(DeviceID=device_id, DeviceName=device_name, Location="Unknown", Status="Active")
     │                session.add(device)
     │                session.commit()
     │                session.refresh(device)
     │            print("[DEBUG] device_utils.py/get_or_create_device[WORKED].")
     │            return device
     │
     │        def get_or_create_sensor(session: Session, sensor_id, device_id, sensor_type):
     │            print("[DEBUG] device_utils.py/get_or_create_sensor loaded successfully.")
     │
     │            sensor = session.query(Sensor).filter_by(SensorID=sensor_id).first()
     │            if not sensor:
     │                # Create new sensor if none exists with this SensorID
     │                sensor = Sensor(SensorID=sensor_id, DeviceID=device_id, SensorType=sensor_type, Location="Unknown", Status="Active")
     │                session.add(sensor)
     │                session.commit()
     │                session.refresh(sensor)
     │            else:
     │                # Optionally update sensor_type or other fields if different
     │                if sensor.SensorType != sensor_type:
     │                    sensor.SensorType = sensor_type
     │                    session.commit()
     │
     │            print("[DEBUG] device_utils.py/get_or_create_sensor[WORKED].")
     │            return sensor
     │
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── fusion_utils.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from sqlalchemy import desc
     │        from database_setup import KalmanFilterFusionData, WeightedAverageFusionData
     │
     │        def get_fused_values_by_sensors(session, *sensor_ids):
     │            print("[DEBUG] fusion_utils.py/get_fused_values_by_sensors loaded successfully.")
     │            print(f"[DEBUG] fusion_utils.py/get_fused_values_by_sensors called with sensor_ids: {sensor_ids}")
     │            fused = {}
     │            for sensor_id in sensor_ids:
     │                fusion = session.query(KalmanFilterFusionData).filter_by(SensorID=sensor_id).order_by(desc(KalmanFilterFusionData.Timestamp)).first()
     │                if fusion:
     │                    fused[sensor_id] = fusion.FusedValue
     │            print("[DEBUG] fusion_utils.py/get_fused_values_by_sensors [WORKED].")
     │            return fused
     │
     │        def get_latest_fused_temperature_humidity(session):
     │            print("[DEBUG] fusion_utils.py/get_latest_fused_temperature_humidity loaded successfully.")
     │            temp = session.query(WeightedAverageFusionData).filter_by(SensorType="temperature").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
     │            hum = session.query(WeightedAverageFusionData).filter_by(SensorType="humidity").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
     │            print("[DEBUG] fusion_utils.py/get_latest_fused_temperature_humidity [WORKED].")
     │            return {
     │                "temperature": temp.FusedValue if temp else None,
     │                "humidity": hum.FusedValue if hum else None
     │            }
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── sensor_storage.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from datetime import datetime
     │        from database_setup import SensorData, KalmanFilterFusionData
     │        from .device_utils import get_or_create_device, get_or_create_sensor
     │
     │        def store_sensor_value(session, sensor, value, time):
     │            print("[DEBUG] sensor_storage.py/store_sensor_value loaded successfully.")
     │            session.add(SensorData(SensorID=sensor.SensorID, Value=value, Timestamp=time))
     │            print("[DEBUG] sensor_storage.py/store_sensor_value [WORKED].")
     │
     │        def store_sensor_fused_value(session, sensor, value, time):
     │            print("[DEBUG] sensor_storage.py/store_sensor_fused_value loaded successfully.")
     │            session.add(KalmanFilterFusionData(SensorID=sensor.SensorID, FusedValue=value, Timestamp=time))
     │            print("[DEBUG] sensor_storage.py/store_sensor_fused_value [WORKED].")
     │
     │        def store_sensor_data(session, device_id, device_name, sensor_id,
     │                              temperature=None, filtered_temperature=None,
     │                              humidity=None, filtered_humidity=None,
     │                              soil_moisture=None, filtered_soil_moisture=None, timestamp=None):
     │            get_or_create_device(session, device_id, device_name)
     │            print("[DEBUG] sensor_storage.py/store_sensor_data loaded successfully.")
     │            if temperature is not None:
     │                sensor = get_or_create_sensor(session, sensor_id, device_id, "temperature")
     │                store_sensor_value(session, sensor, temperature, timestamp)
     │            if filtered_temperature is not None:
     │                sensor = get_or_create_sensor(session, sensor_id, device_id, "temperature")
     │                store_sensor_fused_value(session, sensor, filtered_temperature, timestamp)
     │            if humidity is not None:
     │                sensor = get_or_create_sensor(session, sensor_id, device_id, "humidity")
     │                store_sensor_value(session, sensor, humidity, timestamp)
     │            if filtered_humidity is not None:
     │                sensor = get_or_create_sensor(session, sensor_id, device_id, "humidity_filtered")
     │                store_sensor_fused_value(session, sensor, filtered_humidity, timestamp)
     │            if soil_moisture is not None:
     │                sensor = get_or_create_sensor(session, sensor_id, device_id, "soil_moisture")
     │                store_sensor_value(session, sensor, soil_moisture,timestamp)
     │            if filtered_soil_moisture is not None:
     │                sensor = get_or_create_sensor(session, sensor_id, device_id, "soil_moisture_filtered")
     │                store_sensor_fused_value(session, sensor, filtered_soil_moisture, timestamp)
     │            session.commit()
     │            print("[DEBUG] sensor_storage.py/store_sensor_data [WORKED].")
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   └── status.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from flask import Blueprint, render_template, jsonify
     │        from .fusion_utils import get_fused_values_by_sensors
     │        from database_setup import SessionLocal, WeightedAverageFusionData
     │        from .constants import soil_sensor_1id, soil_sensor_2id
     │
     │        status_bp = Blueprint('status', __name__)
     │
     │        @status_bp.route("/status")
     │        def status_page():
     │            return render_template("index.html")
     │
     │        @status_bp.route("/api/latest-fused-values")
     │        def latest_fused_values():
     │            temperature = None
     │            humidity = None
     │            soil_moisture = None
     │
     │            try:
     │                with SessionLocal() as session:
     │                    # --- Latest Soil Moisture ---
     │                    result = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
     │                    soil1 = result.get(soil_sensor_1id)
     │                    soil2 = result.get(soil_sensor_2id)
     │
     │                    valid_soil_values = [v for v in [soil1, soil2] if v is not None and 0 <= v <= 5000]
     │                    if valid_soil_values:
     │                        soil_moisture = sum(valid_soil_values) / len(valid_soil_values)
     │                    else:
     │                        print("[WARNING] No valid soil moisture readings found.")
     │
     │                    # --- Latest Temperature ---
     │                    temp_record = session.query(WeightedAverageFusionData)\
     │                        .filter(WeightedAverageFusionData.SensorType == "temperature")\
     │                        .order_by(WeightedAverageFusionData.Timestamp.desc())\
     │                        .first()
     │
     │                    if temp_record:
     │                        temperature = temp_record.FusedValue
     │                    else:
     │                        print("[WARNING] No temperature data found.")
     │
     │                    # --- Latest Humidity ---
     │                    hum_record = session.query(WeightedAverageFusionData)\
     │                        .filter(WeightedAverageFusionData.SensorType == "humidity")\
     │                        .order_by(WeightedAverageFusionData.Timestamp.desc())\
     │                        .first()
     │
     │                    if hum_record:
     │                        humidity = hum_record.FusedValue
     │                    else:
     │                        print("[WARNING] No humidity data found.")
     │
     │            except Exception as e:
     │                print(f"[ERROR] Failed to fetch latest fused values: {e}")
     │
     │            return jsonify({
     │                "temperature": temperature,
     │                "humidity": humidity,
     │                "soil_moisture": soil_moisture
     │            })
     │        ↑↑↑ END OF FILE ↑↑↑
     
     ├── static
     │   ├── no-signal.jpg
     │   ├── predictions
     │   │   ├── snapshot_1747066344.jpg
     │   │   ├── snapshot_1747066357.jpg
     │   │   └── snapshot_1747066365.jpg
     │   └── styles.css
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        body {
     │            margin: 0;
     │            font-family: Arial, sans-serif;
     │            background-color: #f4f4f4;
     │            text-align: center;
     │        }
     │        img {
     │            max-width: 300px;
     │            margin: 10px;
     │            border: 2px solid #ccc;
     │            padding: 5px;
     │        }
     │
     │        nav {
     │            display: flex;
     │            justify-content: space-between;
     │            align-items: center;
     │            background-color: #2c3e50;
     │            padding: 15px 30px;
     │        }
     │
     │        .logo {
     │            font-size: 24px;
     │            font-weight: bold;
     │            color: #ecf0f1;
     │        }
     │
     │        nav ul {
     │            list-style: none;
     │            padding: 0;
     │            display: flex;
     │        }
     │
     │        nav ul li {
     │            margin: 0 15px;
     │        }
     │
     │        nav ul li a {
     │            text-decoration: none;
     │            color: #ecf0f1;
     │            font-size: 18px;
     │        }
     │
     │        nav ul li a:hover {
     │            color: #1abc9c;
     │        }
     │
     │        .container {
     │            margin-top: 50px;
     │        }
     │
     │        h1 {
     │            color: #2c3e50;
     │        }
     │
     │        p {
     │            color: #555;
     │            font-size: 18px;
     │        }
     │        ↑↑↑ END OF FILE ↑↑↑
     
     ├── templates
     │   ├── ai_model.html
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        {% extends "base.html" %}
     │
     │        {% block title %}YOLO Image Processor{% endblock %}
     │
     │
     │        <style>
     │            body {
     │                font-family: 'Poppins', sans-serif;
     │                background-color: #f5f7fa;
     │                margin: 0;
     │                padding: 20px;
     │                color: #333;
     │            }
     │
     │            h1 {
     │                text-align: center;
     │                color: #2c3e50;
     │                margin: 20px 0;
     │            }
     │
     │            .buttons {
     │                text-align: center;
     │                margin-bottom: 20px;
     │            }
     │
     │            form {
     │                display: inline-block;
     │                margin: 10px;
     │                text-align: center;
     │            }
     │
     │            button {
     │                background-color: #3498db;
     │                color: white;
     │                border: none;
     │                padding: 12px 20px;
     │                font-size: 16px;
     │                border-radius: 8px;
     │                cursor: pointer;
     │                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
     │                transition: background-color 0.3s ease;
     │            }
     │
     │            button:hover {
     │                background-color: #2980b9;
     │            }
     │
     │            .image-gallery {
     │                display: flex;
     │                flex-wrap: wrap;
     │                justify-content: center;
     │                margin-top: 20px;
     │            }
     │
     │            .image-card {
     │                background: white;
     │                margin: 10px;
     │                padding: 10px;
     │                border-radius: 10px;
     │                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
     │                width: 320px;
     │            }
     │
     │            .image-card img {
     │                max-width: 100%;
     │                border-radius: 8px;
     │            }
     │
     │            .image-card p {
     │                margin-top: 8px;
     │                font-size: 14px;
     │                color: #555;
     │                text-align: center;
     │            }
     │        </style>
     │
     │
     │        {% block content %}
     │        <h1>YOLO Image Processor</h1>
     │
     │        <!-- Buttons -->
     │        <div class="buttons">
     │            <form action="/run" method="post">
     │                <button type="submit">🚀 Run YOLO on Images</button>
     │            </form>
     │        </div>
     │
     │        <!-- Images -->
     │        <h2 style="text-align: center;">Processed Images</h2>
     │
     │        {% if images %}
     │            <div class="image-gallery">
     │                {% for img in images %}
     │                    <div class="image-card">
     │                        <img src="{{ url_for('static', filename='predictions/' + img) }}" alt="{{ img }}">
     │                        <p>{{ img }}</p>
     │                    </div>
     │                {% endfor %}
     │            </div>
     │        {% else %}
     │            <p style="text-align: center;">No processed images yet.</p>
     │        {% endif %}
     │        {% endblock %}
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── base.html
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        <!DOCTYPE html>
     │        <html lang="en">
     │        <head>
     │            <meta charset="UTF-8">
     │            <meta name="viewport" content="width=device-width, initial-scale=1.0">
     │            <title>Greenhouse Monitoring</title>
     │            <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
     │            <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
     │
     │            <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
     │            <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
     │            <style>
     │                    .chart-container {
     │                    width: 100%;
     │                    max-width: 900px;
     │                    margin: auto;
     │                    margin-top: 50px;
     │                }
     │            </style>
     │        </head>
     │        <body>
     │
     │            <nav>
     │                <div class="logo">Greenhouse</div>
     │                <ul>
     │                    <li><a href="/">Home</a></li>
     │                    <li><a href="/dashboard">Dashboard</a></li>
     │                    <li><a href="/results">Diseases Detection</a></li>
     │                </ul>
     │            </nav>
     │
     │            <main>
     │                {% block content %}{% endblock %}
     │            </main>
     │        </body>
     │        </html>
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── dashboard.html
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        {% extends "base.html" %}
     │
     │        {% block content %}
     │        <h1>🌿 Greenhouse Sensor Dashboard</h1>
     │
     │        <!-- Time Scale Controls -->
     │        <div class="chart-section">
     │            <h2>Time Scale</h2>
     │            <div class="button-group" id="time-scale-buttons">
     │                <button onclick="setTimeScale('seconds')" id="scale-seconds">Seconds</button>
     │                <button onclick="setTimeScale('minutes')" id="scale-minutes" class="active">Minutes</button>
     │                <button onclick="setTimeScale('hours')" id="scale-hours">Hours</button>
     │                <button onclick="setTimeScale('days')" id="scale-days">Days</button>
     │                <button onclick="setTimeScale('weeks')" id="scale-weeks">Weeks</button>
     │            </div>
     │        </div>
     │
     │        <!-- Weighted Chart -->
     │        <div class="chart-section">
     │            <h2>Weighted Average Fusion</h2>
     │            <div id="weightedChart" class="plot-container"></div>
     │        </div>
     │
     │        <!-- Raw Sensor Chart -->
     │        <div class="chart-section">
     │            <h2>Raw Sensor Data</h2>
     │            <div class="button-group">
     │                <button onclick="showRawCategory('temperature')" id="raw-temperature" class="active">🌡️ Temperature</button>
     │                <button onclick="showRawCategory('humidity')" id="raw-humidity">💧 Humidity</button>
     │                <button onclick="showRawCategory('soil')" id="raw-soil">🌱 Soil Moisture</button>
     │            </div>
     │            <div id="rawChart" class="plot-container"></div>
     │        </div>
     │
     │        <!-- Kalman Filter Chart -->
     │        <div class="chart-section">
     │            <h2>Kalman Filter Fusion</h2>
     │            <div class="button-group">
     │                <button onclick="showKalmanCategory('temperature')" id="kalman-temperature" class="active">🌡️ Temperature</button>
     │                <button onclick="showKalmanCategory('humidity')" id="kalman-humidity">💧 Humidity</button>
     │                <button onclick="showKalmanCategory('soil')" id="kalman-soil">🌱 Soil Moisture</button>
     │            </div>
     │            <div id="kalmanChart" class="plot-container"></div>
     │        </div>
     │
     │        <!-- Plotly Script -->
     │        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
     │
     │        <script>
     │        let rawCategories = { temperature: [], humidity: [], soil: [] };
     │        let kalmanCategories = { temperature: [], humidity: [], soil: [] };
     │        let weightedDataCache = [];
     │        let currentTimeScale = 'minutes';
     │
     │        function setTimeScale(scale) {
     │            currentTimeScale = scale;
     │            document.querySelectorAll('#time-scale-buttons button').forEach(btn => btn.classList.remove('active'));
     │            document.getElementById(`scale-${scale}`).classList.add('active');
     │
     │            showRawCategory(document.querySelector(".button-group .active[id^='raw-']").id.split("-")[1]);
     │            showKalmanCategory(document.querySelector(".button-group .active[id^='kalman-']").id.split("-")[1]);
     │            plotWeighted(weightedDataCache);
     │        }
     │
     │        function getWeekNumber(d) {
     │            const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
     │            const dayNum = date.getUTCDay() || 7;
     │            date.setUTCDate(date.getUTCDate() + 4 - dayNum);
     │            const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
     │            return Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
     │        }
     │
     │        function formatTimestamps(timestamps) {
     │            return timestamps.map(str => {
     │                const date = new Date(str);
     │                if (currentTimeScale === "weeks") return str;
     │
     │                if (isNaN(date.getTime())) return str;
     │
     │                switch (currentTimeScale) {
     │                    case 'seconds':
     │                        return date.toLocaleTimeString();
     │                    case 'minutes':
     │                        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
     │                    case 'hours':
     │                        return date.toLocaleTimeString([], { hour: '2-digit' }) + ":00";
     │                    case 'days':
     │                        return date.toLocaleDateString();
     │                    default:
     │                        return str;
     │                }
     │            });
     │        }
     │
     │        function groupDataByScale(sensorData, scale) {
     │            const grouped = [];
     │
     │            for (const sensor of sensorData) {
     │                const buckets = {};
     │
     │                for (let i = 0; i < sensor.timestamps.length; i++) {
     │                    const date = new Date(sensor.timestamps[i]);
     │
     │                    let key;
     │                    switch (scale) {
     │                        case 'seconds':
     │                            key = date.toISOString();
     │                            break;
     │                        case 'minutes':
     │                            key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()} ${date.getHours()}:${date.getMinutes()}`;
     │                            break;
     │                        case 'hours':
     │                            key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()} ${date.getHours()}:00`;
     │                            break;
     │                        case 'days':
     │                            key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
     │                            break;
     │                        case 'weeks':
     │                            const week = getWeekNumber(date);
     │                            key = `${date.getFullYear()}-W${week}`;
     │                            break;
     │                        default:
     │                            key = date.toISOString();
     │                    }
     │
     │                    if (!buckets[key]) buckets[key] = [];
     │                    buckets[key].push(sensor.values[i]);
     │                }
     │
     │                const groupedTimestamps = Object.keys(buckets);
     │                const groupedValues = groupedTimestamps.map(k =>
     │                    buckets[k].reduce((a, b) => a + b, 0) / buckets[k].length
     │                );
     │
     │                grouped.push({
     │                    label: sensor.label || sensor.sensor_type,
     │                    timestamps: groupedTimestamps,
     │                    values: groupedValues
     │                });
     │            }
     │
     │            return grouped;
     │        }
     │
     │        function categorize(data) {
     │            const categories = { temperature: [], humidity: [], soil: [] };
     │            for (const d of data) {
     │                const name = d.label.toLowerCase();
     │                if (name.includes("temp")) categories.temperature.push(d);
     │                else if (name.includes("humid")) categories.humidity.push(d);
     │                else if (name.includes("soil")) categories.soil.push(d);
     │            }
     │            return categories;
     │        }
     │
     │        function plotCategory(data, elementId) {
     │            if (data.length === 0) {
     │                Plotly.purge(elementId);
     │                document.getElementById(elementId).innerHTML = "<p style='text-align:center;color:#888;'>No data available.</p>";
     │                return;
     │            }
     │
     │            const grouped = groupDataByScale(data, currentTimeScale);
     │
     │            Plotly.react(elementId, grouped.map(sensor => ({
     │                x: formatTimestamps(sensor.timestamps),
     │                y: sensor.values,
     │                mode: 'lines+markers',
     │                name: sensor.label
     │            })), {
     │                xaxis: { title: 'Time' },
     │                yaxis: { title: 'Value' },
     │                margin: { t: 10 }
     │            });
     │        }
     │
     │        function plotWeighted(data) {
     │            weightedDataCache = data;
     │            if (data.length === 0) {
     │                Plotly.purge("weightedChart");
     │                document.getElementById("weightedChart").innerHTML = "<p style='text-align:center;color:#888;'>No data available.</p>";
     │                return;
     │            }
     │
     │            const grouped = groupDataByScale(data, currentTimeScale);
     │
     │        Plotly.react("weightedChart", grouped.map(sensor => ({
     │            x: formatTimestamps(sensor.timestamps),
     │            y: sensor.values,
     │            mode: 'lines+markers',
     │            name: sensor.label || sensor.sensor_type || "Unknown"
     │        })), {
     │            xaxis: { title: 'Time' },
     │            yaxis: { title: 'Fused Value' },
     │            margin: { t: 10 }
     │        });
     │
     │        }
     │
     │        function setActive(prefix, type) {
     │            document.querySelectorAll(`button[id^="${prefix}-"]`).forEach(btn => btn.classList.remove("active"));
     │            document.getElementById(`${prefix}-${type}`).classList.add("active");
     │        }
     │
     │        function showRawCategory(type) {
     │            plotCategory(rawCategories[type], "rawChart");
     │            setActive("raw", type);
     │        }
     │
     │        function showKalmanCategory(type) {
     │            plotCategory(kalmanCategories[type], "kalmanChart");
     │            setActive("kalman", type);
     │        }
     │
     │        async function fetchAndUpdateCharts() {
     │            try {
     │                const response = await fetch("/api/dashboard-data");
     │                const data = await response.json();
     │
     │                rawCategories = categorize(data.raw);
     │                kalmanCategories = categorize(data.kalman);
     │                weightedDataCache = data.weighted;
     │
     │                const rawType = document.querySelector(".button-group .active[id^='raw-']").id.split("-")[1];
     │                const kalmanType = document.querySelector(".button-group .active[id^='kalman-']").id.split("-")[1];
     │
     │                showRawCategory(rawType);
     │                showKalmanCategory(kalmanType);
     │                plotWeighted(weightedDataCache);
     │            } catch (err) {
     │                console.error("Failed to fetch update:", err);
     │            }
     │        }
     │
     │        fetchAndUpdateCharts();
     │        setInterval(fetchAndUpdateCharts, 10000);
     │        </script>
     │
     │        <style>
     │        body {
     │            font-family: 'Inter', sans-serif;
     │            background-color: #f4f6f9;
     │            margin: 0;
     │            padding: 0;
     │            color: #333;
     │        }
     │
     │        h1 {
     │            text-align: center;
     │            padding: 30px 0 10px;
     │            font-size: 2.2rem;
     │        }
     │
     │        h2 {
     │            font-size: 1.4rem;
     │            margin-bottom: 10px;
     │            color: #2c3e50;
     │        }
     │
     │        .chart-section {
     │            margin: 30px auto;
     │            max-width: 1000px;
     │            background: white;
     │            border-radius: 12px;
     │            padding: 25px;
     │            box-shadow: 0 4px 12px rgba(0,0,0,0.06);
     │        }
     │
     │        .button-group {
     │            display: flex;
     │            justify-content: center;
     │            margin: 20px 0 10px;
     │            flex-wrap: wrap;
     │        }
     │
     │        .button-group button {
     │            padding: 10px 18px;
     │            margin: 6px;
     │            cursor: pointer;
     │            border: none;
     │            border-radius: 8px;
     │            background-color: #e0e6ed;
     │            color: #333;
     │            font-weight: 600;
     │            transition: 0.2s ease;
     │        }
     │
     │        .button-group button:hover {
     │            background-color: #d0dbe8;
     │        }
     │
     │        .button-group .active {
     │            background-color: #2c7be5;
     │            color: #fff;
     │        }
     │
     │        .plot-container {
     │            width: 100%;
     │            height: 400px;
     │        }
     │
     │        @media (max-width: 768px) {
     │            .button-group {
     │                flex-direction: column;
     │                align-items: center;
     │            }
     │
     │            .button-group button {
     │                width: 80%;
     │            }
     │
     │            .plot-container {
     │                height: 350px;
     │            }
     │        }
     │        </style>
     │        {% endblock %}
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── index.html
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        {% extends "base.html" %}
     │
     │        {% block content %}
     │        <div class="container">
     │            <h1>Welcome to the AI-driven Greenhouse</h1>
     │
     │        </div>
     │
     │        <!-- Device Control Panel -->
     │        <div class="control-panel">
     │            <h2>Device Controls</h2>
     │            <button id="fan-btn" class="control-btn off" onclick="toggleDevice('toggle_fan', 'fan-btn')">Ventilation Fan: OFF</button>
     │            <button id="shutter-btn" class="control-btn off" onclick="toggleDevice('toggle_shutter', 'shutter-btn')">Intake Shutter: OFF</button>
     │            <button id="pump-btn" class="control-btn off" onclick="toggleDevice('toggle_pump', 'pump-btn')">Water Pump: OFF</button>
     │        </div>
     │
     │        <!-- Threshold Slider Panel -->
     │        <div class="slider-panel">
     │            <h2>Threshold Settings</h2>
     │            <label>Temperature Threshold: <span id="tempValue">27</span>°C</label>
     │            <input type="range" id="tempSlider" min="10" max="50" value="27" oninput="updateSlider('temp')">
     │
     │            <label>Humidity Threshold: <span id="humValue">80</span>%</label>
     │            <input type="range" id="humSlider" min="30" max="100" value="80" oninput="updateSlider('hum')">
     │
     │            <label>Soil Moisture Threshold: <span id="soilValue">4000</span></label>
     │            <input type="range" id="soilSlider" min="500" max="6000" value="4000" oninput="updateSlider('soil')">
     │
     │            <button onclick="saveThresholds()">Save Thresholds</button>
     │        </div>
     │
     │        <!--  Live Status Display moved here -->
     │        <div class="container">
     │            <h1>🌿 Greenhouse Live Status</h1>
     │            <div class="status-container">
     │                <div class="status-box">
     │                    <h2>🌡️ Temperature</h2>
     │                    <p id="temp-value">-- °C</p>
     │                </div>
     │                <div class="status-box">
     │                    <h2>💧 Humidity</h2>
     │                    <p id="humidity-value">-- %</p>
     │                </div>
     │                <div class="status-box">
     │                    <h2>🌱 Soil Moisture</h2>
     │                    <p id="soil-value">--</p>
     │                </div>
     │            </div>
     │        </div>
     │
     │        <!-- Camera Stream -->
     │        <div class="container">
     │            <h1>Surveillance</h1>
     │            <p>Two cameras for monitoring.</p>
     │            <img id="camera-stream" src="http://192.168.200.155:81/stream" width="400" height="400" alt="ESP32-CAM Stream"
     │                 onerror="this.onerror=null; this.src='static/no-signal.jpg';">
     │        </div>
     │
     │        <script>
     │            function updateSlider(type) {
     │                if (type === 'temp') {
     │                    document.getElementById('tempValue').textContent = document.getElementById('tempSlider').value;
     │                } else if (type === 'hum') {
     │                    document.getElementById('humValue').textContent = document.getElementById('humSlider').value;
     │                } else if (type === 'soil') {
     │                    document.getElementById('soilValue').textContent = document.getElementById('soilSlider').value;
     │                }
     │            }
     │
     │            function saveThresholds() {
     │                const data = {
     │                    temp_threshold: document.getElementById('tempSlider').value,
     │                    hum_threshold: document.getElementById('humSlider').value,
     │                    soil_moisture_threshold: document.getElementById('soilSlider').value
     │                };
     │
     │                fetch('/set_thresholds', {
     │                    method: 'POST',
     │                    headers: { 'Content-Type': 'application/json' },
     │                    body: JSON.stringify(data)
     │                })
     │                .then(res => res.json())
     │                .then(response => {
     │                    alert(response.message);
     │                })
     │                .catch(error => {
     │                    console.error('Error:', error);
     │                    alert('Error saving thresholds.');
     │                });
     │            }
     │
     │            window.onload = () => {
     │                fetch('/get_thresholds')
     │                    .then(res => res.json())
     │                    .then(data => {
     │                        document.getElementById('tempSlider').value = data.TEMP_THRESHOLD;
     │                        document.getElementById('humSlider').value = data.HUM_THRESHOLD;
     │                        document.getElementById('soilSlider').value = data.SOIL_MOISTURE_THRESHOLD;
     │                        updateSlider('temp');
     │                        updateSlider('hum');
     │                        updateSlider('soil');
     │                    });
     │
     │                fetchLatestValues();
     │                setInterval(fetchLatestValues, 10000); // Refresh every 10 seconds
     │            };
     │
     │            async function fetchLatestValues() {
     │                try {
     │                    const res = await fetch('/api/latest-fused-values');
     │                    const data = await res.json();
     │
     │                    document.getElementById("temp-value").textContent = data.temperature?.toFixed(2) + " °C";
     │                    document.getElementById("humidity-value").textContent = data.humidity?.toFixed(2) + " %";
     │                    document.getElementById("soil-value").textContent = data.soil_moisture?.toFixed(2);
     │                } catch (err) {
     │                    console.error("Failed to load latest values", err);
     │                }
     │            }
     │
     │            function toggleDevice(action, buttonId) {
     │                const button = document.getElementById(buttonId);
     │                const isOn = button.classList.contains("on");
     │
     │                fetch('/receive', {
     │                    method: 'POST',
     │                    headers: {
     │                        'Content-Type': 'application/json',
     │                        'Authorization': 'Basic ' + btoa('web_control:web_password')
     │                    },
     │                    body: JSON.stringify({
     │                        DeviceID: 99,
     │                        DeviceName: "web_control",
     │                        Action: action
     │                    })
     │                })
     │                .then(response => response.json())
     │                .then(data => {
     │                    if (data.action.includes("executed")) {
     │                        button.classList.toggle("on", !isOn);
     │                        button.classList.toggle("off", isOn);
     │                        button.innerText = button.innerText.replace(isOn ? "ON" : "OFF", isOn ? "OFF" : "ON");
     │                    } else {
     │                        alert("Failed to execute command.");
     │                    }
     │                })
     │                .catch(error => console.error('Error:', error));
     │            }
     │        </script><style>
     │            * {
     │                box-sizing: border-box;
     │            }
     │
     │            body {
     │                margin: 0;
     │                font-family: Arial, sans-serif;
     │            }
     │
     │            .container {
     │                padding: 20px;
     │                margin-left: 270px;
     │                transition: margin-left 0.3s ease;
     │            }
     │
     │            .control-panel,
     │            .slider-panel {
     │                width: 240px;
     │                padding: 15px;
     │                background-color: #f4f4f4;
     │                border-radius: 10px;
     │                box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
     │                position: fixed;
     │                left: 20px;
     │                z-index: 10;
     │            }
     │
     │            .control-panel {
     │                top: 100px;
     │            }
     │
     │            .slider-panel {
     │                bottom: 10%;
     │                background-color: #f9f9f9;
     │            }
     │
     │            .control-btn {
     │                display: block;
     │                width: 100%;
     │                margin: 10px 0;
     │                padding: 10px;
     │                font-size: 16px;
     │                font-weight: bold;
     │                border: none;
     │                border-radius: 5px;
     │                cursor: pointer;
     │            }
     │
     │            .on {
     │                background-color: green;
     │                color: white;
     │            }
     │
     │            .off {
     │                background-color: red;
     │                color: white;
     │            }
     │
     │            .slider-panel label {
     │                margin-top: 10px;
     │                display: block;
     │            }
     │
     │            .slider-panel input[type="range"] {
     │                width: 100%;
     │            }
     │
     │            .slider-panel button {
     │                margin-top: 15px;
     │                width: 100%;
     │                padding: 10px;
     │                font-weight: bold;
     │                background-color: #007BFF;
     │                color: white;
     │                border: none;
     │                border-radius: 5px;
     │                cursor: pointer;
     │            }
     │
     │            .status-container {
     │                display: flex;
     │                justify-content: center;
     │                flex-wrap: wrap;
     │                gap: 30px;
     │                margin: 40px 0;
     │            }
     │
     │            .status-box {
     │                background: white;
     │                border-radius: 12px;
     │                padding: 30px;
     │                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
     │                text-align: center;
     │                width: 30%;
     │                min-width: 220px;
     │                flex: 1 1 250px;
     │            }
     │
     │            .status-box h2 {
     │                margin-bottom: 10px;
     │                font-size: 1.4rem;
     │                color: #2c3e50;
     │            }
     │
     │            .status-box p {
     │                font-size: 2rem;
     │                font-weight: bold;
     │                color: #2c7be5;
     │            }
     │
     │            img#camera-stream {
     │                max-width: 100%;
     │                height: auto;
     │                display: block;
     │                margin-top: 20px;
     │            }
     │
     │            /* Small and medium screen support */
     │            @media (max-width: 992px) {
     │                .container {
     │                    margin-left: 0;
     │                    padding: 15px;
     │                }
     │
     │                .control-panel,
     │                .slider-panel {
     │                    position: static;
     │                    width: 100%;
     │                    margin-bottom: 20px;
     │                }
     │
     │                .status-container {
     │                    flex-direction: column;
     │                    align-items: center;
     │                }
     │
     │                .status-box {
     │                    width: 90%;
     │                    max-width: 400px;
     │                }
     │            }
     │        </style>
     │
     │
     │        {% endblock %}
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   └── status.html
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        {% extends "base.html" %}
     │
     │        {% block content %}
     │        <h1>🌿 Greenhouse Live Status</h1>
     │
     │        <div class="status-container">
     │            <div class="status-box">
     │                <h2>🌡️ Temperature</h2>
     │                <p id="temp-value">-- °C</p>
     │            </div>
     │            <div class="status-box">
     │                <h2>💧 Humidity</h2>
     │                <p id="humidity-value">-- %</p>
     │            </div>
     │            <div class="status-box">
     │                <h2>🌱 Soil Moisture</h2>
     │                <p id="soil-value">--</p>
     │            </div>
     │        </div>
     │
     │        <script>
     │        async function fetchLatestValues() {
     │            try {
     │                const res = await fetch('/api/latest-fused-values');
     │                const data = await res.json();
     │
     │                document.getElementById("temp-value").textContent = data.temperature?.toFixed(2) + " °C";
     │                document.getElementById("humidity-value").textContent = data.humidity?.toFixed(2) + " %";
     │                document.getElementById("soil-value").textContent = data.soil_moisture?.toFixed(2);
     │            } catch (err) {
     │                console.error("Failed to load latest values", err);
     │            }
     │        }
     │
     │        fetchLatestValues();
     │        setInterval(fetchLatestValues, 10000); // refresh every 10 seconds
     │        </script>
     │
     │        <style>
     │        .status-container {
     │            display: flex;
     │            justify-content: center;
     │            flex-wrap: wrap;
     │            gap: 30px;
     │            margin-top: 40px;
     │        }
     │
     │        .status-box {
     │            background: white;
     │            border-radius: 12px;
     │            padding: 30px;
     │            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
     │            text-align: center;
     │            width: 250px;
     │        }
     │
     │        .status-box h2 {
     │            margin-bottom: 10px;
     │            font-size: 1.4rem;
     │            color: #2c3e50;
     │        }
     │
     │        .status-box p {
     │            font-size: 2rem;
     │            font-weight: bold;
     │            color: #2c7be5;
     │        }
     │        </style>
     │        {% endblock %}
     │        ↑↑↑ END OF FILE ↑↑↑
     
     ├── trials
     │   ├── capturingImagesFromRasCam.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        import cv2
     │        import requests
     │        import numpy as np
     │        import time
     │
     │        # MJPEG stream URL
     │        url = "http://192.168.1.15:5000/video_feed"
     │
     │        # Connect to the stream
     │        stream = requests.get(url, stream=True)
     │        if stream.status_code != 200:
     │            print("❌ Failed to connect to video stream")
     │            exit()
     │
     │        print("📷 Press 'b' to capture an image, 'q' to quit")
     │
     │        bytes_buffer = b""
     │        img_count = 0
     │
     │        for chunk in stream.iter_content(chunk_size=1024):
     │            bytes_buffer += chunk
     │            a = bytes_buffer.find(b'\xff\xd8')
     │            b = bytes_buffer.find(b'\xff\xd9')
     │
     │            if a != -1 and b != -1:
     │                jpg = bytes_buffer[a:b+2]
     │                bytes_buffer = bytes_buffer[b+2:]
     │
     │                img_np = np.frombuffer(jpg, dtype=np.uint8)
     │                frame = cv2.imdecode(img_np, cv2.IMREAD_COLOR)
     │                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
     │
     │                if frame is not None:
     │                    cv2.imshow("Live Stream", frame)
     │
     │                    key = cv2.waitKey(1) & 0xFF
     │                    if key == ord('b'):
     │                        filename = f"snapshot_{int(time.time())}.jpg"
     │                        cv2.imwrite(filename, frame)
     │                        print(f"✅ Saved snapshot as {filename}")
     │                    elif key == ord('q'):
     │                        print("👋 Exiting...")
     │                        break
     │
     │        cv2.destroyAllWindows()
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── dashboardprev.html
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        <!--
     │        <script>
     │            function updateDashboard() {
     │                $.getJSON("/data", function(data) {
     │                    let time = data.time;
     │
     │                    // Temperature Chart
     │                    let temperature_traces = [];
     │                    for (let i = 0; i < 4; i++) {
     │                        temperature_traces.push({
     │                            x: time,
     │                            y: data.temperature[i],
     │                            mode: 'lines',
     │                            name: 'Temp ' + (i+1)
     │                        });
     │                    }
     │                    Plotly.react('temperature_chart', temperature_traces, { title: 'Temperature Over Time' });
     │
     │                    // Humidity Chart
     │                    let humidity_traces = [];
     │                    for (let i = 0; i < 2; i++) {
     │                        humidity_traces.push({
     │                            x: time,
     │                            y: data.humidity[i],
     │                            mode: 'lines',
     │                            name: 'Humidity ' + (i+1)
     │                        });
     │                    }
     │                    Plotly.react('humidity_chart', humidity_traces, { title: 'Humidity Over Time' });
     │
     │                    // Soil Moisture Chart
     │                    let soil_moisture_traces = [];
     │                    for (let i = 0; i < 2; i++) {
     │                        soil_moisture_traces.push({
     │                            x: time,
     │                            y: data.soil_moisture[i],
     │                            mode: 'lines',
     │                            name: 'Soil Moisture ' + (i+1)
     │                        });
     │                    }
     │                    Plotly.react('soil_moisture_chart', soil_moisture_traces, { title: 'Soil Moisture Over Time' });
     │                });
     │            }
     │
     │            // Update dashboard every 5 seconds
     │            setInterval(updateDashboard, 5000);
     │            updateDashboard();
     │        </script> -->
     │        <!-- <script>
     │            function updateDashboard() {
     │                $.getJSON("/data", function(data) {
     │                    let time = data.time;
     │
     │                    // Temperature Chart
     │                    let temperature_traces = [];
     │                    if (data.temperature) {
     │                        let temperature_values = Object.values(data.temperature); // Extract values dynamically
     │                        for (let i = 0; i < temperature_values.length; i++) {
     │                            temperature_traces.push({
     │                                x: time,
     │                                y: temperature_values[i],
     │                                mode: 'lines',
     │                                name: 'Temp ' + (i + 1)
     │                            });
     │                        }
     │                    }
     │                    Plotly.react('temperature_chart', temperature_traces, { title: 'Temperature Over Time' });
     │
     │                    // Humidity Chart
     │                    let humidity_traces = [];
     │                    if (data.humidity) {
     │                        let humidity_values = Object.values(data.humidity);
     │                        for (let i = 0; i < humidity_values.length; i++) {
     │                            humidity_traces.push({
     │                                x: time,
     │                                y: humidity_values[i],
     │                                mode: 'lines',
     │                                name: 'Humidity ' + (i + 1)
     │                            });
     │                        }
     │                    }
     │                    Plotly.react('humidity_chart', humidity_traces, { title: 'Humidity Over Time' });
     │
     │                    // Soil Moisture Chart
     │                    let soil_moisture_traces = [];
     │                    if (data.soil_moisture) {
     │                        let soil_moisture_values = Object.values(data.soil_moisture);
     │                        for (let i = 0; i < soil_moisture_values.length; i++) {
     │                            soil_moisture_traces.push({
     │                                x: time,
     │                                y: soil_moisture_values[i],
     │                                mode: 'lines',
     │                                name: 'Soil Moisture ' + (i + 1)
     │                            });
     │                        }
     │                    }
     │                    Plotly.react('soil_moisture_chart', soil_moisture_traces, { title: 'Soil Moisture Over Time' });
     │                });
     │            }
     │
     │            // Update dashboard every 5 seconds
     │            setInterval(updateDashboard, 5000);
     │            updateDashboard();
     │        </script> -->
     │
     │        <script>
     │            function updateDashboard() {
     │                $.getJSON("/data", function(data) {
     │                    let time = data.time;
     │                    let deviceIDs = data.DeviceID;
     │
     │                    function createTraces(sensorData, chartId, title, label) {
     │                        let traces = {};
     │
     │                        for (let i = 0; i < 4; i++) {
     │                            let deviceId = deviceIDs[i];
     │                            if (!(deviceId in traces)) {
     │                                traces[deviceId] = { x: [], y: [], mode: 'lines', name: label + ' Device ' + deviceId };
     │                            }
     │                            traces[deviceId].x.push(time[i]);
     │                            traces[deviceId].y.push(sensorData[i]);
     │                        }
     │
     │                        Plotly.react(chartId, Object.values(traces), { title: title });
     │                    }
     │
     │                    if (data.temperature) {
     │                        createTraces(data.temperature, 'temperature_chart', 'Temperature Over Time', 'Temp');
     │                    }
     │
     │                    if (data.humidity) {
     │                        createTraces(data.humidity, 'humidity_chart', 'Humidity Over Time', 'Humidity');
     │                    }
     │
     │                    if (data.soil_moisture) {
     │                        createTraces(data.soil_moisture, 'soil_moisture_chart', 'Soil Moisture Over Time', 'Soil Moisture');
     │                    }
     │                });
     │            }
     │
     │            // Update dashboard every 5 seconds
     │            setInterval(updateDashboard, 5000);
     │            updateDashboard();
     │        </script>
     │
     │        <!-- {% extends "base.html" %}
     │
     │        {% block content %}
     │
     │        <h1>Greenhouse Monitoring Dashboard</h1>
     │
     │        <div id="temperature_chart"></div>
     │        <div id="humidity_chart"></div>
     │        <div id="soil_moisture_chart"></div>
     │
     │        <script>
     │            function updateDashboard() {
     │                $.getJSON("/data", function(data) {
     │                    let time = data.time;
     │
     │                    // Temperature Chart
     │                    let temperature_traces = [];
     │                    for (let i = 0; i < 4; i++) {
     │                        temperature_traces.push({
     │                            x: time,
     │                            y: data.temperature[i],
     │                            mode: 'lines',
     │                            name: 'Temp ' + (i+1)
     │                        });
     │                    }
     │                    Plotly.react('temperature_chart', temperature_traces, { title: 'Temperature Over Time' });
     │
     │                    // Humidity Chart
     │                    let humidity_traces = [];
     │                    for (let i = 0; i < 4; i++) {
     │                        humidity_traces.push({
     │                            x: time,
     │                            y: data.humidity[i],
     │                            mode: 'lines',
     │                            name: 'Humidity ' + (i+1)
     │                        });
     │                    }
     │                    Plotly.react('humidity_chart', humidity_traces, { title: 'Humidity Over Time' });
     │
     │                    // Soil Moisture Chart
     │                    let soil_moisture_traces = [];
     │                    for (let i = 0; i < 2; i++) {
     │                        soil_moisture_traces.push({
     │                            x: time,
     │                            y: data.soil_moisture[i],
     │                            mode: 'lines',
     │                            name: 'Soil Moisture ' + (i+1)
     │                        });
     │                    }
     │                    Plotly.react('soil_moisture_chart', soil_moisture_traces, { title: 'Soil Moisture Over Time' });
     │                });
     │            }
     │
     │            // Update dashboard every 5 seconds
     │            setInterval(updateDashboard, 50000);
     │            updateDashboard();
     │        </script>
     │
     │
     │        {% endblock %} -->
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── dashboardupgrade.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from flask import Blueprint, jsonify
     │        import json
     │        import os
     │        import time
     │
     │        dashboard_bp = Blueprint("dashboard", __name__)
     │
     │        # File to store the last known data
     │        DATA_FILE = "last_data.json"
     │
     │        # Function to load the last known data
     │        def load_last_data():
     │            if os.path.exists(DATA_FILE):
     │                with open(DATA_FILE, "r") as f:
     │                    return json.load(f)
     │            return {
     │                "time": [],
     │                "temperature": [[] for _ in range(6)],
     │                "humidity": [[] for _ in range(6)],
     │                "soil_moisture": [[] for _ in range(4)]
     │            }
     │
     │        # Function to save data
     │        def save_data(data):
     │            with open(DATA_FILE, "w") as f:
     │                json.dump(data, f)
     │
     │        # Global variable to store last known data
     │        last_data = load_last_data()
     │        last_update_time = time.time()
     │
     │        @dashboard_bp.route("/data")
     │        def get_data():
     │            global last_data, last_update_time
     │
     │            new_data = fetch_sensor_data()  # Replace this with your actual function
     │
     │            if new_data:  # If there's new data, update the stored data
     │                last_data = new_data
     │                last_update_time = time.time()
     │                save_data(last_data)  # Save updated data
     │
     │            return jsonify(last_data)
     │
     │        def fetch_sensor_data():
     │            """
     │            Simulates getting new sensor data.
     │            Replace this with your actual function that gets data from sensors.
     │            Returns None if no new data.
     │            """
     │            # Simulated condition where sometimes no new data arrives
     │            if time.time() - last_update_time < 10:  # Assume no new data within 10 sec
     │                return None
     │
     │            # Simulated new data (Replace with real sensor data fetching)
     │            return {
     │                "time": ["2025-02-22 12:00:00"],  # Add real timestamp
     │                "temperature": [[22.3, 22.5, 22.7, 22.6, 22.8, 22.9]],
     │                "humidity": [[50, 51, 49, 48, 52, 50]],
     │                "soil_moisture": [[30, 32, 29, 31]]
     │            }
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── data_retrival.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from sqlalchemy.orm import sessionmaker
     │        from database_setup import engine, SensorData,UserInteraction
     │        import pandas as pd
     │
     │        # this could also be used for sensor fusion
     │
     │        #  Create session
     │        Session = sessionmaker(bind=engine)
     │        session = Session()
     │
     │        #  Fetch all readings as a list of dictionaries
     │        data = session.query(UserInteraction).all()
     │
     │        # Convert SQLAlchemy objects to dictionaries
     │        result_list = [
     │            {"DeviceID": d.DeviceID, "UserID": d.UserID, "Action": d.Action, "Timestamp": d.Timestamp}
     │            for d in data
     │        ]
     │
     │        #  Close session
     │        session.close()
     │
     │        print("\n Retrieved Sensor Readings List:")
     │        print(result_list)
     │        # data=result_list
     │        # # Convert to Pandas DataFrame
     │        # df = pd.DataFrame(data)
     │
     │        # # Convert 'Timestamp' column to datetime format (if needed)
     │        # df['Timestamp'] = pd.to_datetime(df['Timestamp'])
     │
     │        # # Convert Timestamp to datetime
     │        # df["Timestamp"] = pd.to_datetime(df["Timestamp"])
     │
     │        # # Pivot the table to restructure data
     │        # df_pivot = df.pivot_table(index=["Timestamp", "DeviceID"], columns="SensorType", values="Value", aggfunc="first")
     │
     │        # # Rename columns explicitly to match the required output
     │        # df_pivot.columns = df_pivot.columns.rename(None)  # Remove MultiIndex column names
     │        # df_pivot.rename(columns={
     │        #     "temperature": "temperature",
     │        #     "humidity": "humidity",
     │        #     "soil_moisture": "soil_moisture"
     │        # }, inplace=True)
     │
     │        # # Reset index to bring columns back
     │        # df_pivot.reset_index(inplace=True)
     │
     │        # # Rename Timestamp to time
     │        # df_pivot.rename(columns={"Timestamp": "time"}, inplace=True)
     │
     │        # # Display result
     │        # print(df_pivot)
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── database_setup.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, ForeignKey
     │        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
     │        from datetime import datetime
     │
     │        # Database connection
     │        DATABASE_URL = "sqlite:///greenhouse.db"
     │        engine = create_engine(DATABASE_URL, echo=True)
     │
     │        # Create session factory
     │        SessionLocal = sessionmaker(bind=engine)
     │
     │        #  Base Model
     │        class Base(DeclarativeBase):
     │            pass
     │
     │        #  Devices Table
     │        class Device(Base):
     │            __tablename__ = "devices"
     │
     │            DeviceID = Column(Integer, primary_key=True)
     │            DeviceName = Column(String(50), nullable=False)
     │            Location = Column(String(100))
     │            Status = Column(String(20))  # e.g., "Active", "Inactive"
     │            Type = Column(String(50))  # e.g., "ESP32", "Raspberry Pi"
     │
     │            sensor_data = relationship("SensorData", back_populates="device")
     │            user_interactions = relationship("UserInteraction", back_populates="device")
     │
     │        #  SensorData Table
     │        class SensorData(Base):
     │            __tablename__ = "sensor_data"
     │
     │            DataID = Column(Integer, primary_key=True)
     │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
     │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │            SensorType = Column(String(50))  # e.g., "temperature", "humidity"
     │            Value = Column(Float)  # Sensor reading value
     │
     │            device = relationship("Device", back_populates="sensor_data")
     │
     │        #  UserInteractions Table
     │        class UserInteraction(Base):
     │            __tablename__ = "user_interactions"
     │
     │            InteractionID = Column(Integer, primary_key=True)
     │            UserID = Column(Integer)  # Assuming users are stored elsewhere
     │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
     │            Action = Column(String(20), nullable=False)  # e.g., "Turn On", "Turn Off"
     │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │
     │            device = relationship("Device", back_populates="user_interactions")
     │
     │        #  Create Tables in SQLite
     │        Base.metadata.create_all(engine)
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── database_setups.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from sqlalchemy import (
     │            create_engine, Column, Integer, Float, String, DateTime, ForeignKey
     │        )
     │        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
     │        from datetime import datetime
     │
     │        # Database connection
     │        DATABASE_URL = "sqlite:///greenhouse.db"
     │        engine = create_engine(DATABASE_URL, echo=True)
     │        SessionLocal = sessionmaker(bind=engine)
     │
     │        # Base class
     │        class Base(DeclarativeBase):
     │            pass
     │
     │        # Devices Table
     │        class Device(Base):
     │            __tablename__ = "devices"
     │
     │            DeviceID = Column(Integer, primary_key=True)
     │            DeviceName = Column(String(50), nullable=False)
     │            Location = Column(String(100))
     │            Status = Column(String(20))  # e.g., "Active", "Inactive"
     │            Type = Column(String(50))    # e.g., "ESP32", "Raspberry Pi"
     │
     │            # Relationships
     │            sensors = relationship("Sensor", back_populates="device", cascade="all, delete-orphan")
     │            sensor_data = relationship("SensorData", secondary="sensors", viewonly=True)
     │            user_interactions = relationship("UserInteraction", back_populates="device", cascade="all, delete-orphan")
     │            kalman_fusions = relationship("KalmanFilterFusionData", back_populates="device", cascade="all, delete-orphan")
     │            weighted_fusions = relationship("WeightedAverageFusionData", back_populates="device", cascade="all, delete-orphan")
     │
     │        # Sensors Table
     │        class Sensor(Base):
     │            __tablename__ = "sensors"
     │
     │            SensorID = Column(Integer, primary_key=True)
     │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
     │            SensorType = Column(String(50))  # e.g., "DHT", "SoilMoisture"
     │            SensorIndex = Column(Integer)    # To distinguish multiple sensors of same type
     │            Location = Column(String(100))   # e.g., "Top Left"
     │            Status = Column(String(20), default="Active")
     │
     │            device = relationship("Device", back_populates="sensors")
     │            sensor_data = relationship("SensorData", back_populates="sensor", cascade="all, delete-orphan")
     │
     │        # SensorData Table
     │        class SensorData(Base):
     │            __tablename__ = "sensor_data"
     │
     │            DataID = Column(Integer, primary_key=True)
     │            SensorID = Column(Integer, ForeignKey("sensors.SensorID"), nullable=False)
     │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │            Value = Column(Float, nullable=False)
     │
     │            sensor = relationship("Sensor", back_populates="sensor_data")
     │
     │        # UserInteractions Table
     │        class UserInteraction(Base):
     │            __tablename__ = "user_interactions"
     │
     │            InteractionID = Column(Integer, primary_key=True)
     │            UserID = Column(Integer)
     │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
     │            ActuatorID = Column(Integer, ForeignKey("actuators.ActuatorID"))  # Optional, if interaction is with an actuator
     │            Action = Column(String(20), nullable=False)  # e.g., "Turn On", "Turn Off"
     │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │
     │            device = relationship("Device", back_populates="user_interactions")
     │
     │        # Kalman Filter Fusion Table
     │        class KalmanFilterFusionData(Base):
     │            __tablename__ = "kalman_filter_fusion"
     │
     │            FusionID = Column(Integer, primary_key=True)
     │            SensorID = Column(Integer, ForeignKey("kalmanFilterFusionData.SensorID"), nullable=False)
     │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │            FusedValue = Column(Float, nullable=False)
     │
     │
     │            sensor = relationship("Sensor", back_populates="kalmanFilterFusionData"
     │
     │        # Weighted Average Fusion Table
     │        class WeightedAverageFusionData(Base):
     │            __tablename__ = "weighted_average_fusion"
     │
     │            FusionID = Column(Integer, primary_key=True)
     │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
     │            SensorType = Column(String(50))  # Optional
     │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │            FusedValue = Column(Float, nullable=False)
     │
     │            device = relationship("Device", back_populates="weighted_fusions")
     │
     │        # Actuators Table
     │        class Actuator(Base):
     │            __tablename__ = "actuators"
     │
     │            ActuatorID = Column(Integer, primary_key=True)
     │            ActuatorName = Column(String(50), nullable=False, unique=True)
     │            Status = Column(String(20), nullable=False)  # e.g., "On", "Off"
     │            LastUpdated = Column(DateTime, default=datetime.utcnow)
     │            UserID = Column(Integer)  # Refers to the user who last updated it
     │
     │            def __repr__(self):
     │                return f"<Actuator(Name={self.ActuatorName}, Status={self.Status})>"
     │
     │        # Create all tables
     │        Base.metadata.create_all(engine)
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── everything.txt.txt
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        │        <h1>Greenhouse Monitoring Dashboard</h1>
     │        │
     │        │        <div id="temperature_chart"></div>
     │        │        <div id="humidity_chart"></div>
     │        │        <div id="soil_moisture_chart"></div>
     │        │
     │        │        <script>
     │        │            function updateDashboard() {
     │        │                $.getJSON("/data", function(data) {
     │        │                    let time = data.time;
     │        │
     │        │                    // Temperature Chart
     │        │                    let temperature_traces = [];
     │        │                    for (let i = 0; i < 4; i++) {
     │        │                        temperature_traces.push({
     │        │                            x: time,
     │        │                            y: data.temperature[i],
     │        │                            mode: 'lines',
     │        │                            name: 'Temp ' + (i+1)
     │        │                        });
     │        │                    }
     │        │                    Plotly.react('temperature_chart', temperature_traces, { title: 'Temperature Over Time' });
     │        │
     │        │                    // Humidity Chart
     │        │                    let humidity_traces = [];
     │        │                    for (let i = 0; i < 4; i++) {
     │        │                        humidity_traces.push({
     │        │                            x: time,
     │        │                            y: data.humidity[i],
     │        │                            mode: 'lines',
     │        │                            name: 'Humidity ' + (i+1)
     │        │                        });
     │        │                    }
     │        │                    Plotly.react('humidity_chart', humidity_traces, { title: 'Humidity Over Time' });
     │        │
     │        │                    // Soil Moisture Chart
     │        │                    let soil_moisture_traces = [];
     │        │                    for (let i = 0; i < 2; i++) {
     │        │                        soil_moisture_traces.push({
     │        │                            x: time,
     │        │                            y: data.soil_moisture[i],
     │        │                            mode: 'lines',
     │        │                            name: 'Soil Moisture ' + (i+1)
     │        │                        });
     │        │                    }
     │        │                    Plotly.react('soil_moisture_chart', soil_moisture_traces, { title: 'Soil Moisture Over Time' });
     │        │                });
     │        │            }
     │        │
     │        │            // Update dashboard every 5 seconds
     │        │            setInterval(updateDashboard, 50000);
     │        │            updateDashboard();
     │        │        </script>
     │        │
     │        │
     │        │        {% endblock %} -->
     │        │        ↑↑↑ END OF FILE ↑↑↑
     │
     │        │   ├── dashboardupgrade.py
     │        │        ↓↓↓ FILE CONTENT ↓↓↓
     │        │        from flask import Blueprint, jsonify
     │        │        import json
     │        │        import os
     │        │        import time
     │        │
     │        │        dashboard_bp = Blueprint("dashboard", __name__)
     │        │
     │        │        # File to store the last known data
     │        │        DATA_FILE = "last_data.json"
     │        │
     │        │        # Function to load the last known data
     │        │        def load_last_data():
     │        │            if os.path.exists(DATA_FILE):
     │        │                with open(DATA_FILE, "r") as f:
     │        │                    return json.load(f)
     │        │            return {
     │        │                "time": [],
     │        │                "temperature": [[] for _ in range(6)],
     │        │                "humidity": [[] for _ in range(6)],
     │        │                "soil_moisture": [[] for _ in range(4)]
     │        │            }
     │        │
     │        │        # Function to save data
     │        │        def save_data(data):
     │        │            with open(DATA_FILE, "w") as f:
     │        │                json.dump(data, f)
     │        │
     │        │        # Global variable to store last known data
     │        │        last_data = load_last_data()
     │        │        last_update_time = time.time()
     │        │
     │        │        @dashboard_bp.route("/data")
     │        │        def get_data():
     │        │            global last_data, last_update_time
     │        │
     │        │            new_data = fetch_sensor_data()  # Replace this with your actual function
     │        │
     │        │            if new_data:  # If there's new data, update the stored data
     │        │                last_data = new_data
     │        │                last_update_time = time.time()
     │        │                save_data(last_data)  # Save updated data
     │        │
     │        │            return jsonify(last_data)
     │        │
     │        │        def fetch_sensor_data():
     │        │            """
     │        │            Simulates getting new sensor data.
     │        │            Replace this with your actual function that gets data from sensors.
     │        │            Returns None if no new data.
     │        │            """
     │        │            # Simulated condition where sometimes no new data arrives
     │        │            if time.time() - last_update_time < 10:  # Assume no new data within 10 sec
     │        │                return None
     │        │
     │        │            # Simulated new data (Replace with real sensor data fetching)
     │        │            return {
     │        │                "time": ["2025-02-22 12:00:00"],  # Add real timestamp
     │        │                "temperature": [[22.3, 22.5, 22.7, 22.6, 22.8, 22.9]],
     │        │                "humidity": [[50, 51, 49, 48, 52, 50]],
     │        │                "soil_moisture": [[30, 32, 29, 31]]
     │        │            }
     │        │        ↑↑↑ END OF FILE ↑↑↑
     │
     │        │   ├── data_retrival.py
     │        │        ↓↓↓ FILE CONTENT ↓↓↓
     │        │        from sqlalchemy.orm import sessionmaker
     │        │        from database_setup import engine, SensorData,UserInteraction
     │        │        import pandas as pd
     │        │
     │        │        # this could also be used for sensor fusion
     │        │
     │        │        #  Create session
     │        │        Session = sessionmaker(bind=engine)
     │        │        session = Session()
     │        │
     │        │        #  Fetch all readings as a list of dictionaries
     │        │        data = session.query(UserInteraction).all()
     │        │
     │        │        # Convert SQLAlchemy objects to dictionaries
     │        │        result_list = [
     │        │            {"DeviceID": d.DeviceID, "UserID": d.UserID, "Action": d.Action, "Timestamp": d.Timestamp}
     │        │            for d in data
     │        │        ]
     │        │
     │        │        #  Close session
     │        │        session.close()
     │        │
     │        │        print("\n Retrieved Sensor Readings List:")
     │        │        print(result_list)
     │        │        # data=result_list
     │        │        # # Convert to Pandas DataFrame
     │        │        # df = pd.DataFrame(data)
     │        │
     │        │        # # Convert 'Timestamp' column to datetime format (if needed)
     │        │        # df['Timestamp'] = pd.to_datetime(df['Timestamp'])
     │        │
     │        │        # # Convert Timestamp to datetime
     │        │        # df["Timestamp"] = pd.to_datetime(df["Timestamp"])
     │        │
     │        │        # # Pivot the table to restructure data
     │        │        # df_pivot = df.pivot_table(index=["Timestamp", "DeviceID"], columns="SensorType", values="Value", aggfunc="first")
     │        │
     │        │        # # Rename columns explicitly to match the required output
     │        │        # df_pivot.columns = df_pivot.columns.rename(None)  # Remove MultiIndex column names
     │        │        # df_pivot.rename(columns={
     │        │        #     "temperature": "temperature",
     │        │        #     "humidity": "humidity",
     │        │        #     "soil_moisture": "soil_moisture"
     │        │        # }, inplace=True)
     │        │
     │        │        # # Reset index to bring columns back
     │        │        # df_pivot.reset_index(inplace=True)
     │        │
     │        │        # # Rename Timestamp to time
     │        │        # df_pivot.rename(columns={"Timestamp": "time"}, inplace=True)
     │        │
     │        │        # # Display result
     │        │        # print(df_pivot)
     │        │        ↑↑↑ END OF FILE ↑↑↑
     │
     │        │   ├── database_setup.py
     │        │        ↓↓↓ FILE CONTENT ↓↓↓
     │        │        from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, ForeignKey
     │        │        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
     │        │        from datetime import datetime
     │        │
     │        │        # Database connection
     │        │        DATABASE_URL = "sqlite:///greenhouse.db"
     │        │        engine = create_engine(DATABASE_URL, echo=True)
     │        │
     │        │        # Create session factory
     │        │        SessionLocal = sessionmaker(bind=engine)
     │        │
     │        │        #  Base Model
     │        │        class Base(DeclarativeBase):
     │        │            pass
     │        │
     │        │        #  Devices Table
     │        │        class Device(Base):
     │        │            __tablename__ = "devices"
     │        │
     │        │            DeviceID = Column(Integer, primary_key=True)
     │        │            DeviceName = Column(String(50), nullable=False)
     │        │            Location = Column(String(100))
     │        │            Status = Column(String(20))  # e.g., "Active", "Inactive"
     │        │            Type = Column(String(50))  # e.g., "ESP32", "Raspberry Pi"
     │        │
     │        │            sensor_data = relationship("SensorData", back_populates="device")
     │        │            user_interactions = relationship("UserInteraction", back_populates="device")
     │        │
     │        │        #  SensorData Table
     │        │        class SensorData(Base):
     │        │            __tablename__ = "sensor_data"
     │        │
     │        │            DataID = Column(Integer, primary_key=True)
     │        │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
     │        │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │        │            SensorType = Column(String(50))  # e.g., "temperature", "humidity"
     │        │            Value = Column(Float)  # Sensor reading value
     │        │
     │        │            device = relationship("Device", back_populates="sensor_data")
     │        │
     │        │        #  UserInteractions Table
     │        │        class UserInteraction(Base):
     │        │            __tablename__ = "user_interactions"
     │        │
     │        │            InteractionID = Column(Integer, primary_key=True)
     │        │            UserID = Column(Integer)  # Assuming users are stored elsewhere
     │        │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
     │        │            Action = Column(String(20), nullable=False)  # e.g., "Turn On", "Turn Off"
     │        │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │        │
     │        │            device = relationship("Device", back_populates="user_interactions")
     │        │
     │        │        #  Create Tables in SQLite
     │        │        Base.metadata.create_all(engine)
     │        │        ↑↑↑ END OF FILE ↑↑↑
     │
     │        │   ├── database_setups.py
     │        │        ↓↓↓ FILE CONTENT ↓↓↓
     │        │        from sqlalchemy import (
     │        │            create_engine, Column, Integer, Float, String, DateTime, ForeignKey
     │        │        )
     │        │        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
     │        │        from datetime import datetime
     │        │
     │        │        # Database connection
     │        │        DATABASE_URL = "sqlite:///greenhouse.db"
     │        │        engine = create_engine(DATABASE_URL, echo=True)
     │        │        SessionLocal = sessionmaker(bind=engine)
     │        │
     │        │        # Base class
     │        │        class Base(DeclarativeBase):
     │        │            pass
     │        │
     │        │        # Devices Table
     │        │        class Device(Base):
     │        │            __tablename__ = "devices"
     │        │
     │        │            DeviceID = Column(Integer, primary_key=True)
     │        │            DeviceName = Column(String(50), nullable=False)
     │        │            Location = Column(String(100))
     │        │            Status = Column(String(20))  # e.g., "Active", "Inactive"
     │        │            Type = Column(String(50))    # e.g., "ESP32", "Raspberry Pi"
     │        │
     │        │            # Relationships
     │        │            sensors = relationship("Sensor", back_populates="device", cascade="all, delete-orphan")
     │        │            sensor_data = relationship("SensorData", secondary="sensors", viewonly=True)
     │        │            user_interactions = relationship("UserInteraction", back_populates="device", cascade="all, delete-orphan")
     │        │            kalman_fusions = relationship("KalmanFilterFusionData", back_populates="device", cascade="all, delete-orphan")
     │        │            weighted_fusions = relationship("WeightedAverageFusionData", back_populates="device", cascade="all, delete-orphan")
     │        │
     │        │        # Sensors Table
     │        │        class Sensor(Base):
     │        │            __tablename__ = "sensors"
     │        │
     │        │            SensorID = Column(Integer, primary_key=True)
     │        │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
     │        │            SensorType = Column(String(50))  # e.g., "DHT", "SoilMoisture"
     │        │            SensorIndex = Column(Integer)    # To distinguish multiple sensors of same type
     │        │            Location = Column(String(100))   # e.g., "Top Left"
     │        │            Status = Column(String(20), default="Active")
     │        │
     │        │            device = relationship("Device", back_populates="sensors")
     │        │            sensor_data = relationship("SensorData", back_populates="sensor", cascade="all, delete-orphan")
     │        │
     │        │        # SensorData Table
     │        │        class SensorData(Base):
     │        │            __tablename__ = "sensor_data"
     │        │
     │        │            DataID = Column(Integer, primary_key=True)
     │        │            SensorID = Column(Integer, ForeignKey("sensors.SensorID"), nullable=False)
     │        │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │        │            Value = Column(Float, nullable=False)
     │        │
     │        │            sensor = relationship("Sensor", back_populates="sensor_data")
     │        │
     │        │        # UserInteractions Table
     │        │        class UserInteraction(Base):
     │        │            __tablename__ = "user_interactions"
     │        │
     │        │            InteractionID = Column(Integer, primary_key=True)
     │        │            UserID = Column(Integer)
     │        │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
     │        │            ActuatorID = Column(Integer, ForeignKey("actuators.ActuatorID"))  # Optional, if interaction is with an actuator
     │        │            Action = Column(String(20), nullable=False)  # e.g., "Turn On", "Turn Off"
     │        │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │        │
     │        │            device = relationship("Device", back_populates="user_interactions")
     │        │
     │        │        # Kalman Filter Fusion Table
     │        │        class KalmanFilterFusionData(Base):
     │        │            __tablename__ = "kalman_filter_fusion"
     │        │
     │        │            FusionID = Column(Integer, primary_key=True)
     │        │            SensorID = Column(Integer, ForeignKey("kalmanFilterFusionData.SensorID"), nullable=False)
     │        │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │        │            FusedValue = Column(Float, nullable=False)
     │        │
     │        │
     │        │            sensor = relationship("Sensor", back_populates="kalmanFilterFusionData"
     │        │
     │        │        # Weighted Average Fusion Table
     │        │        class WeightedAverageFusionData(Base):
     │        │            __tablename__ = "weighted_average_fusion"
     │        │
     │        │            FusionID = Column(Integer, primary_key=True)
     │        │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
     │        │            SensorType = Column(String(50))  # Optional
     │        │            Timestamp = Column(DateTime, default=datetime.utcnow)
     │        │            FusedValue = Column(Float, nullable=False)
     │        │
     │        │            device = relationship("Device", back_populates="weighted_fusions")
     │        │
     │        │        # Actuators Table
     │        │        class Actuator(Base):
     │        │            __tablename__ = "actuators"
     │        │
     │        │            ActuatorID = Column(Integer, primary_key=True)
     │        │            ActuatorName = Column(String(50), nullable=False, unique=True)
     │        │            Status = Column(String(20), nullable=False)  # e.g., "On", "Off"
     │        │            LastUpdated = Column(DateTime, default=datetime.utcnow)
     │        │            UserID = Column(Integer)  # Refers to the user who last updated it
     │        │
     │        │            def __repr__(self):
     │        │                return f"<Actuator(Name={self.ActuatorName}, Status={self.Status})>"
     │        │
     │        │        # Create all tables
     │        │        Base.metadata.create_all(engine)
     │        │        ↑↑↑ END OF FILE ↑↑↑
     │
     │        │   ├── indexprev.html
     │        │        ↓↓↓ FILE CONTENT ↓↓↓
     │        │        {% extends "base.html" %}
     │        │
     │        │        {% block content %}
     │        │        <div class="container">
     │        │            <h1>Welcome to the AI driven Greenhouse</h1>
     │        │            <p>Monitor and control your greenhouse environment remotely.</p>
     │        │        </div>
     │        │
     │        │        <div class="container">
     │        │            <h1>Surveillance</h1>
     │        │            <p>Two cameras for monitoring.</p>
     │        │        </div>
     │        │
     │        │        <div class="container">
     │        │            <img id="camera-stream" src="http://192.168.1.24:81/stream" width="400" height="400" alt="ESP32-CAM Stream" onerror="this.onerror=null; this.src='static/no-signal.jpg';">
     │        │        </div>
     │        │
     │        │        {% endblock %}
     │        │        ↑↑↑ END OF FILE ↑↑↑
     │
     │        │   ├── network.py
     │        │        ↓↓↓ FILE CONTENT ↓↓↓
     │        │        from flask import request, jsonify
     │        │        from database_setup import SessionLocal, SensorData, Device,UserInteraction
     │        │        from datetime import datetime
     │        │
     │        │        # Device (Microcontrollers) authentication credentials for sending sensor data to the server
     │        │        credentials = {
     │        │            "esp_Temp_humid_1": "esp_password",
     │        │            "esp_Soil_moisture_1": "esp_password"
     │        │        }
     │        │
     │        │        def action_based_on_sensor(DeviceName, temperature=0, humidity=0, soil_moisture=0):
     │        │            session = SessionLocal()
     │        │            try:
     │        │                if DeviceName == "esp_Temp_humid_1" and temperature > 30:
     │        │                    session.add(UserInteraction(DeviceID=11, UserID=5000, Action="blink_led", Timestamp=datetime.utcnow()))
     │        │                    session.commit()
     │        │                    return "blink_led"
     │        │
     │        │                elif DeviceName == "esp_Soil_moisture_1" and soil_moisture > 30:
     │        │                    session.add(UserInteraction(DeviceID=12, UserID=5000, Action="blink_led", Timestamp=datetime.utcnow()))
     │        │                    session.commit()
     │        │                    return "blink_led"
     │        │
     │        │                return "no_action"
     │        │
     │        │            finally:
     │        │                session.close()
     │        │
     │        │
     │        │
     │        │        def store_sensor_data(device_id, DeviceName, temperature=None, humidity=None, soil_moisture=None):
     │        │            session = SessionLocal()
     │        │
     │        │            # Ensure device exists in the database
     │        │            device = session.query(Device).filter_by(DeviceID=device_id).first()
     │        │            if not device:
     │        │                device = Device(DeviceID=device_id, DeviceName=DeviceName, Type="ESP32", Location="Unknown", Status="Active")
     │        │                session.add(device)
     │        │                session.commit()
     │        │                session.refresh(device)  # Ensure we have the latest DeviceID
     │        │
     │        │            # Store sensor readings for the specific device ID received from ESP
     │        │            if temperature is not None and device_id in {1, 2, 3}:
     │        │                session.add(SensorData(DeviceID=device_id, SensorType="temperature", Value=temperature, Timestamp=datetime.utcnow()))
     │        │
     │        │            if humidity is not None and device_id in {4, 5, 6}:
     │        │                session.add(SensorData(DeviceID=device_id, SensorType="humidity", Value=humidity, Timestamp=datetime.utcnow()))
     │        │
     │        │            if soil_moisture is not None and device_id in {7, 8}:
     │        │                session.add(SensorData(DeviceID=device_id, SensorType="soil_moisture", Value=soil_moisture, Timestamp=datetime.utcnow()))
     │        │
     │        │            session.commit()
     │        │            session.close()
     │        │
     │        │        def receive_sensor_data(request):
     │        │            # Get Authorization header
     │        │            auth = request.authorization
     │        │            if not auth or credentials.get(auth.username) != auth.password:
     │        │                return jsonify({"error": "Unauthorized"}), 401
     │        │
     │        │            try:
     │        │                data = request.json
     │        │                if not data:
     │        │                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
     │        │
     │        │                device_id = data.get('DeviceID')  # This is an integer
     │        │                DeviceName = data.get('DeviceName')  # This is a string
     │        │                temperature = data.get('temperature')
     │        │                humidity = data.get('humidity')
     │        │                soil_moisture = data.get('soil_moisture')  # Fixed key
     │        │
     │        │                if not device_id or not DeviceName:
     │        │                    return jsonify({"error": "Missing 'DeviceID' or 'DeviceName' in payload"}), 400
     │        │
     │        │                print(f"Received JSON payload: {data}")
     │        │
     │        │                # Store the data in the database
     │        │                store_sensor_data(device_id, DeviceName, temperature, humidity, soil_moisture)
     │        │
     │        │                # Determine action based on sensor data
     │        │                action = action_based_on_sensor(DeviceName, temperature, humidity, soil_moisture)
     │        │
     │        │                response = {"DeviceName": DeviceName, "action": action}
     │        │                return jsonify(response)
     │        │
     │        │            except Exception as e:
     │        │                print(f"Error processing request: {e}")
     │        │                return jsonify({"error": "Internal Server Error"}), 500
     │        │        ↑↑↑ END OF FILE ↑↑↑
     │
     │        │   ├── newer_network.py
     │        │        ↓↓↓ FILE CONTENT ↓↓↓
     │        │        from flask import request, jsonify
     │        │        import time
     │        │        from sqlalchemy import desc
     │        │        from datetime import datetime
     │        │        from sqlalchemy.orm import Session
     │        │        from database_setup import (
     │        │            SessionLocal, SensorData, Sensor, Device, UserInteraction,
     │        │            Actuator, WeightedAverageFusionData, KalmanFilterFusionData
     │        │        )
     │        │        from weightedAverage import process_weighted_fusion
     │        │
     │        │        # Authentication credentials for devices
     │        │        credentials = {
     │        │            "Ventilation_System_ESP": "password",
     │        │            "Irrigation_System_ESP": "password",
     │        │            "web_control": "web_password"
     │        │        }
     │        │
     │        │        # Constants
     │        │        DEFAULT_USER_ID = 5000  # Server user
     │        │        TEMP_THRESHOLD = 30
     │        │        HUM_THRESHOLD = 40
     │        │        SOIL_MOISTURE_THRESHOLD = 30
     │        │
     │        │        TEMP_SENSOR_IDS = [2099, 2092, 3093]
     │        │        HUM_SENSOR_IDS = [2091, 2034, 3027]
     │        │        WEIGHTS = [0.5, 0.3, 0.2]
     │        │
     │        │        # Actuator Names
     │        │        INTAKE_SHUTTER = "intake_shutter"
     │        │        WATER_PUMP = "water_pump"
     │        │        VENTILATION_FAN = "ventilation_fan"
     │        │
     │        │        # Device IDs
     │        │        Ventilation_System_ESP_ID = 2000
     │        │        Irrigation_System_ESP_ID = 3000
     │        │
     │        │        soil_sensor_1id = 2005
     │        │        soil_sensor_2id = 3002
     │        │
     │        │
     │        │        def get_fused_values_by_sensors(session: Session, *sensor_ids: int):
     │        │            fused_values = {}
     │        │
     │        │            if not sensor_ids:
     │        │                return fused_values  # No IDs provided → return empty
     │        │
     │        │            for sensor_id in sensor_ids:
     │        │                if sensor_id is None:
     │        │                    continue
     │        │                fusion = (
     │        │                    session.query(KalmanFilterFusionData)
     │        │                    .filter_by(SensorID=sensor_id)
     │        │                    .order_by(desc(KalmanFilterFusionData.Timestamp))
     │        │                    .first()
     │        │                )
     │        │                if fusion:
     │        │                    fused_values[sensor_id] = fusion.FusedValue
     │        │
     │        │            return fused_values
     │        │
     │        │
     │        │        def log_user_action(session, device_id, action, user_id, actuator_id):
     │        │            session.add(UserInteraction(
     │        │                DeviceID=device_id,
     │        │                Action=action,
     │        │                UserID=user_id,
     │        │                ActuatorID=actuator_id,
     │        │                Timestamp=datetime.utcnow()
     │        │            ))
     │        │
     │        │
     │        │        def control_actuator(session, actuator_name, status, user_id):
     │        │            actuator = session.query(Actuator).filter_by(ActuatorName=actuator_name).first()
     │        │            if not actuator:
     │        │                actuator = Actuator(
     │        │                    ActuatorName=actuator_name,
     │        │                    Status=status,
     │        │                    LastUpdated=datetime.utcnow(),
     │        │                    UserID=user_id
     │        │                )
     │        │                session.add(actuator)
     │        │            else:
     │        │                if actuator.Status != status:
     │        │                    actuator.Status = status
     │        │                    actuator.LastUpdated = datetime.utcnow()
     │        │                    actuator.UserID = user_id
     │        │                    log_user_action(
     │        │                        session,
     │        │                        device_id=actuator.ActuatorID,
     │        │                        action=f"{actuator_name}_{status.lower()}",
     │        │                        user_id=user_id,
     │        │                        actuator_id=actuator.ActuatorID
     │        │                    )
     │        │            session.commit()
     │        │            return actuator
     │        │
     │        │
     │        │        def get_latest_fused_temperature_humidity(session):
     │        │            latest_temp = session.query(WeightedAverageFusionData).filter_by(
     │        │                SensorType="temperature").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
     │        │            latest_hum = session.query(WeightedAverageFusionData).filter_by(
     │        │                SensorType="humidity").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
     │        │
     │        │            return {
     │        │                "temperature": latest_temp.FusedValue if latest_temp else None,
     │        │                "humidity": latest_hum.FusedValue if latest_hum else None
     │        │            }
     │        │
     │        │
     │        │        def action_based_on_sensor(user_id=DEFAULT_USER_ID):
     │        │            with SessionLocal() as session:
     │        │                result = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
     │        │                soil1 = result.get(soil_sensor_1id)
     │        │                soil2 = result.get(soil_sensor_2id)
     │        │
     │        │                soil_moisture = None
     │        │                if soil1 is not None and soil2 is not None:
     │        │                    average = (soil1 + soil2) / 2
     │        │                    if 0 <= average <= 100:
     │        │                        soil_moisture = average
     │        │                elif soil1 is not None:
     │        │                    if 0 <= soil1 <= 100:
     │        │                        soil_moisture = soil1
     │        │                elif soil2 is not None:
     │        │                    if 0 <= soil2 <= 100:
     │        │                        soil_moisture = soil2
     │        │                # Else → soil_moisture stays None
     │        │
     │        │                temperature=process_weighted_fusion(sensor_ids=TEMP_SENSOR_IDS, weights=WEIGHTS, sensor_type="Temperature")
     │        │
     │        │                # Call for humidity
     │        │                humidity=process_weighted_fusion(sensor_ids=HUM_SENSOR_IDS, weights=WEIGHTS, sensor_type="Humidity")
     │        │
     │        │                actions = []
     │        │
     │        │                try:
     │        │                    if temperature is not None and humidity is not None:
     │        │                        if temperature > TEMP_THRESHOLD or humidity > HUM_THRESHOLD:
     │        │                            control_actuator(session, VENTILATION_FAN, "on", user_id)
     │        │                            control_actuator(session, INTAKE_SHUTTER, "on", user_id)
     │        │                            actions.append("Ventilation_ON")
     │        │                        elif temperature < TEMP_THRESHOLD and humidity < HUM_THRESHOLD:
     │        │                            control_actuator(session, VENTILATION_FAN, "off", user_id)
     │        │                            control_actuator(session, INTAKE_SHUTTER, "off", user_id)
     │        │                            actions.append("Ventilation_OFF")
     │        │
     │        │                    if soil_moisture is not None:
     │        │                        if soil_moisture < SOIL_MOISTURE_THRESHOLD:
     │        │                            control_actuator(session, WATER_PUMP, "on", user_id)
     │        │                            actions.append("Irrigation_ON")
     │        │                        else:
     │        │                            control_actuator(session, WATER_PUMP, "off", user_id)
     │        │                            actions.append("Irrigation_OFF")
     │        │
     │        │                    session.commit()
     │        │                    return ", ".join(actions) if actions else "none"
     │        │                except Exception as e:
     │        │                    session.rollback()
     │        │                    print(f"[ERROR] Failed to perform action: {e}")
     │        │                    return "error"
     │        │
     │        │
     │        │
     │        │        def get_or_create_device(session, device_id, device_name):
     │        │            device = session.query(Device).filter_by(DeviceID=device_id).first()
     │        │            if not device:
     │        │                device = Device(DeviceID=device_id, DeviceName=device_name, Location="Unknown", Status="Active")
     │        │                session.add(device)
     │        │                session.commit()
     │        │                session.refresh(device)
     │        │            return device
     │        │
     │        │
     │        │        def get_or_create_sensor(session,sensor_id, device_id, sensor_type):
     │        │            sensor = session.query(Sensor).filter_by(SensorID=sensor_id, SensorType=sensor_type).first()
     │        │            if not sensor:
     │        │                sensor = Sensor(SensorID=sensor_id, DeviceID=device_id, SensorType=sensor_type, Location="Unknown", Status="Active")
     │        │                session.add(sensor)
     │        │                session.commit()
     │        │                session.refresh(sensor)
     │        │            return sensor
     │        │
     │        │
     │        │        def store_sensor_value(session, sensor, value):
     │        │            session.add(SensorData(SensorID=sensor.SensorID, Value=value, Timestamp=datetime.utcnow()))
     │        │
     │        │
     │        │        def store_sensor_data(device_id, device_name,sensor_id,
     │        │                              temperature=None, filtered_temperature=None,
     │        │                              humidity=None, filtered_humidity=None,
     │        │                              soil_moisture=None, filtered_soil_moisture=None):
     │        │            with SessionLocal() as session:
     │        │                try:
     │        │                    get_or_create_device(session, device_id, device_name)
     │        │
     │        │                    if temperature is not None:
     │        │                        sensor = get_or_create_sensor(session, device_id, "temperature")
     │        │                        store_sensor_value(session, sensor, temperature)
     │        │
     │        │                    if filtered_temperature is not None:
     │        │                        sensor = get_or_create_sensor(session, device_id, "temperature_filtered")
     │        │                        store_sensor_value(session, sensor, filtered_temperature)
     │        │
     │        │                    if humidity is not None:
     │        │                        sensor = get_or_create_sensor(session, device_id, "humidity")
     │        │                        store_sensor_value(session, sensor, humidity)
     │        │
     │        │                    if filtered_humidity is not None:
     │        │                        sensor = get_or_create_sensor(session, device_id, "humidity_filtered")
     │        │                        store_sensor_value(session, sensor, filtered_humidity)
     │        │
     │        │                    if soil_moisture is not None:
     │        │                        sensor = get_or_create_sensor(session, device_id, "soil_moisture")
     │        │                        store_sensor_value(session, sensor, soil_moisture)
     │        │
     │        │                    if filtered_soil_moisture is not None:
     │        │                        sensor = get_or_create_sensor(session, device_id, "soil_moisture_filtered")
     │        │                        store_sensor_value(session, sensor, filtered_soil_moisture)
     │        │
     │        │                    session.commit()
     │        │                except Exception as e:
     │        │                    session.rollback()
     │        │                    print(f"[ERROR] Failed to store sensor data: {e}")
     │        │
     │        │
     │        │        def receive_sensor_data(request):
     │        │            auth = request.authorization
     │        │            if not auth or credentials.get(auth.username) != auth.password:
     │        │                return jsonify({"error": "Unauthorized"}), 401
     │        │
     │        │            try:
     │        │                data = request.get_json()
     │        │                if not data:
     │        │                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
     │        │
     │        │                device_id = data.get('DeviceID')
     │        │                device_name = data.get('DeviceName')
     │        │                sensor_id = data.get('SensorID')
     │        │                if not device_id or not device_name:
     │        │                    return jsonify({"error": "Missing DeviceID or DeviceName"}), 400
     │        │
     │        │                temperature = data.get('temperature')
     │        │                filtered_temperature = data.get('filtered_temperature')
     │        │                humidity = data.get('humidity')
     │        │                filtered_humidity = data.get('filtered_humidity')
     │        │                soil_moisture = data.get('soil_moisture')
     │        │                filtered_soil_moisture = data.get('filtered_soil_moisture')
     │        │
     │        │                store_sensor_data(device_id, device_name,sensor_id,
     │        │                                  temperature, filtered_temperature,
     │        │                                  humidity, filtered_humidity,
     │        │                                  soil_moisture, filtered_soil_moisture)
     │        │
     │        │                print(f"[INFO] Received data from DeviceID: {device_id}, SensorID: {sensor_id}")
     │        │                # Optional: wait for fusion update to complete if it's not sync
     │        │                time.sleep(5)
     │        │
     │        │                action_result = action_based_on_sensor()
     │        │
     │        │                with SessionLocal() as session:
     │        │                    latest = get_latest_fused_temperature_humidity(session)
     │        │                    soil_data = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
     │        │                    avg_soil = None
     │        │                    if soil_data:
     │        │                        values = list(soil_data.values())
     │        │                        avg_soil = sum(values) / len(values) if values else None
     │        │
     │        │                return jsonify({
     │        │                    "status": "success",
     │        │                    "action": action_result,
     │        │                    "temperature": latest["temperature"],
     │        │                    "humidity": latest["humidity"],
     │        │                    "soil_moisture": avg_soil
     │        │                }), 200
     │        │
     │        │            except Exception as e:
     │        │                print(f"[ERROR] Failed to receive/process sensor data: {e}")
     │        │                return jsonify({"error": "Internal Server Error"}), 500
     │        │        ↑↑↑ END OF FILE ↑↑↑
     │
     │        │   └── old_network.py
     │        │        ↓↓↓ FILE CONTENT ↓↓↓
     │        │        from flask import request, jsonify
     │        │        from webdevelopment.database_setup import SessionLocal, SensorData, Device, UserInteraction, Actuator, WeightedAverageFusionData
     │        │        from datetime import datetime
     │        │        from webdevelopment.weightedAverage import process_weighted_fusion
     │        │
     │        │        # Authentication credentials for devices
     │        │        credentials = {
     │        │            "Ventilation_System_ESP ": "password",
     │        │            "Irrigation_System_ESP": "password"
     │        │        }
     │        │
     │        │        # Constants
     │        │        DEFAULT_USER_ID = 5000  # Server user
     │        │        TEMP_THRESHOLD = 30
     │        │        HUM_THRESHOLD = 40
     │        │        SOIL_MOISTURE_THRESHOLD = 30
     │        │
     │        │        # Actuator Names
     │        │        INTAKE_SHUTTER = "intake_shutter"
     │        │        WATER_PUMP = "water_pump"
     │        │        VENTILATION_FAN = "ventilation_fan"
     │        │
     │        │        # Device Names
     │        │        Ventilation_System_ESP = 1111
     │        │        Irrigation_System_ESP = 2222
     │        │
     │        │
     │        │        def log_user_action(session, device_id, action, user_id):
     │        │            interaction = UserInteraction(
     │        │                DeviceID=device_id,
     │        │                Action=action,
     │        │                UserID=user_id,
     │        │                Timestamp=datetime.utcnow()
     │        │            )
     │        │            session.add(interaction)
     │        │
     │        │
     │        │        def control_actuator(session, actuator_name, status, user_id):
     │        │            actuator = session.query(Actuator).filter_by(ActuatorName=actuator_name).first()
     │        │            if not actuator:
     │        │                actuator = Actuator(ActuatorName=actuator_name, Status=status, LastUpdated=datetime.utcnow(), UserID=user_id)
     │        │                session.add(actuator)
     │        │            else:
     │        │                actuator.Status = status
     │        │                actuator.LastUpdated = datetime.utcnow()
     │        │                actuator.UserID = user_id
     │        │
     │        │            # Log who triggered this actuator
     │        │            log_user_action(session, device_id=actuator.ActuatorID, action=f"{actuator_name}_{status.lower()}", user_id=user_id)
     │        │            return True
     │        │
     │        │
     │        │        def action_based_on_sensor(DeviceName, temperature=0, humidity=0, soil_moisture=0, user_id=DEFAULT_USER_ID):
     │        │            session = SessionLocal()
     │        │
     │        │            try:
     │        │                if  temperature > TEMP_THRESHOLD or humidity > HUM_THRESHOLD:
     │        │
     │        │                    control_actuator(session, VENTILATION_FAN, "On", user_id)
     │        │                    control_actuator(session, INTAKE_SHUTTER, "On", user_id)
     │        │                    log_user_action(session, Ventilation_System_ESP,"On", user_id)
     │        │                    log_user_action(session, INTAKE_SHUTTER,"On", user_id)
     │        │                    action_taken = "VENTILATION_System_on"
     │        │
     │        │
     │        │                elif soil_moisture < SOIL_MOISTURE_THRESHOLD:
     │        │                    control_actuator(session, WATER_PUMP, "On", user_id)
     │        │                    log_user_action(session, Irrigation_System_ESP, "On", user_id)
     │        │                    action_taken = "Irrigation_System_on"
     │        │
     │        │                session.commit()
     │        │                return action_taken
     │        │
     │        │            except Exception as e:
     │        │                session.rollback()
     │        │                print(f"[ERROR] Failed to perform action: {e}")
     │        │                return "error"
     │        │
     │        │            finally:
     │        │                session.close()
     │        │
     │        │
     │        │        def store_sensor_data(device_id, DeviceName, temperature=None, filtered_temperature=None, humidity=None, filtered_humidity=None, soil_moisture=None, filtered_soil_moisture= None):
     │        │            session = SessionLocal()
     │        │
     │        │            try:
     │        │                # Ensure device exists
     │        │                device = session.query(Device).filter_by(DeviceID=device_id).first()
     │        │                if not device:
     │        │                    device = Device(DeviceID=device_id, DeviceName=DeviceName, Type="ESP32", Location="Unknown", Status="Active")
     │        │                    session.add(device)
     │        │                    session.commit()
     │        │                    session.refresh(device)
     │        │
     │        │                # Store relevant sensor data
     │        │                if temperature is not None and device_id in {1, 2, 3, 4}:
     │        │                    session.add(SensorData(DeviceID=device_id, SensorType="temperature", Value=temperature, Timestamp=datetime.utcnow()))
     │        │                if filtered_temperature is not None and device_id in {1, 2, 3, 4}:
     │        │                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
     │        │                if humidity is not None and device_id in {5, 6, 7, 8}:
     │        │                    session.add(SensorData(DeviceID=device_id, SensorType="humidity", Value=humidity, Timestamp=datetime.utcnow()))
     │        │                if filtered_humidity is not None and device_id in {5, 6, 7, 8}:
     │        │                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
     │        │                if soil_moisture is not None and device_id in {9,10}:
     │        │                    session.add(SensorData(DeviceID=device_id, SensorType="soil_moisture", Value=soil_moisture, Timestamp=datetime.utcnow()))
     │        │                if filtered_soil_moisture is not None and device_id in {9,10}:
     │        │                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
     │        │                session.commit()
     │        │
     │        │            except Exception as e:
     │        │                session.rollback()
     │        │                print(f"[ERROR] Failed to store sensor data: {e}")
     │        │            finally:
     │        │                session.close()
     │        │
     │        │
     │        │        def receive_sensor_data(request):
     │        │            # Basic HTTP Auth
     │        │            auth = request.authorization
     │        │            if not auth or credentials.get(auth.username) != auth.password:
     │        │                return jsonify({"error": "Unauthorized"}), 401
     │        │
     │        │            try:
     │        │                data = request.json
     │        │                if not data:
     │        │                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
     │        │
     │        │                DeviceID = data.get('DeviceID')
     │        │                DeviceName = data.get('DeviceName')
     │        │                temperature = data.get('temperature')
     │        │                filtered_temperature = data.get('filtered_temperature')
     │        │                humidity = data.get('humidity')
     │        │                filtered_humidity = data.get('filtered_humidity')
     │        │                soil_moisture = data.get('soil_moisture')
     │        │                filtered_soil_moisture = data.get('filtered_soil_moisture')
     │        │
     │        │                if not DeviceID:
     │        │                    return jsonify({"error": "Missing 'DeviceID' in payload"}), 400
     │        │                if not DeviceName:
     │        │                    return jsonify({"error": "Missing 'DeviceName' in payload"}), 400
     │        │
     │        │                print(f"Received payload: from {DeviceName}")
     │        │
     │        │                store_sensor_data(DeviceID, DeviceName, temperature, humidity, soil_moisture)
     │        │
     │        │                process_weighted_fusion()
     │        │
     │        │
     │        │                action = action_based_on_sensor(DeviceName, temperature, humidity, soil_moisture)
     │        │
     │        │                if action == "VENTILATION_System_on":
     │        │                    return jsonify({"DeviceName": "Ventilation_System_ESP", "action": action})
     │        │
     │        │                elif action == "Irrigation_System_on":
     │        │                    return jsonify({"DeviceName": "Irrigation_System_ESP", "action": action})
     │        │
     │        │                elif action == "error":
     │        │                    return jsonify({"error": "Failed to perform action"}), 500
     │        │
     │        │                else:
     │        │                    return jsonify({"DeviceName": DeviceName, "action": "No action taken"}), 200
     │        │
     │        │
     │        │            except Exception as e:
     │        │                print(f"[ERROR] Exception in receive_sensor_data: {e}")
     │        │                return jsonify({"error": "Internal Server Error"}), 500
     │        │        ↑↑↑ END OF FILE ↑↑↑
     │
     │        ├── webserver.code-workspace
     │        └── weightedAverage.py
     │             ↓↓↓ FILE CONTENT ↓↓↓
     │             from datetime import datetime, timedelta
     │             from sqlalchemy.orm import Session
     │             from database_setup import KalmanFilterFusionData, WeightedAverageFusionData, SessionLocal
     │
     │
     │             def weighted_average_fusion(values, weights):
     │                 """Perform weighted average of given values with weights."""
     │                 if len(values) != len(weights):
     │                     raise ValueError("Length of values and weights must match.")
     │                 return sum(v * w for v, w in zip(values, weights))
     │
     │
     │             def fetch_recent_sensor_data(session, sensor_ids, window_seconds):
     │                 """Fetch the most recent Kalman-filtered readings for given sensor_ids within time window."""
     │                 now = datetime.utcnow()
     │                 window_start = now - timedelta(seconds=window_seconds)
     │                 latest_data = {}
     │
     │                 for sensor_id in sensor_ids:
     │                     entry = session.query(KalmanFilterFusionData)\
     │                         .filter(KalmanFilterFusionData.SensorID == sensor_id)\
     │                         .filter(KalmanFilterFusionData.Timestamp >= window_start)\
     │                         .order_by(KalmanFilterFusionData.Timestamp.desc())\
     │                         .first()
     │                     if entry:
     │                         latest_data[sensor_id] = entry.FusedValue
     │
     │                 return latest_data
     │
     │
     │             def process_weighted_fusion(sensor_ids, weights, sensor_type, fusion_window_seconds=60):
     │                 """
     │                 Run weighted average fusion on a given set of sensor IDs and weights.
     │
     │                 Args:
     │                     sensor_ids (list): List of sensor IDs.
     │                     weights (list): Corresponding weights (same length as sensor_ids).
     │                     sensor_type (str): Sensor type label (e.g., "Temperature", "Humidity").
     │                     fusion_window_seconds (int): Time window in seconds to consider valid readings.
     │                 """
     │                 session: Session = SessionLocal()
     │                 try:
     │                     sensor_data = fetch_recent_sensor_data(session, sensor_ids, fusion_window_seconds)
     │
     │                     if not sensor_data:
     │                         print(f"[{sensor_type.upper()}] No recent readings available.")
     │                         return
     │
     │                     available_ids = list(sensor_data.keys())
     │                     available_values = [sensor_data[sid] for sid in available_ids]
     │
     │                     # Adjust weights to match available sensors
     │                     weight_map = {sid: w for sid, w in zip(sensor_ids, weights)}
     │                     available_weights = [weight_map[sid] for sid in available_ids]
     │
     │
     │                     # Normalize weights
     │                     total_weight = sum(available_weights)
     │                     normalized_weights = [w / total_weight for w in available_weights]
     │
     │                     fused_value = weighted_average_fusion(available_values, normalized_weights)
     │
     │                     session.add(WeightedAverageFusionData(
     │                         SensorType=sensor_type,
     │                         Timestamp=datetime.utcnow(),
     │                         FusedValue=fused_value
     │                     ))
     │                     session.commit()
     │                     print(f"[{sensor_type.upper()}] Fused value: {fused_value:.2f} from {len(available_values)} sensors.")
     │                 except Exception as e:
     │                     session.rollback()
     │                     print(f"[ERROR] Fusion failed for {sensor_type}: {e}")
     │                 finally:
     │                     session.close()
     │             ↑↑↑ END OF FILE ↑↑↑
     │
     │        PS D:\Documents\My AAST\Term 9\Graduation Project\Greenhouse\webdevelopment>
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── indexprev.html
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        {% extends "base.html" %}
     │
     │        {% block content %}
     │        <div class="container">
     │            <h1>Welcome to the AI driven Greenhouse</h1>
     │            <p>Monitor and control your greenhouse environment remotely.</p>
     │        </div>
     │
     │        <div class="container">
     │            <h1>Surveillance</h1>
     │            <p>Two cameras for monitoring.</p>
     │        </div>
     │
     │        <div class="container">
     │            <img id="camera-stream" src="http://192.168.1.24:81/stream" width="400" height="400" alt="ESP32-CAM Stream" onerror="this.onerror=null; this.src='static/no-signal.jpg';">
     │        </div>
     │
     │        {% endblock %}
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── network.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from flask import request, jsonify
     │        from database_setup import SessionLocal, SensorData, Device,UserInteraction
     │        from datetime import datetime
     │
     │        # Device (Microcontrollers) authentication credentials for sending sensor data to the server
     │        credentials = {
     │            "esp_Temp_humid_1": "esp_password",
     │            "esp_Soil_moisture_1": "esp_password"
     │        }
     │
     │        def action_based_on_sensor(DeviceName, temperature=0, humidity=0, soil_moisture=0):
     │            session = SessionLocal()
     │            try:
     │                if DeviceName == "esp_Temp_humid_1" and temperature > 30:
     │                    session.add(UserInteraction(DeviceID=11, UserID=5000, Action="blink_led", Timestamp=datetime.utcnow()))
     │                    session.commit()
     │                    return "blink_led"
     │
     │                elif DeviceName == "esp_Soil_moisture_1" and soil_moisture > 30:
     │                    session.add(UserInteraction(DeviceID=12, UserID=5000, Action="blink_led", Timestamp=datetime.utcnow()))
     │                    session.commit()
     │                    return "blink_led"
     │
     │                return "no_action"
     │
     │            finally:
     │                session.close()
     │
     │
     │
     │        def store_sensor_data(device_id, DeviceName, temperature=None, humidity=None, soil_moisture=None):
     │            session = SessionLocal()
     │
     │            # Ensure device exists in the database
     │            device = session.query(Device).filter_by(DeviceID=device_id).first()
     │            if not device:
     │                device = Device(DeviceID=device_id, DeviceName=DeviceName, Type="ESP32", Location="Unknown", Status="Active")
     │                session.add(device)
     │                session.commit()
     │                session.refresh(device)  # Ensure we have the latest DeviceID
     │
     │            # Store sensor readings for the specific device ID received from ESP
     │            if temperature is not None and device_id in {1, 2, 3}:
     │                session.add(SensorData(DeviceID=device_id, SensorType="temperature", Value=temperature, Timestamp=datetime.utcnow()))
     │
     │            if humidity is not None and device_id in {4, 5, 6}:
     │                session.add(SensorData(DeviceID=device_id, SensorType="humidity", Value=humidity, Timestamp=datetime.utcnow()))
     │
     │            if soil_moisture is not None and device_id in {7, 8}:
     │                session.add(SensorData(DeviceID=device_id, SensorType="soil_moisture", Value=soil_moisture, Timestamp=datetime.utcnow()))
     │
     │            session.commit()
     │            session.close()
     │
     │        def receive_sensor_data(request):
     │            # Get Authorization header
     │            auth = request.authorization
     │            if not auth or credentials.get(auth.username) != auth.password:
     │                return jsonify({"error": "Unauthorized"}), 401
     │
     │            try:
     │                data = request.json
     │                if not data:
     │                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
     │
     │                device_id = data.get('DeviceID')  # This is an integer
     │                DeviceName = data.get('DeviceName')  # This is a string
     │                temperature = data.get('temperature')
     │                humidity = data.get('humidity')
     │                soil_moisture = data.get('soil_moisture')  # Fixed key
     │
     │                if not device_id or not DeviceName:
     │                    return jsonify({"error": "Missing 'DeviceID' or 'DeviceName' in payload"}), 400
     │
     │                print(f"Received JSON payload: {data}")
     │
     │                # Store the data in the database
     │                store_sensor_data(device_id, DeviceName, temperature, humidity, soil_moisture)
     │
     │                # Determine action based on sensor data
     │                action = action_based_on_sensor(DeviceName, temperature, humidity, soil_moisture)
     │
     │                response = {"DeviceName": DeviceName, "action": action}
     │                return jsonify(response)
     │
     │            except Exception as e:
     │                print(f"Error processing request: {e}")
     │                return jsonify({"error": "Internal Server Error"}), 500
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   ├── newer_network.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from flask import request, jsonify
     │        import time
     │        from sqlalchemy import desc
     │        from datetime import datetime
     │        from sqlalchemy.orm import Session
     │        from database_setup import (
     │            SessionLocal, SensorData, Sensor, Device, UserInteraction,
     │            Actuator, WeightedAverageFusionData, KalmanFilterFusionData
     │        )
     │        from weightedAverage import process_weighted_fusion
     │
     │        # Authentication credentials for devices
     │        credentials = {
     │            "Ventilation_System_ESP": "password",
     │            "Irrigation_System_ESP": "password",
     │            "web_control": "web_password"
     │        }
     │
     │        # Constants
     │        DEFAULT_USER_ID = 5000  # Server user
     │        TEMP_THRESHOLD = 30
     │        HUM_THRESHOLD = 40
     │        SOIL_MOISTURE_THRESHOLD = 30
     │
     │        TEMP_SENSOR_IDS = [2099, 2092, 3093]
     │        HUM_SENSOR_IDS = [2091, 2034, 3027]
     │        WEIGHTS = [0.5, 0.3, 0.2]
     │
     │        # Actuator Names
     │        INTAKE_SHUTTER = "intake_shutter"
     │        WATER_PUMP = "water_pump"
     │        VENTILATION_FAN = "ventilation_fan"
     │
     │        # Device IDs
     │        Ventilation_System_ESP_ID = 2000
     │        Irrigation_System_ESP_ID = 3000
     │
     │        soil_sensor_1id = 2005
     │        soil_sensor_2id = 3002
     │
     │
     │        def get_fused_values_by_sensors(session: Session, *sensor_ids: int):
     │            fused_values = {}
     │
     │            if not sensor_ids:
     │                return fused_values  # No IDs provided → return empty
     │
     │            for sensor_id in sensor_ids:
     │                if sensor_id is None:
     │                    continue
     │                fusion = (
     │                    session.query(KalmanFilterFusionData)
     │                    .filter_by(SensorID=sensor_id)
     │                    .order_by(desc(KalmanFilterFusionData.Timestamp))
     │                    .first()
     │                )
     │                if fusion:
     │                    fused_values[sensor_id] = fusion.FusedValue
     │
     │            return fused_values
     │
     │
     │        def log_user_action(session, device_id, action, user_id, actuator_id):
     │            session.add(UserInteraction(
     │                DeviceID=device_id,
     │                Action=action,
     │                UserID=user_id,
     │                ActuatorID=actuator_id,
     │                Timestamp=datetime.utcnow()
     │            ))
     │
     │
     │        def control_actuator(session, actuator_name, status, user_id):
     │            actuator = session.query(Actuator).filter_by(ActuatorName=actuator_name).first()
     │            if not actuator:
     │                actuator = Actuator(
     │                    ActuatorName=actuator_name,
     │                    Status=status,
     │                    LastUpdated=datetime.utcnow(),
     │                    UserID=user_id
     │                )
     │                session.add(actuator)
     │            else:
     │                if actuator.Status != status:
     │                    actuator.Status = status
     │                    actuator.LastUpdated = datetime.utcnow()
     │                    actuator.UserID = user_id
     │                    log_user_action(
     │                        session,
     │                        device_id=actuator.ActuatorID,
     │                        action=f"{actuator_name}_{status.lower()}",
     │                        user_id=user_id,
     │                        actuator_id=actuator.ActuatorID
     │                    )
     │            session.commit()
     │            return actuator
     │
     │
     │        def get_latest_fused_temperature_humidity(session):
     │            latest_temp = session.query(WeightedAverageFusionData).filter_by(
     │                SensorType="temperature").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
     │            latest_hum = session.query(WeightedAverageFusionData).filter_by(
     │                SensorType="humidity").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
     │
     │            return {
     │                "temperature": latest_temp.FusedValue if latest_temp else None,
     │                "humidity": latest_hum.FusedValue if latest_hum else None
     │            }
     │
     │
     │        def action_based_on_sensor(user_id=DEFAULT_USER_ID):
     │            with SessionLocal() as session:
     │                result = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
     │                soil1 = result.get(soil_sensor_1id)
     │                soil2 = result.get(soil_sensor_2id)
     │
     │                soil_moisture = None
     │                if soil1 is not None and soil2 is not None:
     │                    average = (soil1 + soil2) / 2
     │                    if 0 <= average <= 100:
     │                        soil_moisture = average
     │                elif soil1 is not None:
     │                    if 0 <= soil1 <= 100:
     │                        soil_moisture = soil1
     │                elif soil2 is not None:
     │                    if 0 <= soil2 <= 100:
     │                        soil_moisture = soil2
     │                # Else → soil_moisture stays None
     │
     │                temperature=process_weighted_fusion(sensor_ids=TEMP_SENSOR_IDS, weights=WEIGHTS, sensor_type="Temperature")
     │
     │                # Call for humidity
     │                humidity=process_weighted_fusion(sensor_ids=HUM_SENSOR_IDS, weights=WEIGHTS, sensor_type="Humidity")
     │
     │                actions = []
     │
     │                try:
     │                    if temperature is not None and humidity is not None:
     │                        if temperature > TEMP_THRESHOLD or humidity > HUM_THRESHOLD:
     │                            control_actuator(session, VENTILATION_FAN, "on", user_id)
     │                            control_actuator(session, INTAKE_SHUTTER, "on", user_id)
     │                            actions.append("Ventilation_ON")
     │                        elif temperature < TEMP_THRESHOLD and humidity < HUM_THRESHOLD:
     │                            control_actuator(session, VENTILATION_FAN, "off", user_id)
     │                            control_actuator(session, INTAKE_SHUTTER, "off", user_id)
     │                            actions.append("Ventilation_OFF")
     │
     │                    if soil_moisture is not None:
     │                        if soil_moisture < SOIL_MOISTURE_THRESHOLD:
     │                            control_actuator(session, WATER_PUMP, "on", user_id)
     │                            actions.append("Irrigation_ON")
     │                        else:
     │                            control_actuator(session, WATER_PUMP, "off", user_id)
     │                            actions.append("Irrigation_OFF")
     │
     │                    session.commit()
     │                    return ", ".join(actions) if actions else "none"
     │                except Exception as e:
     │                    session.rollback()
     │                    print(f"[ERROR] Failed to perform action: {e}")
     │                    return "error"
     │
     │
     │
     │        def get_or_create_device(session, device_id, device_name):
     │            device = session.query(Device).filter_by(DeviceID=device_id).first()
     │            if not device:
     │                device = Device(DeviceID=device_id, DeviceName=device_name, Location="Unknown", Status="Active")
     │                session.add(device)
     │                session.commit()
     │                session.refresh(device)
     │            return device
     │
     │
     │        def get_or_create_sensor(session,sensor_id, device_id, sensor_type):
     │            sensor = session.query(Sensor).filter_by(SensorID=sensor_id, SensorType=sensor_type).first()
     │            if not sensor:
     │                sensor = Sensor(SensorID=sensor_id, DeviceID=device_id, SensorType=sensor_type, Location="Unknown", Status="Active")
     │                session.add(sensor)
     │                session.commit()
     │                session.refresh(sensor)
     │            return sensor
     │
     │
     │        def store_sensor_value(session, sensor, value):
     │            session.add(SensorData(SensorID=sensor.SensorID, Value=value, Timestamp=datetime.utcnow()))
     │
     │
     │        def store_sensor_data(device_id, device_name,sensor_id,
     │                              temperature=None, filtered_temperature=None,
     │                              humidity=None, filtered_humidity=None,
     │                              soil_moisture=None, filtered_soil_moisture=None):
     │            with SessionLocal() as session:
     │                try:
     │                    get_or_create_device(session, device_id, device_name)
     │
     │                    if temperature is not None:
     │                        sensor = get_or_create_sensor(session, device_id, "temperature")
     │                        store_sensor_value(session, sensor, temperature)
     │
     │                    if filtered_temperature is not None:
     │                        sensor = get_or_create_sensor(session, device_id, "temperature_filtered")
     │                        store_sensor_value(session, sensor, filtered_temperature)
     │
     │                    if humidity is not None:
     │                        sensor = get_or_create_sensor(session, device_id, "humidity")
     │                        store_sensor_value(session, sensor, humidity)
     │
     │                    if filtered_humidity is not None:
     │                        sensor = get_or_create_sensor(session, device_id, "humidity_filtered")
     │                        store_sensor_value(session, sensor, filtered_humidity)
     │
     │                    if soil_moisture is not None:
     │                        sensor = get_or_create_sensor(session, device_id, "soil_moisture")
     │                        store_sensor_value(session, sensor, soil_moisture)
     │
     │                    if filtered_soil_moisture is not None:
     │                        sensor = get_or_create_sensor(session, device_id, "soil_moisture_filtered")
     │                        store_sensor_value(session, sensor, filtered_soil_moisture)
     │
     │                    session.commit()
     │                except Exception as e:
     │                    session.rollback()
     │                    print(f"[ERROR] Failed to store sensor data: {e}")
     │
     │
     │        def receive_sensor_data(request):
     │            auth = request.authorization
     │            if not auth or credentials.get(auth.username) != auth.password:
     │                return jsonify({"error": "Unauthorized"}), 401
     │
     │            try:
     │                data = request.get_json()
     │                if not data:
     │                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
     │
     │                device_id = data.get('DeviceID')
     │                device_name = data.get('DeviceName')
     │                sensor_id = data.get('SensorID')
     │                if not device_id or not device_name:
     │                    return jsonify({"error": "Missing DeviceID or DeviceName"}), 400
     │
     │                temperature = data.get('temperature')
     │                filtered_temperature = data.get('filtered_temperature')
     │                humidity = data.get('humidity')
     │                filtered_humidity = data.get('filtered_humidity')
     │                soil_moisture = data.get('soil_moisture')
     │                filtered_soil_moisture = data.get('filtered_soil_moisture')
     │
     │                store_sensor_data(device_id, device_name,sensor_id,
     │                                  temperature, filtered_temperature,
     │                                  humidity, filtered_humidity,
     │                                  soil_moisture, filtered_soil_moisture)
     │
     │                print(f"[INFO] Received data from DeviceID: {device_id}, SensorID: {sensor_id}")
     │                # Optional: wait for fusion update to complete if it's not sync
     │                time.sleep(5)
     │
     │                action_result = action_based_on_sensor()
     │
     │                with SessionLocal() as session:
     │                    latest = get_latest_fused_temperature_humidity(session)
     │                    soil_data = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
     │                    avg_soil = None
     │                    if soil_data:
     │                        values = list(soil_data.values())
     │                        avg_soil = sum(values) / len(values) if values else None
     │
     │                return jsonify({
     │                    "status": "success",
     │                    "action": action_result,
     │                    "temperature": latest["temperature"],
     │                    "humidity": latest["humidity"],
     │                    "soil_moisture": avg_soil
     │                }), 200
     │
     │            except Exception as e:
     │                print(f"[ERROR] Failed to receive/process sensor data: {e}")
     │                return jsonify({"error": "Internal Server Error"}), 500
     │        ↑↑↑ END OF FILE ↑↑↑
     
     │   └── old_network.py
     │        ↓↓↓ FILE CONTENT ↓↓↓
     │        from flask import request, jsonify
     │        from webdevelopment.database_setup import SessionLocal, SensorData, Device, UserInteraction, Actuator, WeightedAverageFusionData
     │        from datetime import datetime
     │        from webdevelopment.weightedAverage import process_weighted_fusion
     │
     │        # Authentication credentials for devices
     │        credentials = {
     │            "Ventilation_System_ESP ": "password",
     │            "Irrigation_System_ESP": "password"
     │        }
     │
     │        # Constants
     │        DEFAULT_USER_ID = 5000  # Server user
     │        TEMP_THRESHOLD = 30
     │        HUM_THRESHOLD = 40
     │        SOIL_MOISTURE_THRESHOLD = 30
     │
     │        # Actuator Names
     │        INTAKE_SHUTTER = "intake_shutter"
     │        WATER_PUMP = "water_pump"
     │        VENTILATION_FAN = "ventilation_fan"
     │
     │        # Device Names
     │        Ventilation_System_ESP = 1111
     │        Irrigation_System_ESP = 2222
     │
     │
     │        def log_user_action(session, device_id, action, user_id):
     │            interaction = UserInteraction(
     │                DeviceID=device_id,
     │                Action=action,
     │                UserID=user_id,
     │                Timestamp=datetime.utcnow()
     │            )
     │            session.add(interaction)
     │
     │
     │        def control_actuator(session, actuator_name, status, user_id):
     │            actuator = session.query(Actuator).filter_by(ActuatorName=actuator_name).first()
     │            if not actuator:
     │                actuator = Actuator(ActuatorName=actuator_name, Status=status, LastUpdated=datetime.utcnow(), UserID=user_id)
     │                session.add(actuator)
     │            else:
     │                actuator.Status = status
     │                actuator.LastUpdated = datetime.utcnow()
     │                actuator.UserID = user_id
     │
     │            # Log who triggered this actuator
     │            log_user_action(session, device_id=actuator.ActuatorID, action=f"{actuator_name}_{status.lower()}", user_id=user_id)
     │            return True
     │
     │
     │        def action_based_on_sensor(DeviceName, temperature=0, humidity=0, soil_moisture=0, user_id=DEFAULT_USER_ID):
     │            session = SessionLocal()
     │
     │            try:
     │                if  temperature > TEMP_THRESHOLD or humidity > HUM_THRESHOLD:
     │
     │                    control_actuator(session, VENTILATION_FAN, "On", user_id)
     │                    control_actuator(session, INTAKE_SHUTTER, "On", user_id)
     │                    log_user_action(session, Ventilation_System_ESP,"On", user_id)
     │                    log_user_action(session, INTAKE_SHUTTER,"On", user_id)
     │                    action_taken = "VENTILATION_System_on"
     │
     │
     │                elif soil_moisture < SOIL_MOISTURE_THRESHOLD:
     │                    control_actuator(session, WATER_PUMP, "On", user_id)
     │                    log_user_action(session, Irrigation_System_ESP, "On", user_id)
     │                    action_taken = "Irrigation_System_on"
     │
     │                session.commit()
     │                return action_taken
     │
     │            except Exception as e:
     │                session.rollback()
     │                print(f"[ERROR] Failed to perform action: {e}")
     │                return "error"
     │
     │            finally:
     │                session.close()
     │
     │
     │        def store_sensor_data(device_id, DeviceName, temperature=None, filtered_temperature=None, humidity=None, filtered_humidity=None, soil_moisture=None, filtered_soil_moisture= None):
     │            session = SessionLocal()
     │
     │            try:
     │                # Ensure device exists
     │                device = session.query(Device).filter_by(DeviceID=device_id).first()
     │                if not device:
     │                    device = Device(DeviceID=device_id, DeviceName=DeviceName, Type="ESP32", Location="Unknown", Status="Active")
     │                    session.add(device)
     │                    session.commit()
     │                    session.refresh(device)
     │
     │                # Store relevant sensor data
     │                if temperature is not None and device_id in {1, 2, 3, 4}:
     │                    session.add(SensorData(DeviceID=device_id, SensorType="temperature", Value=temperature, Timestamp=datetime.utcnow()))
     │                if filtered_temperature is not None and device_id in {1, 2, 3, 4}:
     │                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
     │                if humidity is not None and device_id in {5, 6, 7, 8}:
     │                    session.add(SensorData(DeviceID=device_id, SensorType="humidity", Value=humidity, Timestamp=datetime.utcnow()))
     │                if filtered_humidity is not None and device_id in {5, 6, 7, 8}:
     │                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
     │                if soil_moisture is not None and device_id in {9,10}:
     │                    session.add(SensorData(DeviceID=device_id, SensorType="soil_moisture", Value=soil_moisture, Timestamp=datetime.utcnow()))
     │                if filtered_soil_moisture is not None and device_id in {9,10}:
     │                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
     │                session.commit()
     │
     │            except Exception as e:
     │                session.rollback()
     │                print(f"[ERROR] Failed to store sensor data: {e}")
     │            finally:
     │                session.close()
     │
     │
     │        def receive_sensor_data(request):
     │            # Basic HTTP Auth
     │            auth = request.authorization
     │            if not auth or credentials.get(auth.username) != auth.password:
     │                return jsonify({"error": "Unauthorized"}), 401
     │
     │            try:
     │                data = request.json
     │                if not data:
     │                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
     │
     │                DeviceID = data.get('DeviceID')
     │                DeviceName = data.get('DeviceName')
     │                temperature = data.get('temperature')
     │                filtered_temperature = data.get('filtered_temperature')
     │                humidity = data.get('humidity')
     │                filtered_humidity = data.get('filtered_humidity')
     │                soil_moisture = data.get('soil_moisture')
     │                filtered_soil_moisture = data.get('filtered_soil_moisture')
     │
     │                if not DeviceID:
     │                    return jsonify({"error": "Missing 'DeviceID' in payload"}), 400
     │                if not DeviceName:
     │                    return jsonify({"error": "Missing 'DeviceName' in payload"}), 400
     │
     │                print(f"Received payload: from {DeviceName}")
     │
     │                store_sensor_data(DeviceID, DeviceName, temperature, humidity, soil_moisture)
     │
     │                process_weighted_fusion()
     │
     │
     │                action = action_based_on_sensor(DeviceName, temperature, humidity, soil_moisture)
     │
     │                if action == "VENTILATION_System_on":
     │                    return jsonify({"DeviceName": "Ventilation_System_ESP", "action": action})
     │
     │                elif action == "Irrigation_System_on":
     │                    return jsonify({"DeviceName": "Irrigation_System_ESP", "action": action})
     │
     │                elif action == "error":
     │                    return jsonify({"error": "Failed to perform action"}), 500
     │
     │                else:
     │                    return jsonify({"DeviceName": DeviceName, "action": "No action taken"}), 200
     │
     │
     │            except Exception as e:
     │                print(f"[ERROR] Exception in receive_sensor_data: {e}")
     │                return jsonify({"error": "Internal Server Error"}), 500
     │        ↑↑↑ END OF FILE ↑↑↑
     
     ├── webserver.code-workspace
     └── weightedAverage.py
          ↓↓↓ FILE CONTENT ↓↓↓
          from datetime import datetime, timedelta
          from sqlalchemy.orm import Session
          from database_setup import KalmanFilterFusionData, WeightedAverageFusionData, SessionLocal
     
     
          def weighted_average_fusion(values, weights):
              """Perform weighted average of given values with weights."""
              if len(values) != len(weights):
                  raise ValueError("Length of values and weights must match.")
              return sum(v * w for v, w in zip(values, weights))
     
     
          def fetch_recent_sensor_data(session, sensor_ids, window_seconds):
              """Fetch the most recent Kalman-filtered readings for given sensor_ids within time window."""
              now = datetime.utcnow()
              window_start = now - timedelta(seconds=window_seconds)
              latest_data = {}
     
              for sensor_id in sensor_ids:
                  entry = session.query(KalmanFilterFusionData)\
                      .filter(KalmanFilterFusionData.SensorID == sensor_id)\
                      .filter(KalmanFilterFusionData.Timestamp >= window_start)\
                      .order_by(KalmanFilterFusionData.Timestamp.desc())\
                      .first()
                  if entry:
                      latest_data[sensor_id] = entry.FusedValue
     
              return latest_data
     
     
          def process_weighted_fusion(sensor_ids, weights, sensor_type, fusion_window_seconds=60):
              """
              Run weighted average fusion on a given set of sensor IDs and weights.
     
              Args:
                  sensor_ids (list): List of sensor IDs.
                  weights (list): Corresponding weights (same length as sensor_ids).
                  sensor_type (str): Sensor type label (e.g., "Temperature", "Humidity").
                  fusion_window_seconds (int): Time window in seconds to consider valid readings.
              """
              session: Session = SessionLocal()
              try:
                  sensor_data = fetch_recent_sensor_data(session, sensor_ids, fusion_window_seconds)
     
                  if not sensor_data:
                      print(f"[{sensor_type.upper()}] No recent readings available.")
                      return
     
                  available_ids = list(sensor_data.keys())
                  available_values = [sensor_data[sid] for sid in available_ids]
     
                  # Adjust weights to match available sensors
                  weight_map = {sid: w for sid, w in zip(sensor_ids, weights)}
                  available_weights = [weight_map[sid] for sid in available_ids]
     
     
                  # Normalize weights
                  total_weight = sum(available_weights)
                  normalized_weights = [w / total_weight for w in available_weights]
     
                  fused_value = weighted_average_fusion(available_values, normalized_weights)
     
                  session.add(WeightedAverageFusionData(
                      SensorType=sensor_type,
                      Timestamp=datetime.utcnow(),
                      FusedValue=fused_value
                  ))
                  session.commit()
                  print(f"[{sensor_type.upper()}] Fused value: {fused_value:.2f} from {len(available_values)} sensors.")
              except Exception as e:
                  session.rollback()
                  print(f"[ERROR] Fusion failed for {sensor_type}: {e}")
              finally:
                  session.close()
          ↑↑↑ END OF FILE ↑↑↑
     ↑↑↑ END OF FILE ↑↑↑

├── static
│   ├── Belal.jpeg
│   ├── Mostafa.jpg
│   ├── Raghad.jpeg
│   ├── Team.jpeg
│   ├── YoussefAhmed.jpeg
│   ├── abaza.jpeg
│   ├── h.jpeg
│   ├── hamzawy.jpeg
│   ├── leaf_banner.avif
│   ├── marwan.jpeg
│   ├── no-signal.jpg
│   ├── predictions
│   │   ├── snapshot_1747066344.jpg
│   │   ├── snapshot_1747066357.jpg
│   │   └── snapshot_1747066365.jpg
│   └── styles.css
│        ↓↓↓ FILE CONTENT ↓↓↓
│        body {
│            margin: 0;
│            font-family: Arial, sans-serif;
│            background-color: #f4f4f4;
│            text-align: center;
│        }
│        img {
│            max-width: 300px;
│            margin: 10px;
│            border: 2px solid #ccc;
│            padding: 5px;
│        }
│        
│        nav {
│            display: flex;
│            justify-content: space-between;
│            align-items: center;
│            background-color: #2c3e50;
│            padding: 15px 30px;
│        }
│        
│        .logo {
│            font-size: 24px;
│            font-weight: bold;
│            color: #ecf0f1;
│        }
│        
│        nav ul {
│            list-style: none;
│            padding: 0;
│            display: flex;
│        }
│        
│        nav ul li {
│            margin: 0 15px;
│        }
│        
│        nav ul li a {
│            text-decoration: none;
│            color: #ecf0f1;
│            font-size: 18px;
│        }
│        
│        nav ul li a:hover {
│            color: #1abc9c;
│        }
│        
│        .container {
│            margin-top: 50px;
│        }
│        
│        h1 {
│            color: #2c3e50;
│        }
│        
│        p {
│            color: #555;
│            font-size: 18px;
│        }
│        ↑↑↑ END OF FILE ↑↑↑

├── templates
│   ├── aboutus.html
│        ↓↓↓ FILE CONTENT ↓↓↓
│        {% extends "base.html" %}
│        {% block content %}
│        <div class="about-hero">
│            <h1>Meet the Team Behind the Greenhouse</h1>
│            <p class="intro">
│                We're a team of six engineers blending AI, embedded systems, and green architecture to develop an intelligent greenhouse system. Our solution improves sustainability and plant care through innovation.
│            </p>
│        </div>
│        
│        <div class="team-photo">
│            <img src="{{ url_for('static', filename='Team.jpeg') }}" alt="Team Group Photo">
│        </div>
│        
│        <div class="team-grid">
│            <!-- Supervisors -->
│            <div class="member-card">
│                <h3>Prof. Dr. Mohamed Abaza</h3>
│                <img src="{{ url_for('static', filename='abaza.jpeg') }}" alt="Dr. Mohamed Abaza">
│                <p class="role">Head of Electronics and Communication Engineering Department</p>
│                <p class="desc">
│                    Ph.D. in Digital Communications from Université de Bretagne Occidentale, France. IEEE Senior Member with 40+ publications and over 900 citations. Expert in MIMO, optical wireless systems, and accreditation. Leads curriculum development and international student training programs.
│                </p>
│            </div>
│        
│            <div class="member-card">
│                <h3>Associate Prof. Dr. Hesham Ali</h3>
│                <img src="{{ url_for('static', filename='h.jpeg') }}" alt="Biomedical Supervisor">
│                <p class="role">Head of Biomedical Engineering Department</p>
│                <p class="desc">
│                    21+ years in academia and 15+ years in electronic design. Specialist in embedded systems, MEMS modeling, PCB design, and biomedical equipment. Reviewer at IEEE IoT Magazine and highly experienced in lab instrumentation, FPGA systems, and digital signal processing.
│                </p>
│            </div>
│        
│            {% set members = [
│                {"name": "Belal Alaa Eldin", "img": "Belal.jpeg", "role": "Full Stack Developer", "desc": "Architected and implemented the system's backend and frontend infrastructure. Led integration between sensors, UI, and network communication for seamless remote control."},
│                {"name": "Marwan Mohamed Fouad", "img": "marwan.jpeg", "role": "AI Model Developer", "desc": "Created a deep learning model for plant disease classification. Developed and tested model deployment pipelines and real-time inference on edge devices."},
│                {"name": "Mohamed Emad el Hamzawy", "img": "hamzawy.jpeg", "role": "Sensor Fusion Engineer", "desc": "Designed hybrid algorithms using Kalman filters and averaging strategies to merge multi-source data, enabling more accurate and robust sensor readings."},
│                {"name": "Mohamed Mostafa", "img": "Mostafa.jpg", "role": "Research & Documentation Lead", "desc": "Provided critical technical documentation and academic support. Researched agricultural technologies to guide system decisions with evidence-based insights."},
│                {"name": "Raghad Osama", "img": "Raghad.jpeg", "role": "RC Rover Developer", "desc": "Built an autonomous rover for real-time greenhouse inspection and spraying. Integrated AI camera input and disease response into mobile operation."},
│                {"name": "Youssef Ahmed Abdelaziz", "img": "YoussefAhmed.jpeg", "role": "Greenhouse Architect & Hardware Designer", "desc": "Designed the physical greenhouse and internal circuitry. Ensured environmental durability and optimal sensor-actuator layout through CAD planning."}
│            ] %}
│        
│            {% for m in members %}
│            <div class="member-card">
│                <h3>{{ m.name }}</h3>
│                <img src="{{ url_for('static', filename=m.img) }}" alt="{{ m.name }}">
│                <p class="role">{{ m.role }}</p>
│                <p class="desc">{{ m.desc }}</p>
│            </div>
│            {% endfor %}
│        </div>
│        
│        <style>
│            .about-hero {
│                text-align: center;
│                padding: 80px 20px 40px;
│                background: linear-gradient(to right, #e6f9ea, #f4fef7);
│                border-bottom: 1px solid #cce8d4;
│            }
│        
│            .about-hero h1 {
│                font-size: 2.8rem;
│                color: #207d49;
│                margin-bottom: 20px;
│                font-weight: 600;
│                letter-spacing: 1px;
│            }
│        
│            .about-hero .intro {
│                max-width: 700px;
│                margin: auto;
│                font-size: 1.2rem;
│                color: #333;
│                line-height: 1.7;
│            }
│        
│            .team-photo img {
│                display: block;
│                max-width: 90%;
│                margin: 40px auto;
│                border-radius: 16px;
│                box-shadow: 0 10px 30px rgba(0,0,0,0.15);
│                transition: transform 0.3s ease;
│            }
│        
│            .team-photo img:hover {
│                transform: scale(1.01);
│            }
│        
│            .team-grid {
│                display: grid;
│                grid-template-columns: repeat(3, 1fr);
│                gap: 40px;
│                padding: 50px 20px;
│                background-color: #f7fcf9;
│            }
│        
│            .member-card {
│                background: white;
│                border-radius: 16px;
│                padding: 30px 20px;
│                text-align: center;
│                box-shadow: 0 8px 18px rgba(0, 100, 0, 0.08);
│                transition: all 0.3s ease;
│                display: flex;
│                flex-direction: column;
│                align-items: center;
│            }
│        
│            .member-card:hover {
│                transform: translateY(-6px);
│                box-shadow: 0 12px 24px rgba(0, 100, 0, 0.15);
│            }
│        
│            .member-card img {
│                width: 120px;
│                height: 120px;
│                border-radius: 50%;
│                object-fit: cover;
│                margin-bottom: 15px;
│                border: 3px solid #a8d5ba;
│                box-shadow: 0 2px 6px rgba(0,0,0,0.1);
│            }
│        
│            .member-card h3 {
│                font-size: 1.4rem;
│                margin-bottom: 5px;
│                color: #1c5e35;
│                font-weight: 600;
│            }
│        
│            .member-card .role {
│                font-weight: 500;
│                color: #2b9348;
│                margin-bottom: 12px;
│                font-size: 1rem;
│                letter-spacing: 0.5px;
│            }
│        
│            .member-card .desc {
│                font-size: 0.95rem;
│                color: #555;
│                line-height: 1.6;
│                max-width: 90%;
│            }
│        
│            /* Responsive design */
│            @media (max-width: 1200px) {
│                .team-grid {
│                    grid-template-columns: repeat(2, 1fr);
│                }
│            }
│        
│            @media (max-width: 768px) {
│                .team-grid {
│                    grid-template-columns: 1fr;
│                }
│            }
│        </style>
│        {% endblock %}
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── ai_model.html
│        ↓↓↓ FILE CONTENT ↓↓↓
│        {% extends "base.html" %}
│        
│        {% block title %}YOLO Image Processor{% endblock %}
│        
│        
│        <style>
│            body {
│                font-family: 'Poppins', sans-serif;
│                background-color: #f5f7fa;
│                margin: 0;
│                padding: 20px;
│                color: #333;
│            }
│        
│            h1 {
│                text-align: center;
│                color: #2c3e50;
│                margin: 20px 0;
│            }
│        
│            .buttons {
│                text-align: center;
│                margin-bottom: 20px;
│            }
│        
│            form {
│                display: inline-block;
│                margin: 10px;
│                text-align: center;
│            }
│        
│            button {
│                background-color: #3498db;
│                color: white;
│                border: none;
│                padding: 12px 20px;
│                font-size: 16px;
│                border-radius: 8px;
│                cursor: pointer;
│                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
│                transition: background-color 0.3s ease;
│            }
│        
│            button:hover {
│                background-color: #2980b9;
│            }
│        
│            .image-gallery {
│                display: flex;
│                flex-wrap: wrap;
│                justify-content: center;
│                margin-top: 20px;
│            }
│        
│            .image-card {
│                background: white;
│                margin: 10px;
│                padding: 10px;
│                border-radius: 10px;
│                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
│                width: 320px;
│            }
│        
│            .image-card img {
│                max-width: 100%;
│                border-radius: 8px;
│            }
│        
│            .image-card p {
│                margin-top: 8px;
│                font-size: 14px;
│                color: #555;
│                text-align: center;
│            }
│        </style>
│        
│        
│        {% block content %}
│        <h1>YOLO Image Processor</h1>
│        
│        <!-- Buttons -->
│        <div class="buttons">
│            <form action="/run" method="post">
│                <button type="submit">🚀 Run YOLO on Images</button>
│            </form>
│        </div>
│        
│        <!-- Images -->
│        <h2 style="text-align: center;">Processed Images</h2>
│        
│        {% if images %}
│            <div class="image-gallery">
│                {% for img in images %}
│                    <div class="image-card">
│                        <img src="{{ url_for('static', filename='predictions/' + img) }}" alt="{{ img }}">
│                        <p>{{ img }}</p>
│                    </div>
│                {% endfor %}
│            </div>
│        {% else %}
│            <p style="text-align: center;">No processed images yet.</p>
│        {% endif %}
│        {% endblock %}
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── base.html
│        ↓↓↓ FILE CONTENT ↓↓↓
│        <!DOCTYPE html>
│        <html lang="en">
│        <head>
│            <meta charset="UTF-8">
│            <meta name="viewport" content="width=device-width, initial-scale=1.0">
│            <title>Greenhouse Monitoring</title>
│        
│            <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
│            <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
│        
│            <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
│            <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
│            <script>
│                window.addEventListener("beforeunload", function () {
│                    navigator.sendBeacon("/logout");
│                });
│            </script>
│        
│            <style>
│                body {
│                    font-family: 'Poppins', sans-serif;
│                }
│        
│                nav {
│                    display: flex;
│                    justify-content: space-between;
│                    align-items: center;
│                    background-color: #2c3e50;
│                    color: white;
│                    padding: 10px 20px;
│                }
│        
│                nav .logo {
│                    font-weight: bold;
│                    font-size: 24px;
│                }
│        
│                nav ul {
│                    list-style-type: none;
│                    display: flex;
│                    gap: 20px;
│                    padding: 0;
│                    margin: 0;
│                }
│        
│                nav ul li {
│                    display: flex;
│                    align-items: center;
│                }
│        
│                nav ul li a {
│                    color: #ecf0f1;
│                    text-decoration: none;
│                    font-weight: 600;
│                    font-size: 16px;
│                }
│        
│                nav ul li a:hover {
│                    text-decoration: underline;
│                }
│        
│                .logout-btn {
│                    background-color: #e74c3c;
│                    color: white;
│                    border: none;
│                    padding: 8px 14px;
│                    border-radius: 5px;
│                    font-weight: bold;
│                    font-size: 15px;
│                    cursor: pointer;
│                    transition: background-color 0.3s ease;
│                }
│        
│                .logout-btn:hover {
│                    background-color: #c0392b;
│                }
│        
│                .chart-container {
│                    width: 100%;
│                    max-width: 900px;
│                    margin: auto;
│                    margin-top: 50px;
│                }
│        
│                .footer {
│                    background-color: #2c3e50;
│                    color: #fff;
│                    padding: 20px 0;
│                    margin-top: 40px;
│                    text-align: center;
│                }
│        
│                .footer-container {
│                    max-width: 1000px;
│                    margin: auto;
│                    display: flex;
│                    flex-direction: column;
│                    align-items: center;
│                    gap: 10px;
│                }
│        
│                .footer-container nav a {
│                    color: #ecf0f1;
│                    margin: 0 15px;
│                    text-decoration: none;
│                    font-weight: bold;
│                }
│        
│                .footer-container nav a:hover {
│                    text-decoration: underline;
│                }
│            </style>
│        </head>
│        <body>
│        
│        {% if not hide_nav %}
│            <nav>
│                <div class="logo">Greenhouse</div>
│                <ul>
│                    <li><a href="/">Home</a></li>
│                    <li><a href="/dashboard">Dashboard</a></li>
│                    <li><a href="/results">Diseases Detection</a></li>
│                    <li>
│                        <form action="{{ url_for('auth.logout') }}" method="get" style="display:inline;">
│                            <button type="submit" class="logout-btn">Logout</button>
│                        </form>
│                    </li>
│                </ul>
│            </nav>
│        {% else %}
│            <div style="background-color: #2c3e50; padding: 15px; text-align: center;">
│                <div class="logo" style="color: white; font-size: 24px; font-weight: bold;">Greenhouse</div>
│            </div>
│        {% endif %}
│        
│        <main>
│            {% block content %}{% endblock %}
│        </main>
│        
│        <footer class="footer">
│            <div class="footer-container">
│                <p>&copy; 2025 Smart Greenhouse Project</p>
│                <nav>
│                    <a href="/about">About Us</a>
│                    <a href="#">Contact</a>
│                </nav>
│            </div>
│        </footer>
│        
│        </body>
│        </html>
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── dashboard.html
│        ↓↓↓ FILE CONTENT ↓↓↓
│        {% extends "base.html" %}
│        
│        {% block content %}
│        <h1>🌿 Greenhouse Sensor Dashboard</h1>
│        
│        <!-- Time Scale Controls -->
│        <div class="chart-section">
│            <h2>Time Scale</h2>
│            <div class="button-group" id="time-scale-buttons">
│                <button onclick="setTimeScale('seconds')" id="scale-seconds">Seconds</button>
│                <button onclick="setTimeScale('minutes')" id="scale-minutes" class="active">Minutes</button>
│                <button onclick="setTimeScale('hours')" id="scale-hours">Hours</button>
│                <button onclick="setTimeScale('days')" id="scale-days">Days</button>
│                <button onclick="setTimeScale('weeks')" id="scale-weeks">Weeks</button>
│            </div>
│        </div>
│        
│        <!-- Weighted Chart -->
│        <div class="chart-section">
│            <h2>Weighted Average Fusion</h2>
│            <div id="weightedChart" class="plot-container"></div>
│        </div>
│        
│        <!-- Raw Sensor Chart -->
│        <div class="chart-section">
│            <h2>Raw Sensor Data</h2>
│            <div class="button-group">
│                <button onclick="showRawCategory('temperature')" id="raw-temperature" class="active">🌡️ Temperature</button>
│                <button onclick="showRawCategory('humidity')" id="raw-humidity">💧 Humidity</button>
│                <button onclick="showRawCategory('soil')" id="raw-soil">🌱 Soil Moisture</button>
│            </div>
│            <div id="rawChart" class="plot-container"></div>
│        </div>
│        
│        <!-- Kalman Filter Chart -->
│        <div class="chart-section">
│            <h2>Kalman Filter Fusion</h2>
│            <div class="button-group">
│                <button onclick="showKalmanCategory('temperature')" id="kalman-temperature" class="active">🌡️ Temperature</button>
│                <button onclick="showKalmanCategory('humidity')" id="kalman-humidity">💧 Humidity</button>
│                <button onclick="showKalmanCategory('soil')" id="kalman-soil">🌱 Soil Moisture</button>
│            </div>
│            <div id="kalmanChart" class="plot-container"></div>
│        </div>
│        
│        <!-- Plotly Script -->
│        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
│        
│        <script>
│        let rawCategories = { temperature: [], humidity: [], soil: [] };
│        let kalmanCategories = { temperature: [], humidity: [], soil: [] };
│        let weightedDataCache = [];
│        let currentTimeScale = 'minutes';
│        
│        function setTimeScale(scale) {
│            currentTimeScale = scale;
│            document.querySelectorAll('#time-scale-buttons button').forEach(btn => btn.classList.remove('active'));
│            document.getElementById(`scale-${scale}`).classList.add('active');
│        
│            showRawCategory(document.querySelector(".button-group .active[id^='raw-']").id.split("-")[1]);
│            showKalmanCategory(document.querySelector(".button-group .active[id^='kalman-']").id.split("-")[1]);
│            plotWeighted(weightedDataCache);
│        }
│        
│        function getWeekNumber(d) {
│            const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
│            const dayNum = date.getUTCDay() || 7;
│            date.setUTCDate(date.getUTCDate() + 4 - dayNum);
│            const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
│            return Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
│        }
│        
│        function formatTimestamps(timestamps) {
│            return timestamps.map(str => {
│                const date = new Date(str);
│                if (currentTimeScale === "weeks") return str;
│        
│                if (isNaN(date.getTime())) return str;
│        
│                switch (currentTimeScale) {
│                    case 'seconds':
│                        return date.toLocaleTimeString();
│                    case 'minutes':
│                        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
│                    case 'hours':
│                        return date.toLocaleTimeString([], { hour: '2-digit' }) + ":00";
│                    case 'days':
│                        return date.toLocaleDateString();
│                    default:
│                        return str;
│                }
│            });
│        }
│        
│        function groupDataByScale(sensorData, scale) {
│            const grouped = [];
│        
│            for (const sensor of sensorData) {
│                const buckets = {};
│        
│                for (let i = 0; i < sensor.timestamps.length; i++) {
│                    const date = new Date(sensor.timestamps[i]);
│        
│                    let key;
│                    switch (scale) {
│                        case 'seconds':
│                            key = date.toISOString();
│                            break;
│                        case 'minutes':
│                            key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()} ${date.getHours()}:${date.getMinutes()}`;
│                            break;
│                        case 'hours':
│                            key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()} ${date.getHours()}:00`;
│                            break;
│                        case 'days':
│                            key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
│                            break;
│                        case 'weeks':
│                            const week = getWeekNumber(date);
│                            key = `${date.getFullYear()}-W${week}`;
│                            break;
│                        default:
│                            key = date.toISOString();
│                    }
│        
│                    if (!buckets[key]) buckets[key] = [];
│                    buckets[key].push(sensor.values[i]);
│                }
│        
│                const groupedTimestamps = Object.keys(buckets);
│                const groupedValues = groupedTimestamps.map(k =>
│                    buckets[k].reduce((a, b) => a + b, 0) / buckets[k].length
│                );
│        
│                grouped.push({
│                    label: sensor.label || sensor.sensor_type,
│                    timestamps: groupedTimestamps,
│                    values: groupedValues
│                });
│            }
│        
│            return grouped;
│        }
│        
│        function categorize(data) {
│            const categories = { temperature: [], humidity: [], soil: [] };
│            for (const d of data) {
│                const name = d.label.toLowerCase();
│                if (name.includes("temp")) categories.temperature.push(d);
│                else if (name.includes("humid")) categories.humidity.push(d);
│                else if (name.includes("soil")) categories.soil.push(d);
│            }
│            return categories;
│        }
│        
│        function plotCategory(data, elementId) {
│            if (data.length === 0) {
│                Plotly.purge(elementId);
│                document.getElementById(elementId).innerHTML = "<p style='text-align:center;color:#888;'>No data available.</p>";
│                return;
│            }
│        
│            const grouped = groupDataByScale(data, currentTimeScale);
│        
│            Plotly.react(elementId, grouped.map(sensor => ({
│                x: formatTimestamps(sensor.timestamps),
│                y: sensor.values,
│                mode: 'lines+markers',
│                name: sensor.label
│            })), {
│                xaxis: { title: 'Time' },
│                yaxis: { title: 'Value' },
│                margin: { t: 10 }
│            });
│        }
│        
│        function plotWeighted(data) {
│            weightedDataCache = data;
│            if (data.length === 0) {
│                Plotly.purge("weightedChart");
│                document.getElementById("weightedChart").innerHTML = "<p style='text-align:center;color:#888;'>No data available.</p>";
│                return;
│            }
│        
│            const grouped = groupDataByScale(data, currentTimeScale);
│        
│        Plotly.react("weightedChart", grouped.map(sensor => ({
│            x: formatTimestamps(sensor.timestamps),
│            y: sensor.values,
│            mode: 'lines+markers',
│            name: sensor.label || sensor.sensor_type || "Unknown"
│        })), {
│            xaxis: { title: 'Time' },
│            yaxis: { title: 'Fused Value' },
│            margin: { t: 10 }
│        });
│        
│        }
│        
│        function setActive(prefix, type) {
│            document.querySelectorAll(`button[id^="${prefix}-"]`).forEach(btn => btn.classList.remove("active"));
│            document.getElementById(`${prefix}-${type}`).classList.add("active");
│        }
│        
│        function showRawCategory(type) {
│            plotCategory(rawCategories[type], "rawChart");
│            setActive("raw", type);
│        }
│        
│        function showKalmanCategory(type) {
│            plotCategory(kalmanCategories[type], "kalmanChart");
│            setActive("kalman", type);
│        }
│        
│        async function fetchAndUpdateCharts() {
│            try {
│                const response = await fetch("/api/dashboard-data");
│                const data = await response.json();
│        
│                rawCategories = categorize(data.raw);
│                kalmanCategories = categorize(data.kalman);
│                weightedDataCache = data.weighted;
│        
│                const rawType = document.querySelector(".button-group .active[id^='raw-']").id.split("-")[1];
│                const kalmanType = document.querySelector(".button-group .active[id^='kalman-']").id.split("-")[1];
│        
│                showRawCategory(rawType);
│                showKalmanCategory(kalmanType);
│                plotWeighted(weightedDataCache);
│            } catch (err) {
│                console.error("Failed to fetch update:", err);
│            }
│        }
│        
│        fetchAndUpdateCharts();
│        setInterval(fetchAndUpdateCharts, 10000);
│        </script>
│        
│        <style>
│        body {
│            font-family: 'Inter', sans-serif;
│            background-color: #f4f6f9;
│            margin: 0;
│            padding: 0;
│            color: #333;
│        }
│        
│        h1 {
│            text-align: center;
│            padding: 30px 0 10px;
│            font-size: 2.2rem;
│        }
│        
│        h2 {
│            font-size: 1.4rem;
│            margin-bottom: 10px;
│            color: #2c3e50;
│        }
│        
│        .chart-section {
│            margin: 30px auto;
│            max-width: 1000px;
│            background: white;
│            border-radius: 12px;
│            padding: 25px;
│            box-shadow: 0 4px 12px rgba(0,0,0,0.06);
│        }
│        
│        .button-group {
│            display: flex;
│            justify-content: center;
│            margin: 20px 0 10px;
│            flex-wrap: wrap;
│        }
│        
│        .button-group button {
│            padding: 10px 18px;
│            margin: 6px;
│            cursor: pointer;
│            border: none;
│            border-radius: 8px;
│            background-color: #e0e6ed;
│            color: #333;
│            font-weight: 600;
│            transition: 0.2s ease;
│        }
│        
│        .button-group button:hover {
│            background-color: #d0dbe8;
│        }
│        
│        .button-group .active {
│            background-color: #2c7be5;
│            color: #fff;
│        }
│        
│        .plot-container {
│            width: 100%;
│            height: 400px;
│        }
│        
│        @media (max-width: 768px) {
│            .button-group {
│                flex-direction: column;
│                align-items: center;
│            }
│        
│            .button-group button {
│                width: 80%;
│            }
│        
│            .plot-container {
│                height: 350px;
│            }
│        }
│        </style>
│        {% endblock %}
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── index.html
│        ↓↓↓ FILE CONTENT ↓↓↓
│        {% extends "base.html" %}
│        
│        {% block content %}
│        <div class="container">
│            <h1>Welcome to the AI-driven Greenhouse</h1>
│        </div>
│        
│        <!-- Device Control Panel -->
│        <div class="control-panel">
│            <h2>Actuator Control</h2>
│        
│            <!-- === BOXED ADDITION: Manual Control Buttons (Toggle Style) === -->
│            <button id="vent-btn" class="control-btn off" onclick="toggleSingle('vent', 2009)">Ventilation: OFF</button>
│            <button id="irrig-btn" class="control-btn off" onclick="toggleSingle('irrig', 3009)">Irrigation: OFF</button>
│            <!-- === END BOXED ADDITION === -->
│        </div>
│        
│        <!-- Threshold Slider Panel -->
│        <div class="slider-panel">
│            <h2>Threshold Settings</h2>
│            <label>Temperature Threshold: <span id="tempValue">27</span>°C</label>
│            <input type="range" id="tempSlider" min="10" max="50" value="27" oninput="updateSlider('temp')">
│        
│            <label>Humidity Threshold: <span id="humValue">80</span>%</label>
│            <input type="range" id="humSlider" min="30" max="100" value="80" oninput="updateSlider('hum')">
│        
│            <label>Soil Moisture Threshold: <span id="soilValue">4000</span></label>
│            <input type="range" id="soilSlider" min="500" max="6000" value="4000" oninput="updateSlider('soil')">
│        
│            <button onclick="saveThresholds()">Save Thresholds</button>
│        </div>
│        
│        <!--  Live Status Display moved here -->
│        <div class="container">
│            <div class="status-container">
│                <div class="status-box">
│                    <h2>🌡️ Temperature</h2>
│                    <p id="temp-value">-- °C</p>
│                </div>
│                <div class="status-box">
│                    <h2>💧 Humidity</h2>
│                    <p id="humidity-value">-- %</p>
│                </div>
│                <div class="status-box">
│                    <h2>🌱 Soil Moisture</h2>
│                    <p id="soil-value">--</p>
│                </div>
│            </div>
│        </div>
│        
│        <!-- Camera Stream -->
│        <div class="container">
│            <h1>Surveillance</h1>
│            <p>Two cameras for monitoring.</p>
│            <img id="camera-stream" src="http://192.168.200.155:81/stream" width="400" height="400" alt="ESP32-CAM Stream"
│                 onerror="this.onerror=null; this.src='static/no-signal.jpg';">
│        </div>
│        
│        <script>
│            function updateSlider(type) {
│                if (type === 'temp') {
│                    document.getElementById('tempValue').textContent = document.getElementById('tempSlider').value;
│                } else if (type === 'hum') {
│                    document.getElementById('humValue').textContent = document.getElementById('humSlider').value;
│                } else if (type === 'soil') {
│                    document.getElementById('soilValue').textContent = document.getElementById('soilSlider').value;
│                }
│            }
│        
│            function saveThresholds() {
│                const data = {
│                    temp_threshold: document.getElementById('tempSlider').value,
│                    hum_threshold: document.getElementById('humSlider').value,
│                    soil_moisture_threshold: document.getElementById('soilSlider').value
│                };
│        
│                fetch('/set_thresholds', {
│                    method: 'POST',
│                    headers: { 'Content-Type': 'application/json' },
│                    body: JSON.stringify(data)
│                })
│                .then(res => res.json())
│                .then(response => {
│                    alert(response.message);
│                })
│                .catch(error => {
│                    console.error('Error:', error);
│                    alert('Error saving thresholds.');
│                });
│            }
│        
│            window.onload = () => {
│                fetch('/get_thresholds')
│                    .then(res => res.json())
│                    .then(data => {
│                        document.getElementById('tempSlider').value = data.TEMP_THRESHOLD;
│                        document.getElementById('humSlider').value = data.HUM_THRESHOLD;
│                        document.getElementById('soilSlider').value = data.SOIL_MOISTURE_THRESHOLD;
│                        updateSlider('temp');
│                        updateSlider('hum');
│                        updateSlider('soil');
│                    });
│        
│                fetchLatestValues();
│                setInterval(fetchLatestValues, 10000);
│            };
│        
│            async function fetchLatestValues() {
│                try {
│                    const res = await fetch('/api/latest-fused-values');
│                    const data = await res.json();
│        
│                    document.getElementById("temp-value").textContent = data.temperature?.toFixed(2) + " °C";
│                    document.getElementById("humidity-value").textContent = data.humidity?.toFixed(2) + " %";
│                    document.getElementById("soil-value").textContent = data.soil_moisture?.toFixed(2);
│                } catch (err) {
│                    console.error("Failed to load latest values", err);
│                }
│            }
│        
│            // === BOXED ADDITION: Single Toggle Button Logic with Label Map ===
│            function toggleSingle(id, actuatorId) {
│                const btn = document.getElementById(`${id}-btn`);
│                const isOn = btn.classList.contains("on");
│                const newState = isOn ? "OFF" : "ON";
│                const action = `${capitalize(id)}_${newState}`;
│        
│                const labelMap = {
│                    vent: "Ventilation",
│                    irrig: "Irrigation"
│                };
│        
│                fetch("/manual-control", {
│                    method: "POST",
│                    headers: { "Content-Type": "application/json" },
│                    body: JSON.stringify({
│                        user_id: 7000,
│                        actuator_id: actuatorId,
│                        action: action
│                    })
│                })
│                .then(res => res.json())
│                .then(data => {
│                    alert(data.message || "Success");
│                    btn.classList.toggle("on", newState === "ON");
│                    btn.classList.toggle("off", newState !== "ON");
│                    btn.innerText = `${labelMap[id] || capitalize(id)}: ${newState}`;
│                })
│                .catch(err => alert("Error: " + err));
│            }
│        
│            function capitalize(word) {
│                return word.charAt(0).toUpperCase() + word.slice(1);
│            }
│            // === END BOXED ADDITION ===
│        </script>
│        
│        <style>
│            * { box-sizing: border-box; }
│            body { margin: 0; font-family: Arial, sans-serif; }
│            .container { padding: 20px; margin-left: 270px; transition: margin-left 0.3s ease; }
│            .control-panel, .slider-panel {
│                width: 240px;
│                padding: 15px;
│                background-color: #f4f4f4;
│                border-radius: 10px;
│                box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
│                position: fixed;
│                left: 20px;
│                z-index: 10;
│            }
│            .control-panel { top: 100px; }
│            .slider-panel { bottom: 10%; background-color: #f9f9f9; }
│            .control-btn {
│                display: block;
│                width: 100%;
│                margin: 10px 0;
│                padding: 10px;
│                font-size: 16px;
│                font-weight: bold;
│                border: none;
│                border-radius: 5px;
│                cursor: pointer;
│            }
│            .on { background-color: green; color: white; }
│            .off { background-color: red; color: white; }
│            .slider-panel label { margin-top: 10px; display: block; }
│            .slider-panel input[type="range"] { width: 100%; }
│            .slider-panel button {
│                margin-top: 15px;
│                width: 100%;
│                padding: 10px;
│                font-weight: bold;
│                background-color: #007BFF;
│                color: white;
│                border: none;
│                border-radius: 5px;
│                cursor: pointer;
│            }
│            .status-container {
│                display: flex;
│                justify-content: center;
│                flex-wrap: wrap;
│                gap: 30px;
│                margin: 40px 0;
│            }
│            .status-box {
│                background: white;
│                border-radius: 12px;
│                padding: 30px;
│                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
│                text-align: center;
│                width: 30%;
│                min-width: 220px;
│                flex: 1 1 250px;
│            }
│            .status-box h2 { margin-bottom: 10px; font-size: 1.4rem; color: #2c3e50; }
│            .status-box p { font-size: 2rem; font-weight: bold; color: #2c7be5; }
│            img#camera-stream {
│                max-width: 100%;
│                height: auto;
│                display: block;
│                margin-top: 20px;
│            }
│            @media (max-width: 992px) {
│                .container { margin-left: 0; padding: 15px; }
│                .control-panel, .slider-panel {
│                    position: static;
│                    width: 100%;
│                    margin-bottom: 20px;
│                }
│                .status-container {
│                    flex-direction: column;
│                    align-items: center;
│                }
│                .status-box {
│                    width: 90%;
│                    max-width: 400px;
│                }
│            }
│        </style>
│        
│        {% endblock %}
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── login.html
│        ↓↓↓ FILE CONTENT ↓↓↓
│        {% extends "base.html" %}
│        {% block content %}
│        <div class="logo">Greenhouse</div>
│        <div class="signup-container">
│            <h2>Sign In</h2>
│            <form method="POST">
│                <label>Email</label>
│                <input type="email" name="email" required>
│        
│                <label>Password</label>
│                <input type="password" name="password" required>
│        
│                <button type="submit">Log In</button>
│            </form>
│            <p>Don't have an account? <a href="{{ url_for('auth.signup') }}">Sign up here</a>.</p>
│        
│            {% with messages = get_flashed_messages(with_categories=true) %}
│              {% if messages %}
│                <ul class="flashes">
│                  {% for category, message in messages %}
│                    <li class="{{ category }}">{{ message }}</li>
│                  {% endfor %}
│                </ul>
│              {% endif %}
│            {% endwith %}
│        </div>
│        {% endblock %}
│        ↑↑↑ END OF FILE ↑↑↑

│   └── signup.html
│        ↓↓↓ FILE CONTENT ↓↓↓
│        {% extends "base.html" %}
│        {% block content %}
│        <div class="logo">Greenhouse</div>
│        <div class="signup-container">
│            <h2>Create Account</h2>
│            <form method="POST">
│                <label>Email</label>
│                <input type="email" name="email" required>
│        
│                <label>Username</label>
│                <input type="text" name="username" required>
│        
│                <label>Full Name</label>
│                <input type="text" name="full_name" required>
│        
│                <label>Password</label>
│                <input type="password" name="password" required>
│        
│                <button type="submit">Sign Up</button>
│            </form>
│            <p>Already have an account? <a href="{{ url_for('auth.login') }}">Log in here</a>.</p>
│        
│            {% with messages = get_flashed_messages(with_categories=true) %}
│              {% if messages %}
│                <ul class="flashes">
│                  {% for category, message in messages %}
│                    <li class="{{ category }}">{{ message }}</li>
│                  {% endfor %}
│                </ul>
│              {% endif %}
│            {% endwith %}
│        </div>
│        {% endblock %}
│        ↑↑↑ END OF FILE ↑↑↑

├── trials
│   ├── capturingImagesFromRasCam.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        import cv2
│        import requests
│        import numpy as np
│        import time
│        
│        # MJPEG stream URL
│        url = "http://192.168.1.15:5000/video_feed"
│        
│        # Connect to the stream
│        stream = requests.get(url, stream=True)
│        if stream.status_code != 200:
│            print("❌ Failed to connect to video stream")
│            exit()
│        
│        print("📷 Press 'b' to capture an image, 'q' to quit")
│        
│        bytes_buffer = b""
│        img_count = 0
│        
│        for chunk in stream.iter_content(chunk_size=1024):
│            bytes_buffer += chunk
│            a = bytes_buffer.find(b'\xff\xd8')
│            b = bytes_buffer.find(b'\xff\xd9')
│        
│            if a != -1 and b != -1:
│                jpg = bytes_buffer[a:b+2]
│                bytes_buffer = bytes_buffer[b+2:]
│        
│                img_np = np.frombuffer(jpg, dtype=np.uint8)
│                frame = cv2.imdecode(img_np, cv2.IMREAD_COLOR)
│                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
│        
│                if frame is not None:
│                    cv2.imshow("Live Stream", frame)
│        
│                    key = cv2.waitKey(1) & 0xFF
│                    if key == ord('b'):
│                        filename = f"snapshot_{int(time.time())}.jpg"
│                        cv2.imwrite(filename, frame)
│                        print(f"✅ Saved snapshot as {filename}")
│                    elif key == ord('q'):
│                        print("👋 Exiting...")
│                        break
│        
│        cv2.destroyAllWindows()
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── dashboardprev.html
│        ↓↓↓ FILE CONTENT ↓↓↓
│        <!--
│        <script>
│            function updateDashboard() {
│                $.getJSON("/data", function(data) {
│                    let time = data.time;
│        
│                    // Temperature Chart
│                    let temperature_traces = [];
│                    for (let i = 0; i < 4; i++) {
│                        temperature_traces.push({
│                            x: time,
│                            y: data.temperature[i],
│                            mode: 'lines',
│                            name: 'Temp ' + (i+1)
│                        });
│                    }
│                    Plotly.react('temperature_chart', temperature_traces, { title: 'Temperature Over Time' });
│        
│                    // Humidity Chart
│                    let humidity_traces = [];
│                    for (let i = 0; i < 2; i++) {
│                        humidity_traces.push({
│                            x: time,
│                            y: data.humidity[i],
│                            mode: 'lines',
│                            name: 'Humidity ' + (i+1)
│                        });
│                    }
│                    Plotly.react('humidity_chart', humidity_traces, { title: 'Humidity Over Time' });
│        
│                    // Soil Moisture Chart
│                    let soil_moisture_traces = [];
│                    for (let i = 0; i < 2; i++) {
│                        soil_moisture_traces.push({
│                            x: time,
│                            y: data.soil_moisture[i],
│                            mode: 'lines',
│                            name: 'Soil Moisture ' + (i+1)
│                        });
│                    }
│                    Plotly.react('soil_moisture_chart', soil_moisture_traces, { title: 'Soil Moisture Over Time' });
│                });
│            }
│        
│            // Update dashboard every 5 seconds
│            setInterval(updateDashboard, 5000);
│            updateDashboard();
│        </script> -->
│        <!-- <script>
│            function updateDashboard() {
│                $.getJSON("/data", function(data) {
│                    let time = data.time;
│        
│                    // Temperature Chart
│                    let temperature_traces = [];
│                    if (data.temperature) {
│                        let temperature_values = Object.values(data.temperature); // Extract values dynamically
│                        for (let i = 0; i < temperature_values.length; i++) {
│                            temperature_traces.push({
│                                x: time,
│                                y: temperature_values[i],
│                                mode: 'lines',
│                                name: 'Temp ' + (i + 1)
│                            });
│                        }
│                    }
│                    Plotly.react('temperature_chart', temperature_traces, { title: 'Temperature Over Time' });
│        
│                    // Humidity Chart
│                    let humidity_traces = [];
│                    if (data.humidity) {
│                        let humidity_values = Object.values(data.humidity);
│                        for (let i = 0; i < humidity_values.length; i++) {
│                            humidity_traces.push({
│                                x: time,
│                                y: humidity_values[i],
│                                mode: 'lines',
│                                name: 'Humidity ' + (i + 1)
│                            });
│                        }
│                    }
│                    Plotly.react('humidity_chart', humidity_traces, { title: 'Humidity Over Time' });
│        
│                    // Soil Moisture Chart
│                    let soil_moisture_traces = [];
│                    if (data.soil_moisture) {
│                        let soil_moisture_values = Object.values(data.soil_moisture);
│                        for (let i = 0; i < soil_moisture_values.length; i++) {
│                            soil_moisture_traces.push({
│                                x: time,
│                                y: soil_moisture_values[i],
│                                mode: 'lines',
│                                name: 'Soil Moisture ' + (i + 1)
│                            });
│                        }
│                    }
│                    Plotly.react('soil_moisture_chart', soil_moisture_traces, { title: 'Soil Moisture Over Time' });
│                });
│            }
│        
│            // Update dashboard every 5 seconds
│            setInterval(updateDashboard, 5000);
│            updateDashboard();
│        </script> -->
│        
│        <script>
│            function updateDashboard() {
│                $.getJSON("/data", function(data) {
│                    let time = data.time;
│                    let deviceIDs = data.DeviceID;
│        
│                    function createTraces(sensorData, chartId, title, label) {
│                        let traces = {};
│        
│                        for (let i = 0; i < 4; i++) {
│                            let deviceId = deviceIDs[i];
│                            if (!(deviceId in traces)) {
│                                traces[deviceId] = { x: [], y: [], mode: 'lines', name: label + ' Device ' + deviceId };
│                            }
│                            traces[deviceId].x.push(time[i]);
│                            traces[deviceId].y.push(sensorData[i]);
│                        }
│        
│                        Plotly.react(chartId, Object.values(traces), { title: title });
│                    }
│        
│                    if (data.temperature) {
│                        createTraces(data.temperature, 'temperature_chart', 'Temperature Over Time', 'Temp');
│                    }
│        
│                    if (data.humidity) {
│                        createTraces(data.humidity, 'humidity_chart', 'Humidity Over Time', 'Humidity');
│                    }
│        
│                    if (data.soil_moisture) {
│                        createTraces(data.soil_moisture, 'soil_moisture_chart', 'Soil Moisture Over Time', 'Soil Moisture');
│                    }
│                });
│            }
│        
│            // Update dashboard every 5 seconds
│            setInterval(updateDashboard, 5000);
│            updateDashboard();
│        </script>
│        
│        <!-- {% extends "base.html" %}
│        
│        {% block content %}
│        
│        <h1>Greenhouse Monitoring Dashboard</h1>
│        
│        <div id="temperature_chart"></div>
│        <div id="humidity_chart"></div>
│        <div id="soil_moisture_chart"></div>
│        
│        <script>
│            function updateDashboard() {
│                $.getJSON("/data", function(data) {
│                    let time = data.time;
│        
│                    // Temperature Chart
│                    let temperature_traces = [];
│                    for (let i = 0; i < 4; i++) {
│                        temperature_traces.push({
│                            x: time,
│                            y: data.temperature[i],
│                            mode: 'lines',
│                            name: 'Temp ' + (i+1)
│                        });
│                    }
│                    Plotly.react('temperature_chart', temperature_traces, { title: 'Temperature Over Time' });
│        
│                    // Humidity Chart
│                    let humidity_traces = [];
│                    for (let i = 0; i < 4; i++) {
│                        humidity_traces.push({
│                            x: time,
│                            y: data.humidity[i],
│                            mode: 'lines',
│                            name: 'Humidity ' + (i+1)
│                        });
│                    }
│                    Plotly.react('humidity_chart', humidity_traces, { title: 'Humidity Over Time' });
│        
│                    // Soil Moisture Chart
│                    let soil_moisture_traces = [];
│                    for (let i = 0; i < 2; i++) {
│                        soil_moisture_traces.push({
│                            x: time,
│                            y: data.soil_moisture[i],
│                            mode: 'lines',
│                            name: 'Soil Moisture ' + (i+1)
│                        });
│                    }
│                    Plotly.react('soil_moisture_chart', soil_moisture_traces, { title: 'Soil Moisture Over Time' });
│                });
│            }
│        
│            // Update dashboard every 5 seconds
│            setInterval(updateDashboard, 50000);
│            updateDashboard();
│        </script>
│        
│        
│        {% endblock %} -->
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── dashboardupgrade.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from flask import Blueprint, jsonify
│        import json
│        import os
│        import time
│        
│        dashboard_bp = Blueprint("dashboard", __name__)
│        
│        # File to store the last known data
│        DATA_FILE = "last_data.json"
│        
│        # Function to load the last known data
│        def load_last_data():
│            if os.path.exists(DATA_FILE):
│                with open(DATA_FILE, "r") as f:
│                    return json.load(f)
│            return {
│                "time": [],
│                "temperature": [[] for _ in range(6)],
│                "humidity": [[] for _ in range(6)],
│                "soil_moisture": [[] for _ in range(4)]
│            }
│        
│        # Function to save data
│        def save_data(data):
│            with open(DATA_FILE, "w") as f:
│                json.dump(data, f)
│        
│        # Global variable to store last known data
│        last_data = load_last_data()
│        last_update_time = time.time()
│        
│        @dashboard_bp.route("/data")
│        def get_data():
│            global last_data, last_update_time
│        
│            new_data = fetch_sensor_data()  # Replace this with your actual function
│        
│            if new_data:  # If there's new data, update the stored data
│                last_data = new_data
│                last_update_time = time.time()
│                save_data(last_data)  # Save updated data
│        
│            return jsonify(last_data)
│        
│        def fetch_sensor_data():
│            """
│            Simulates getting new sensor data.
│            Replace this with your actual function that gets data from sensors.
│            Returns None if no new data.
│            """
│            # Simulated condition where sometimes no new data arrives
│            if time.time() - last_update_time < 10:  # Assume no new data within 10 sec
│                return None
│        
│            # Simulated new data (Replace with real sensor data fetching)
│            return {
│                "time": ["2025-02-22 12:00:00"],  # Add real timestamp
│                "temperature": [[22.3, 22.5, 22.7, 22.6, 22.8, 22.9]],
│                "humidity": [[50, 51, 49, 48, 52, 50]],
│                "soil_moisture": [[30, 32, 29, 31]]
│            }
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── data_retrival.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from sqlalchemy.orm import sessionmaker
│        from database_setup import engine, SensorData,UserInteraction
│        import pandas as pd
│        
│        # this could also be used for sensor fusion
│        
│        #  Create session
│        Session = sessionmaker(bind=engine)
│        session = Session()
│        
│        #  Fetch all readings as a list of dictionaries
│        data = session.query(UserInteraction).all()
│        
│        # Convert SQLAlchemy objects to dictionaries
│        result_list = [
│            {"DeviceID": d.DeviceID, "UserID": d.UserID, "Action": d.Action, "Timestamp": d.Timestamp}
│            for d in data
│        ]
│        
│        #  Close session
│        session.close()
│        
│        print("\n Retrieved Sensor Readings List:")
│        print(result_list)
│        # data=result_list
│        # # Convert to Pandas DataFrame
│        # df = pd.DataFrame(data)
│        
│        # # Convert 'Timestamp' column to datetime format (if needed)
│        # df['Timestamp'] = pd.to_datetime(df['Timestamp'])
│        
│        # # Convert Timestamp to datetime
│        # df["Timestamp"] = pd.to_datetime(df["Timestamp"])
│        
│        # # Pivot the table to restructure data
│        # df_pivot = df.pivot_table(index=["Timestamp", "DeviceID"], columns="SensorType", values="Value", aggfunc="first")
│        
│        # # Rename columns explicitly to match the required output
│        # df_pivot.columns = df_pivot.columns.rename(None)  # Remove MultiIndex column names
│        # df_pivot.rename(columns={
│        #     "temperature": "temperature",
│        #     "humidity": "humidity",
│        #     "soil_moisture": "soil_moisture"
│        # }, inplace=True)
│        
│        # # Reset index to bring columns back
│        # df_pivot.reset_index(inplace=True)
│        
│        # # Rename Timestamp to time
│        # df_pivot.rename(columns={"Timestamp": "time"}, inplace=True)
│        
│        # # Display result
│        # print(df_pivot)
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── database_setup.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, ForeignKey
│        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
│        from datetime import datetime
│        
│        # Database connection
│        DATABASE_URL = "sqlite:///greenhouse.db"
│        engine = create_engine(DATABASE_URL, echo=True)
│        
│        # Create session factory
│        SessionLocal = sessionmaker(bind=engine)
│        
│        #  Base Model
│        class Base(DeclarativeBase):
│            pass
│        
│        #  Devices Table
│        class Device(Base):
│            __tablename__ = "devices"
│        
│            DeviceID = Column(Integer, primary_key=True)
│            DeviceName = Column(String(50), nullable=False)
│            Location = Column(String(100))
│            Status = Column(String(20))  # e.g., "Active", "Inactive"
│            Type = Column(String(50))  # e.g., "ESP32", "Raspberry Pi"
│        
│            sensor_data = relationship("SensorData", back_populates="device")
│            user_interactions = relationship("UserInteraction", back_populates="device")
│        
│        #  SensorData Table
│        class SensorData(Base):
│            __tablename__ = "sensor_data"
│        
│            DataID = Column(Integer, primary_key=True)
│            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
│            Timestamp = Column(DateTime, default=datetime.utcnow)
│            SensorType = Column(String(50))  # e.g., "temperature", "humidity"
│            Value = Column(Float)  # Sensor reading value
│        
│            device = relationship("Device", back_populates="sensor_data")
│        
│        #  UserInteractions Table
│        class UserInteraction(Base):
│            __tablename__ = "user_interactions"
│        
│            InteractionID = Column(Integer, primary_key=True)
│            UserID = Column(Integer)  # Assuming users are stored elsewhere
│            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
│            Action = Column(String(20), nullable=False)  # e.g., "Turn On", "Turn Off"
│            Timestamp = Column(DateTime, default=datetime.utcnow)
│        
│            device = relationship("Device", back_populates="user_interactions")
│        
│        #  Create Tables in SQLite
│        Base.metadata.create_all(engine)
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── database_setups.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from sqlalchemy import (
│            create_engine, Column, Integer, Float, String, DateTime, ForeignKey
│        )
│        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
│        from datetime import datetime
│        
│        # Database connection
│        DATABASE_URL = "sqlite:///greenhouse.db"
│        engine = create_engine(DATABASE_URL, echo=True)
│        SessionLocal = sessionmaker(bind=engine)
│        
│        # Base class
│        class Base(DeclarativeBase):
│            pass
│        
│        # Devices Table
│        class Device(Base):
│            __tablename__ = "devices"
│        
│            DeviceID = Column(Integer, primary_key=True)
│            DeviceName = Column(String(50), nullable=False)
│            Location = Column(String(100))
│            Status = Column(String(20))  # e.g., "Active", "Inactive"
│            Type = Column(String(50))    # e.g., "ESP32", "Raspberry Pi"
│        
│            # Relationships
│            sensors = relationship("Sensor", back_populates="device", cascade="all, delete-orphan")
│            sensor_data = relationship("SensorData", secondary="sensors", viewonly=True)
│            user_interactions = relationship("UserInteraction", back_populates="device", cascade="all, delete-orphan")
│            kalman_fusions = relationship("KalmanFilterFusionData", back_populates="device", cascade="all, delete-orphan")
│            weighted_fusions = relationship("WeightedAverageFusionData", back_populates="device", cascade="all, delete-orphan")
│        
│        # Sensors Table
│        class Sensor(Base):
│            __tablename__ = "sensors"
│        
│            SensorID = Column(Integer, primary_key=True)
│            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
│            SensorType = Column(String(50))  # e.g., "DHT", "SoilMoisture"
│            SensorIndex = Column(Integer)    # To distinguish multiple sensors of same type
│            Location = Column(String(100))   # e.g., "Top Left"
│            Status = Column(String(20), default="Active")
│        
│            device = relationship("Device", back_populates="sensors")
│            sensor_data = relationship("SensorData", back_populates="sensor", cascade="all, delete-orphan")
│        
│        # SensorData Table
│        class SensorData(Base):
│            __tablename__ = "sensor_data"
│        
│            DataID = Column(Integer, primary_key=True)
│            SensorID = Column(Integer, ForeignKey("sensors.SensorID"), nullable=False)
│            Timestamp = Column(DateTime, default=datetime.utcnow)
│            Value = Column(Float, nullable=False)
│        
│            sensor = relationship("Sensor", back_populates="sensor_data")
│        
│        # UserInteractions Table
│        class UserInteraction(Base):
│            __tablename__ = "user_interactions"
│        
│            InteractionID = Column(Integer, primary_key=True)
│            UserID = Column(Integer)
│            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
│            ActuatorID = Column(Integer, ForeignKey("actuators.ActuatorID"))  # Optional, if interaction is with an actuator
│            Action = Column(String(20), nullable=False)  # e.g., "Turn On", "Turn Off"
│            Timestamp = Column(DateTime, default=datetime.utcnow)
│        
│            device = relationship("Device", back_populates="user_interactions")
│        
│        # Kalman Filter Fusion Table
│        class KalmanFilterFusionData(Base):
│            __tablename__ = "kalman_filter_fusion"
│        
│            FusionID = Column(Integer, primary_key=True)
│            SensorID = Column(Integer, ForeignKey("kalmanFilterFusionData.SensorID"), nullable=False)
│            Timestamp = Column(DateTime, default=datetime.utcnow)
│            FusedValue = Column(Float, nullable=False)
│        
│        
│            sensor = relationship("Sensor", back_populates="kalmanFilterFusionData"
│        
│        # Weighted Average Fusion Table
│        class WeightedAverageFusionData(Base):
│            __tablename__ = "weighted_average_fusion"
│        
│            FusionID = Column(Integer, primary_key=True)
│            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
│            SensorType = Column(String(50))  # Optional
│            Timestamp = Column(DateTime, default=datetime.utcnow)
│            FusedValue = Column(Float, nullable=False)
│        
│            device = relationship("Device", back_populates="weighted_fusions")
│        
│        # Actuators Table
│        class Actuator(Base):
│            __tablename__ = "actuators"
│        
│            ActuatorID = Column(Integer, primary_key=True)
│            ActuatorName = Column(String(50), nullable=False, unique=True)
│            Status = Column(String(20), nullable=False)  # e.g., "On", "Off"
│            LastUpdated = Column(DateTime, default=datetime.utcnow)
│            UserID = Column(Integer)  # Refers to the user who last updated it
│        
│            def __repr__(self):
│                return f"<Actuator(Name={self.ActuatorName}, Status={self.Status})>"
│        
│        # Create all tables
│        Base.metadata.create_all(engine)
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── everything.txt.txt
│        ↓↓↓ FILE CONTENT ↓↓↓
│        │        <h1>Greenhouse Monitoring Dashboard</h1>
│        │
│        │        <div id="temperature_chart"></div>
│        │        <div id="humidity_chart"></div>
│        │        <div id="soil_moisture_chart"></div>
│        │
│        │        <script>
│        │            function updateDashboard() {
│        │                $.getJSON("/data", function(data) {
│        │                    let time = data.time;
│        │
│        │                    // Temperature Chart
│        │                    let temperature_traces = [];
│        │                    for (let i = 0; i < 4; i++) {
│        │                        temperature_traces.push({
│        │                            x: time,
│        │                            y: data.temperature[i],
│        │                            mode: 'lines',
│        │                            name: 'Temp ' + (i+1)
│        │                        });
│        │                    }
│        │                    Plotly.react('temperature_chart', temperature_traces, { title: 'Temperature Over Time' });
│        │
│        │                    // Humidity Chart
│        │                    let humidity_traces = [];
│        │                    for (let i = 0; i < 4; i++) {
│        │                        humidity_traces.push({
│        │                            x: time,
│        │                            y: data.humidity[i],
│        │                            mode: 'lines',
│        │                            name: 'Humidity ' + (i+1)
│        │                        });
│        │                    }
│        │                    Plotly.react('humidity_chart', humidity_traces, { title: 'Humidity Over Time' });
│        │
│        │                    // Soil Moisture Chart
│        │                    let soil_moisture_traces = [];
│        │                    for (let i = 0; i < 2; i++) {
│        │                        soil_moisture_traces.push({
│        │                            x: time,
│        │                            y: data.soil_moisture[i],
│        │                            mode: 'lines',
│        │                            name: 'Soil Moisture ' + (i+1)
│        │                        });
│        │                    }
│        │                    Plotly.react('soil_moisture_chart', soil_moisture_traces, { title: 'Soil Moisture Over Time' });
│        │                });
│        │            }
│        │
│        │            // Update dashboard every 5 seconds
│        │            setInterval(updateDashboard, 50000);
│        │            updateDashboard();
│        │        </script>
│        │
│        │
│        │        {% endblock %} -->
│        │        ↑↑↑ END OF FILE ↑↑↑
│        
│        │   ├── dashboardupgrade.py
│        │        ↓↓↓ FILE CONTENT ↓↓↓
│        │        from flask import Blueprint, jsonify
│        │        import json
│        │        import os
│        │        import time
│        │
│        │        dashboard_bp = Blueprint("dashboard", __name__)
│        │
│        │        # File to store the last known data
│        │        DATA_FILE = "last_data.json"
│        │
│        │        # Function to load the last known data
│        │        def load_last_data():
│        │            if os.path.exists(DATA_FILE):
│        │                with open(DATA_FILE, "r") as f:
│        │                    return json.load(f)
│        │            return {
│        │                "time": [],
│        │                "temperature": [[] for _ in range(6)],
│        │                "humidity": [[] for _ in range(6)],
│        │                "soil_moisture": [[] for _ in range(4)]
│        │            }
│        │
│        │        # Function to save data
│        │        def save_data(data):
│        │            with open(DATA_FILE, "w") as f:
│        │                json.dump(data, f)
│        │
│        │        # Global variable to store last known data
│        │        last_data = load_last_data()
│        │        last_update_time = time.time()
│        │
│        │        @dashboard_bp.route("/data")
│        │        def get_data():
│        │            global last_data, last_update_time
│        │
│        │            new_data = fetch_sensor_data()  # Replace this with your actual function
│        │
│        │            if new_data:  # If there's new data, update the stored data
│        │                last_data = new_data
│        │                last_update_time = time.time()
│        │                save_data(last_data)  # Save updated data
│        │
│        │            return jsonify(last_data)
│        │
│        │        def fetch_sensor_data():
│        │            """
│        │            Simulates getting new sensor data.
│        │            Replace this with your actual function that gets data from sensors.
│        │            Returns None if no new data.
│        │            """
│        │            # Simulated condition where sometimes no new data arrives
│        │            if time.time() - last_update_time < 10:  # Assume no new data within 10 sec
│        │                return None
│        │
│        │            # Simulated new data (Replace with real sensor data fetching)
│        │            return {
│        │                "time": ["2025-02-22 12:00:00"],  # Add real timestamp
│        │                "temperature": [[22.3, 22.5, 22.7, 22.6, 22.8, 22.9]],
│        │                "humidity": [[50, 51, 49, 48, 52, 50]],
│        │                "soil_moisture": [[30, 32, 29, 31]]
│        │            }
│        │        ↑↑↑ END OF FILE ↑↑↑
│        
│        │   ├── data_retrival.py
│        │        ↓↓↓ FILE CONTENT ↓↓↓
│        │        from sqlalchemy.orm import sessionmaker
│        │        from database_setup import engine, SensorData,UserInteraction
│        │        import pandas as pd
│        │
│        │        # this could also be used for sensor fusion
│        │
│        │        #  Create session
│        │        Session = sessionmaker(bind=engine)
│        │        session = Session()
│        │
│        │        #  Fetch all readings as a list of dictionaries
│        │        data = session.query(UserInteraction).all()
│        │
│        │        # Convert SQLAlchemy objects to dictionaries
│        │        result_list = [
│        │            {"DeviceID": d.DeviceID, "UserID": d.UserID, "Action": d.Action, "Timestamp": d.Timestamp}
│        │            for d in data
│        │        ]
│        │
│        │        #  Close session
│        │        session.close()
│        │
│        │        print("\n Retrieved Sensor Readings List:")
│        │        print(result_list)
│        │        # data=result_list
│        │        # # Convert to Pandas DataFrame
│        │        # df = pd.DataFrame(data)
│        │
│        │        # # Convert 'Timestamp' column to datetime format (if needed)
│        │        # df['Timestamp'] = pd.to_datetime(df['Timestamp'])
│        │
│        │        # # Convert Timestamp to datetime
│        │        # df["Timestamp"] = pd.to_datetime(df["Timestamp"])
│        │
│        │        # # Pivot the table to restructure data
│        │        # df_pivot = df.pivot_table(index=["Timestamp", "DeviceID"], columns="SensorType", values="Value", aggfunc="first")
│        │
│        │        # # Rename columns explicitly to match the required output
│        │        # df_pivot.columns = df_pivot.columns.rename(None)  # Remove MultiIndex column names
│        │        # df_pivot.rename(columns={
│        │        #     "temperature": "temperature",
│        │        #     "humidity": "humidity",
│        │        #     "soil_moisture": "soil_moisture"
│        │        # }, inplace=True)
│        │
│        │        # # Reset index to bring columns back
│        │        # df_pivot.reset_index(inplace=True)
│        │
│        │        # # Rename Timestamp to time
│        │        # df_pivot.rename(columns={"Timestamp": "time"}, inplace=True)
│        │
│        │        # # Display result
│        │        # print(df_pivot)
│        │        ↑↑↑ END OF FILE ↑↑↑
│        
│        │   ├── database_setup.py
│        │        ↓↓↓ FILE CONTENT ↓↓↓
│        │        from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, ForeignKey
│        │        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
│        │        from datetime import datetime
│        │
│        │        # Database connection
│        │        DATABASE_URL = "sqlite:///greenhouse.db"
│        │        engine = create_engine(DATABASE_URL, echo=True)
│        │
│        │        # Create session factory
│        │        SessionLocal = sessionmaker(bind=engine)
│        │
│        │        #  Base Model
│        │        class Base(DeclarativeBase):
│        │            pass
│        │
│        │        #  Devices Table
│        │        class Device(Base):
│        │            __tablename__ = "devices"
│        │
│        │            DeviceID = Column(Integer, primary_key=True)
│        │            DeviceName = Column(String(50), nullable=False)
│        │            Location = Column(String(100))
│        │            Status = Column(String(20))  # e.g., "Active", "Inactive"
│        │            Type = Column(String(50))  # e.g., "ESP32", "Raspberry Pi"
│        │
│        │            sensor_data = relationship("SensorData", back_populates="device")
│        │            user_interactions = relationship("UserInteraction", back_populates="device")
│        │
│        │        #  SensorData Table
│        │        class SensorData(Base):
│        │            __tablename__ = "sensor_data"
│        │
│        │            DataID = Column(Integer, primary_key=True)
│        │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
│        │            Timestamp = Column(DateTime, default=datetime.utcnow)
│        │            SensorType = Column(String(50))  # e.g., "temperature", "humidity"
│        │            Value = Column(Float)  # Sensor reading value
│        │
│        │            device = relationship("Device", back_populates="sensor_data")
│        │
│        │        #  UserInteractions Table
│        │        class UserInteraction(Base):
│        │            __tablename__ = "user_interactions"
│        │
│        │            InteractionID = Column(Integer, primary_key=True)
│        │            UserID = Column(Integer)  # Assuming users are stored elsewhere
│        │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"))
│        │            Action = Column(String(20), nullable=False)  # e.g., "Turn On", "Turn Off"
│        │            Timestamp = Column(DateTime, default=datetime.utcnow)
│        │
│        │            device = relationship("Device", back_populates="user_interactions")
│        │
│        │        #  Create Tables in SQLite
│        │        Base.metadata.create_all(engine)
│        │        ↑↑↑ END OF FILE ↑↑↑
│        
│        │   ├── database_setups.py
│        │        ↓↓↓ FILE CONTENT ↓↓↓
│        │        from sqlalchemy import (
│        │            create_engine, Column, Integer, Float, String, DateTime, ForeignKey
│        │        )
│        │        from sqlalchemy.orm import relationship, sessionmaker, DeclarativeBase
│        │        from datetime import datetime
│        │
│        │        # Database connection
│        │        DATABASE_URL = "sqlite:///greenhouse.db"
│        │        engine = create_engine(DATABASE_URL, echo=True)
│        │        SessionLocal = sessionmaker(bind=engine)
│        │
│        │        # Base class
│        │        class Base(DeclarativeBase):
│        │            pass
│        │
│        │        # Devices Table
│        │        class Device(Base):
│        │            __tablename__ = "devices"
│        │
│        │            DeviceID = Column(Integer, primary_key=True)
│        │            DeviceName = Column(String(50), nullable=False)
│        │            Location = Column(String(100))
│        │            Status = Column(String(20))  # e.g., "Active", "Inactive"
│        │            Type = Column(String(50))    # e.g., "ESP32", "Raspberry Pi"
│        │
│        │            # Relationships
│        │            sensors = relationship("Sensor", back_populates="device", cascade="all, delete-orphan")
│        │            sensor_data = relationship("SensorData", secondary="sensors", viewonly=True)
│        │            user_interactions = relationship("UserInteraction", back_populates="device", cascade="all, delete-orphan")
│        │            kalman_fusions = relationship("KalmanFilterFusionData", back_populates="device", cascade="all, delete-orphan")
│        │            weighted_fusions = relationship("WeightedAverageFusionData", back_populates="device", cascade="all, delete-orphan")
│        │
│        │        # Sensors Table
│        │        class Sensor(Base):
│        │            __tablename__ = "sensors"
│        │
│        │            SensorID = Column(Integer, primary_key=True)
│        │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
│        │            SensorType = Column(String(50))  # e.g., "DHT", "SoilMoisture"
│        │            SensorIndex = Column(Integer)    # To distinguish multiple sensors of same type
│        │            Location = Column(String(100))   # e.g., "Top Left"
│        │            Status = Column(String(20), default="Active")
│        │
│        │            device = relationship("Device", back_populates="sensors")
│        │            sensor_data = relationship("SensorData", back_populates="sensor", cascade="all, delete-orphan")
│        │
│        │        # SensorData Table
│        │        class SensorData(Base):
│        │            __tablename__ = "sensor_data"
│        │
│        │            DataID = Column(Integer, primary_key=True)
│        │            SensorID = Column(Integer, ForeignKey("sensors.SensorID"), nullable=False)
│        │            Timestamp = Column(DateTime, default=datetime.utcnow)
│        │            Value = Column(Float, nullable=False)
│        │
│        │            sensor = relationship("Sensor", back_populates="sensor_data")
│        │
│        │        # UserInteractions Table
│        │        class UserInteraction(Base):
│        │            __tablename__ = "user_interactions"
│        │
│        │            InteractionID = Column(Integer, primary_key=True)
│        │            UserID = Column(Integer)
│        │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
│        │            ActuatorID = Column(Integer, ForeignKey("actuators.ActuatorID"))  # Optional, if interaction is with an actuator
│        │            Action = Column(String(20), nullable=False)  # e.g., "Turn On", "Turn Off"
│        │            Timestamp = Column(DateTime, default=datetime.utcnow)
│        │
│        │            device = relationship("Device", back_populates="user_interactions")
│        │
│        │        # Kalman Filter Fusion Table
│        │        class KalmanFilterFusionData(Base):
│        │            __tablename__ = "kalman_filter_fusion"
│        │
│        │            FusionID = Column(Integer, primary_key=True)
│        │            SensorID = Column(Integer, ForeignKey("kalmanFilterFusionData.SensorID"), nullable=False)
│        │            Timestamp = Column(DateTime, default=datetime.utcnow)
│        │            FusedValue = Column(Float, nullable=False)
│        │
│        │
│        │            sensor = relationship("Sensor", back_populates="kalmanFilterFusionData"
│        │
│        │        # Weighted Average Fusion Table
│        │        class WeightedAverageFusionData(Base):
│        │            __tablename__ = "weighted_average_fusion"
│        │
│        │            FusionID = Column(Integer, primary_key=True)
│        │            DeviceID = Column(Integer, ForeignKey("devices.DeviceID"), nullable=False)
│        │            SensorType = Column(String(50))  # Optional
│        │            Timestamp = Column(DateTime, default=datetime.utcnow)
│        │            FusedValue = Column(Float, nullable=False)
│        │
│        │            device = relationship("Device", back_populates="weighted_fusions")
│        │
│        │        # Actuators Table
│        │        class Actuator(Base):
│        │            __tablename__ = "actuators"
│        │
│        │            ActuatorID = Column(Integer, primary_key=True)
│        │            ActuatorName = Column(String(50), nullable=False, unique=True)
│        │            Status = Column(String(20), nullable=False)  # e.g., "On", "Off"
│        │            LastUpdated = Column(DateTime, default=datetime.utcnow)
│        │            UserID = Column(Integer)  # Refers to the user who last updated it
│        │
│        │            def __repr__(self):
│        │                return f"<Actuator(Name={self.ActuatorName}, Status={self.Status})>"
│        │
│        │        # Create all tables
│        │        Base.metadata.create_all(engine)
│        │        ↑↑↑ END OF FILE ↑↑↑
│        
│        │   ├── indexprev.html
│        │        ↓↓↓ FILE CONTENT ↓↓↓
│        │        {% extends "base.html" %}
│        │
│        │        {% block content %}
│        │        <div class="container">
│        │            <h1>Welcome to the AI driven Greenhouse</h1>
│        │            <p>Monitor and control your greenhouse environment remotely.</p>
│        │        </div>
│        │
│        │        <div class="container">
│        │            <h1>Surveillance</h1>
│        │            <p>Two cameras for monitoring.</p>
│        │        </div>
│        │
│        │        <div class="container">
│        │            <img id="camera-stream" src="http://192.168.1.24:81/stream" width="400" height="400" alt="ESP32-CAM Stream" onerror="this.onerror=null; this.src='static/no-signal.jpg';">
│        │        </div>
│        │
│        │        {% endblock %}
│        │        ↑↑↑ END OF FILE ↑↑↑
│        
│        │   ├── network.py
│        │        ↓↓↓ FILE CONTENT ↓↓↓
│        │        from flask import request, jsonify
│        │        from database_setup import SessionLocal, SensorData, Device,UserInteraction
│        │        from datetime import datetime
│        │
│        │        # Device (Microcontrollers) authentication credentials for sending sensor data to the server
│        │        credentials = {
│        │            "esp_Temp_humid_1": "esp_password",
│        │            "esp_Soil_moisture_1": "esp_password"
│        │        }
│        │
│        │        def action_based_on_sensor(DeviceName, temperature=0, humidity=0, soil_moisture=0):
│        │            session = SessionLocal()
│        │            try:
│        │                if DeviceName == "esp_Temp_humid_1" and temperature > 30:
│        │                    session.add(UserInteraction(DeviceID=11, UserID=5000, Action="blink_led", Timestamp=datetime.utcnow()))
│        │                    session.commit()
│        │                    return "blink_led"
│        │
│        │                elif DeviceName == "esp_Soil_moisture_1" and soil_moisture > 30:
│        │                    session.add(UserInteraction(DeviceID=12, UserID=5000, Action="blink_led", Timestamp=datetime.utcnow()))
│        │                    session.commit()
│        │                    return "blink_led"
│        │
│        │                return "no_action"
│        │
│        │            finally:
│        │                session.close()
│        │
│        │
│        │
│        │        def store_sensor_data(device_id, DeviceName, temperature=None, humidity=None, soil_moisture=None):
│        │            session = SessionLocal()
│        │
│        │            # Ensure device exists in the database
│        │            device = session.query(Device).filter_by(DeviceID=device_id).first()
│        │            if not device:
│        │                device = Device(DeviceID=device_id, DeviceName=DeviceName, Type="ESP32", Location="Unknown", Status="Active")
│        │                session.add(device)
│        │                session.commit()
│        │                session.refresh(device)  # Ensure we have the latest DeviceID
│        │
│        │            # Store sensor readings for the specific device ID received from ESP
│        │            if temperature is not None and device_id in {1, 2, 3}:
│        │                session.add(SensorData(DeviceID=device_id, SensorType="temperature", Value=temperature, Timestamp=datetime.utcnow()))
│        │
│        │            if humidity is not None and device_id in {4, 5, 6}:
│        │                session.add(SensorData(DeviceID=device_id, SensorType="humidity", Value=humidity, Timestamp=datetime.utcnow()))
│        │
│        │            if soil_moisture is not None and device_id in {7, 8}:
│        │                session.add(SensorData(DeviceID=device_id, SensorType="soil_moisture", Value=soil_moisture, Timestamp=datetime.utcnow()))
│        │
│        │            session.commit()
│        │            session.close()
│        │
│        │        def receive_sensor_data(request):
│        │            # Get Authorization header
│        │            auth = request.authorization
│        │            if not auth or credentials.get(auth.username) != auth.password:
│        │                return jsonify({"error": "Unauthorized"}), 401
│        │
│        │            try:
│        │                data = request.json
│        │                if not data:
│        │                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
│        │
│        │                device_id = data.get('DeviceID')  # This is an integer
│        │                DeviceName = data.get('DeviceName')  # This is a string
│        │                temperature = data.get('temperature')
│        │                humidity = data.get('humidity')
│        │                soil_moisture = data.get('soil_moisture')  # Fixed key
│        │
│        │                if not device_id or not DeviceName:
│        │                    return jsonify({"error": "Missing 'DeviceID' or 'DeviceName' in payload"}), 400
│        │
│        │                print(f"Received JSON payload: {data}")
│        │
│        │                # Store the data in the database
│        │                store_sensor_data(device_id, DeviceName, temperature, humidity, soil_moisture)
│        │
│        │                # Determine action based on sensor data
│        │                action = action_based_on_sensor(DeviceName, temperature, humidity, soil_moisture)
│        │
│        │                response = {"DeviceName": DeviceName, "action": action}
│        │                return jsonify(response)
│        │
│        │            except Exception as e:
│        │                print(f"Error processing request: {e}")
│        │                return jsonify({"error": "Internal Server Error"}), 500
│        │        ↑↑↑ END OF FILE ↑↑↑
│        
│        │   ├── newer_network.py
│        │        ↓↓↓ FILE CONTENT ↓↓↓
│        │        from flask import request, jsonify
│        │        import time
│        │        from sqlalchemy import desc
│        │        from datetime import datetime
│        │        from sqlalchemy.orm import Session
│        │        from database_setup import (
│        │            SessionLocal, SensorData, Sensor, Device, UserInteraction,
│        │            Actuator, WeightedAverageFusionData, KalmanFilterFusionData
│        │        )
│        │        from weightedAverage import process_weighted_fusion
│        │
│        │        # Authentication credentials for devices
│        │        credentials = {
│        │            "Ventilation_System_ESP": "password",
│        │            "Irrigation_System_ESP": "password",
│        │            "web_control": "web_password"
│        │        }
│        │
│        │        # Constants
│        │        DEFAULT_USER_ID = 5000  # Server user
│        │        TEMP_THRESHOLD = 30
│        │        HUM_THRESHOLD = 40
│        │        SOIL_MOISTURE_THRESHOLD = 30
│        │
│        │        TEMP_SENSOR_IDS = [2099, 2092, 3093]
│        │        HUM_SENSOR_IDS = [2091, 2034, 3027]
│        │        WEIGHTS = [0.5, 0.3, 0.2]
│        │
│        │        # Actuator Names
│        │        INTAKE_SHUTTER = "intake_shutter"
│        │        WATER_PUMP = "water_pump"
│        │        VENTILATION_FAN = "ventilation_fan"
│        │
│        │        # Device IDs
│        │        Ventilation_System_ESP_ID = 2000
│        │        Irrigation_System_ESP_ID = 3000
│        │
│        │        soil_sensor_1id = 2005
│        │        soil_sensor_2id = 3002
│        │
│        │
│        │        def get_fused_values_by_sensors(session: Session, *sensor_ids: int):
│        │            fused_values = {}
│        │
│        │            if not sensor_ids:
│        │                return fused_values  # No IDs provided → return empty
│        │
│        │            for sensor_id in sensor_ids:
│        │                if sensor_id is None:
│        │                    continue
│        │                fusion = (
│        │                    session.query(KalmanFilterFusionData)
│        │                    .filter_by(SensorID=sensor_id)
│        │                    .order_by(desc(KalmanFilterFusionData.Timestamp))
│        │                    .first()
│        │                )
│        │                if fusion:
│        │                    fused_values[sensor_id] = fusion.FusedValue
│        │
│        │            return fused_values
│        │
│        │
│        │        def log_user_action(session, device_id, action, user_id, actuator_id):
│        │            session.add(UserInteraction(
│        │                DeviceID=device_id,
│        │                Action=action,
│        │                UserID=user_id,
│        │                ActuatorID=actuator_id,
│        │                Timestamp=datetime.utcnow()
│        │            ))
│        │
│        │
│        │        def control_actuator(session, actuator_name, status, user_id):
│        │            actuator = session.query(Actuator).filter_by(ActuatorName=actuator_name).first()
│        │            if not actuator:
│        │                actuator = Actuator(
│        │                    ActuatorName=actuator_name,
│        │                    Status=status,
│        │                    LastUpdated=datetime.utcnow(),
│        │                    UserID=user_id
│        │                )
│        │                session.add(actuator)
│        │            else:
│        │                if actuator.Status != status:
│        │                    actuator.Status = status
│        │                    actuator.LastUpdated = datetime.utcnow()
│        │                    actuator.UserID = user_id
│        │                    log_user_action(
│        │                        session,
│        │                        device_id=actuator.ActuatorID,
│        │                        action=f"{actuator_name}_{status.lower()}",
│        │                        user_id=user_id,
│        │                        actuator_id=actuator.ActuatorID
│        │                    )
│        │            session.commit()
│        │            return actuator
│        │
│        │
│        │        def get_latest_fused_temperature_humidity(session):
│        │            latest_temp = session.query(WeightedAverageFusionData).filter_by(
│        │                SensorType="temperature").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
│        │            latest_hum = session.query(WeightedAverageFusionData).filter_by(
│        │                SensorType="humidity").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
│        │
│        │            return {
│        │                "temperature": latest_temp.FusedValue if latest_temp else None,
│        │                "humidity": latest_hum.FusedValue if latest_hum else None
│        │            }
│        │
│        │
│        │        def action_based_on_sensor(user_id=DEFAULT_USER_ID):
│        │            with SessionLocal() as session:
│        │                result = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
│        │                soil1 = result.get(soil_sensor_1id)
│        │                soil2 = result.get(soil_sensor_2id)
│        │
│        │                soil_moisture = None
│        │                if soil1 is not None and soil2 is not None:
│        │                    average = (soil1 + soil2) / 2
│        │                    if 0 <= average <= 100:
│        │                        soil_moisture = average
│        │                elif soil1 is not None:
│        │                    if 0 <= soil1 <= 100:
│        │                        soil_moisture = soil1
│        │                elif soil2 is not None:
│        │                    if 0 <= soil2 <= 100:
│        │                        soil_moisture = soil2
│        │                # Else → soil_moisture stays None
│        │
│        │                temperature=process_weighted_fusion(sensor_ids=TEMP_SENSOR_IDS, weights=WEIGHTS, sensor_type="Temperature")
│        │
│        │                # Call for humidity
│        │                humidity=process_weighted_fusion(sensor_ids=HUM_SENSOR_IDS, weights=WEIGHTS, sensor_type="Humidity")
│        │
│        │                actions = []
│        │
│        │                try:
│        │                    if temperature is not None and humidity is not None:
│        │                        if temperature > TEMP_THRESHOLD or humidity > HUM_THRESHOLD:
│        │                            control_actuator(session, VENTILATION_FAN, "on", user_id)
│        │                            control_actuator(session, INTAKE_SHUTTER, "on", user_id)
│        │                            actions.append("Ventilation_ON")
│        │                        elif temperature < TEMP_THRESHOLD and humidity < HUM_THRESHOLD:
│        │                            control_actuator(session, VENTILATION_FAN, "off", user_id)
│        │                            control_actuator(session, INTAKE_SHUTTER, "off", user_id)
│        │                            actions.append("Ventilation_OFF")
│        │
│        │                    if soil_moisture is not None:
│        │                        if soil_moisture < SOIL_MOISTURE_THRESHOLD:
│        │                            control_actuator(session, WATER_PUMP, "on", user_id)
│        │                            actions.append("Irrigation_ON")
│        │                        else:
│        │                            control_actuator(session, WATER_PUMP, "off", user_id)
│        │                            actions.append("Irrigation_OFF")
│        │
│        │                    session.commit()
│        │                    return ", ".join(actions) if actions else "none"
│        │                except Exception as e:
│        │                    session.rollback()
│        │                    print(f"[ERROR] Failed to perform action: {e}")
│        │                    return "error"
│        │
│        │
│        │
│        │        def get_or_create_device(session, device_id, device_name):
│        │            device = session.query(Device).filter_by(DeviceID=device_id).first()
│        │            if not device:
│        │                device = Device(DeviceID=device_id, DeviceName=device_name, Location="Unknown", Status="Active")
│        │                session.add(device)
│        │                session.commit()
│        │                session.refresh(device)
│        │            return device
│        │
│        │
│        │        def get_or_create_sensor(session,sensor_id, device_id, sensor_type):
│        │            sensor = session.query(Sensor).filter_by(SensorID=sensor_id, SensorType=sensor_type).first()
│        │            if not sensor:
│        │                sensor = Sensor(SensorID=sensor_id, DeviceID=device_id, SensorType=sensor_type, Location="Unknown", Status="Active")
│        │                session.add(sensor)
│        │                session.commit()
│        │                session.refresh(sensor)
│        │            return sensor
│        │
│        │
│        │        def store_sensor_value(session, sensor, value):
│        │            session.add(SensorData(SensorID=sensor.SensorID, Value=value, Timestamp=datetime.utcnow()))
│        │
│        │
│        │        def store_sensor_data(device_id, device_name,sensor_id,
│        │                              temperature=None, filtered_temperature=None,
│        │                              humidity=None, filtered_humidity=None,
│        │                              soil_moisture=None, filtered_soil_moisture=None):
│        │            with SessionLocal() as session:
│        │                try:
│        │                    get_or_create_device(session, device_id, device_name)
│        │
│        │                    if temperature is not None:
│        │                        sensor = get_or_create_sensor(session, device_id, "temperature")
│        │                        store_sensor_value(session, sensor, temperature)
│        │
│        │                    if filtered_temperature is not None:
│        │                        sensor = get_or_create_sensor(session, device_id, "temperature_filtered")
│        │                        store_sensor_value(session, sensor, filtered_temperature)
│        │
│        │                    if humidity is not None:
│        │                        sensor = get_or_create_sensor(session, device_id, "humidity")
│        │                        store_sensor_value(session, sensor, humidity)
│        │
│        │                    if filtered_humidity is not None:
│        │                        sensor = get_or_create_sensor(session, device_id, "humidity_filtered")
│        │                        store_sensor_value(session, sensor, filtered_humidity)
│        │
│        │                    if soil_moisture is not None:
│        │                        sensor = get_or_create_sensor(session, device_id, "soil_moisture")
│        │                        store_sensor_value(session, sensor, soil_moisture)
│        │
│        │                    if filtered_soil_moisture is not None:
│        │                        sensor = get_or_create_sensor(session, device_id, "soil_moisture_filtered")
│        │                        store_sensor_value(session, sensor, filtered_soil_moisture)
│        │
│        │                    session.commit()
│        │                except Exception as e:
│        │                    session.rollback()
│        │                    print(f"[ERROR] Failed to store sensor data: {e}")
│        │
│        │
│        │        def receive_sensor_data(request):
│        │            auth = request.authorization
│        │            if not auth or credentials.get(auth.username) != auth.password:
│        │                return jsonify({"error": "Unauthorized"}), 401
│        │
│        │            try:
│        │                data = request.get_json()
│        │                if not data:
│        │                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
│        │
│        │                device_id = data.get('DeviceID')
│        │                device_name = data.get('DeviceName')
│        │                sensor_id = data.get('SensorID')
│        │                if not device_id or not device_name:
│        │                    return jsonify({"error": "Missing DeviceID or DeviceName"}), 400
│        │
│        │                temperature = data.get('temperature')
│        │                filtered_temperature = data.get('filtered_temperature')
│        │                humidity = data.get('humidity')
│        │                filtered_humidity = data.get('filtered_humidity')
│        │                soil_moisture = data.get('soil_moisture')
│        │                filtered_soil_moisture = data.get('filtered_soil_moisture')
│        │
│        │                store_sensor_data(device_id, device_name,sensor_id,
│        │                                  temperature, filtered_temperature,
│        │                                  humidity, filtered_humidity,
│        │                                  soil_moisture, filtered_soil_moisture)
│        │
│        │                print(f"[INFO] Received data from DeviceID: {device_id}, SensorID: {sensor_id}")
│        │                # Optional: wait for fusion update to complete if it's not sync
│        │                time.sleep(5)
│        │
│        │                action_result = action_based_on_sensor()
│        │
│        │                with SessionLocal() as session:
│        │                    latest = get_latest_fused_temperature_humidity(session)
│        │                    soil_data = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
│        │                    avg_soil = None
│        │                    if soil_data:
│        │                        values = list(soil_data.values())
│        │                        avg_soil = sum(values) / len(values) if values else None
│        │
│        │                return jsonify({
│        │                    "status": "success",
│        │                    "action": action_result,
│        │                    "temperature": latest["temperature"],
│        │                    "humidity": latest["humidity"],
│        │                    "soil_moisture": avg_soil
│        │                }), 200
│        │
│        │            except Exception as e:
│        │                print(f"[ERROR] Failed to receive/process sensor data: {e}")
│        │                return jsonify({"error": "Internal Server Error"}), 500
│        │        ↑↑↑ END OF FILE ↑↑↑
│        
│        │   └── old_network.py
│        │        ↓↓↓ FILE CONTENT ↓↓↓
│        │        from flask import request, jsonify
│        │        from webdevelopment.database_setup import SessionLocal, SensorData, Device, UserInteraction, Actuator, WeightedAverageFusionData
│        │        from datetime import datetime
│        │        from webdevelopment.weightedAverage import process_weighted_fusion
│        │
│        │        # Authentication credentials for devices
│        │        credentials = {
│        │            "Ventilation_System_ESP ": "password",
│        │            "Irrigation_System_ESP": "password"
│        │        }
│        │
│        │        # Constants
│        │        DEFAULT_USER_ID = 5000  # Server user
│        │        TEMP_THRESHOLD = 30
│        │        HUM_THRESHOLD = 40
│        │        SOIL_MOISTURE_THRESHOLD = 30
│        │
│        │        # Actuator Names
│        │        INTAKE_SHUTTER = "intake_shutter"
│        │        WATER_PUMP = "water_pump"
│        │        VENTILATION_FAN = "ventilation_fan"
│        │
│        │        # Device Names
│        │        Ventilation_System_ESP = 1111
│        │        Irrigation_System_ESP = 2222
│        │
│        │
│        │        def log_user_action(session, device_id, action, user_id):
│        │            interaction = UserInteraction(
│        │                DeviceID=device_id,
│        │                Action=action,
│        │                UserID=user_id,
│        │                Timestamp=datetime.utcnow()
│        │            )
│        │            session.add(interaction)
│        │
│        │
│        │        def control_actuator(session, actuator_name, status, user_id):
│        │            actuator = session.query(Actuator).filter_by(ActuatorName=actuator_name).first()
│        │            if not actuator:
│        │                actuator = Actuator(ActuatorName=actuator_name, Status=status, LastUpdated=datetime.utcnow(), UserID=user_id)
│        │                session.add(actuator)
│        │            else:
│        │                actuator.Status = status
│        │                actuator.LastUpdated = datetime.utcnow()
│        │                actuator.UserID = user_id
│        │
│        │            # Log who triggered this actuator
│        │            log_user_action(session, device_id=actuator.ActuatorID, action=f"{actuator_name}_{status.lower()}", user_id=user_id)
│        │            return True
│        │
│        │
│        │        def action_based_on_sensor(DeviceName, temperature=0, humidity=0, soil_moisture=0, user_id=DEFAULT_USER_ID):
│        │            session = SessionLocal()
│        │
│        │            try:
│        │                if  temperature > TEMP_THRESHOLD or humidity > HUM_THRESHOLD:
│        │
│        │                    control_actuator(session, VENTILATION_FAN, "On", user_id)
│        │                    control_actuator(session, INTAKE_SHUTTER, "On", user_id)
│        │                    log_user_action(session, Ventilation_System_ESP,"On", user_id)
│        │                    log_user_action(session, INTAKE_SHUTTER,"On", user_id)
│        │                    action_taken = "VENTILATION_System_on"
│        │
│        │
│        │                elif soil_moisture < SOIL_MOISTURE_THRESHOLD:
│        │                    control_actuator(session, WATER_PUMP, "On", user_id)
│        │                    log_user_action(session, Irrigation_System_ESP, "On", user_id)
│        │                    action_taken = "Irrigation_System_on"
│        │
│        │                session.commit()
│        │                return action_taken
│        │
│        │            except Exception as e:
│        │                session.rollback()
│        │                print(f"[ERROR] Failed to perform action: {e}")
│        │                return "error"
│        │
│        │            finally:
│        │                session.close()
│        │
│        │
│        │        def store_sensor_data(device_id, DeviceName, temperature=None, filtered_temperature=None, humidity=None, filtered_humidity=None, soil_moisture=None, filtered_soil_moisture= None):
│        │            session = SessionLocal()
│        │
│        │            try:
│        │                # Ensure device exists
│        │                device = session.query(Device).filter_by(DeviceID=device_id).first()
│        │                if not device:
│        │                    device = Device(DeviceID=device_id, DeviceName=DeviceName, Type="ESP32", Location="Unknown", Status="Active")
│        │                    session.add(device)
│        │                    session.commit()
│        │                    session.refresh(device)
│        │
│        │                # Store relevant sensor data
│        │                if temperature is not None and device_id in {1, 2, 3, 4}:
│        │                    session.add(SensorData(DeviceID=device_id, SensorType="temperature", Value=temperature, Timestamp=datetime.utcnow()))
│        │                if filtered_temperature is not None and device_id in {1, 2, 3, 4}:
│        │                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
│        │                if humidity is not None and device_id in {5, 6, 7, 8}:
│        │                    session.add(SensorData(DeviceID=device_id, SensorType="humidity", Value=humidity, Timestamp=datetime.utcnow()))
│        │                if filtered_humidity is not None and device_id in {5, 6, 7, 8}:
│        │                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
│        │                if soil_moisture is not None and device_id in {9,10}:
│        │                    session.add(SensorData(DeviceID=device_id, SensorType="soil_moisture", Value=soil_moisture, Timestamp=datetime.utcnow()))
│        │                if filtered_soil_moisture is not None and device_id in {9,10}:
│        │                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
│        │                session.commit()
│        │
│        │            except Exception as e:
│        │                session.rollback()
│        │                print(f"[ERROR] Failed to store sensor data: {e}")
│        │            finally:
│        │                session.close()
│        │
│        │
│        │        def receive_sensor_data(request):
│        │            # Basic HTTP Auth
│        │            auth = request.authorization
│        │            if not auth or credentials.get(auth.username) != auth.password:
│        │                return jsonify({"error": "Unauthorized"}), 401
│        │
│        │            try:
│        │                data = request.json
│        │                if not data:
│        │                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
│        │
│        │                DeviceID = data.get('DeviceID')
│        │                DeviceName = data.get('DeviceName')
│        │                temperature = data.get('temperature')
│        │                filtered_temperature = data.get('filtered_temperature')
│        │                humidity = data.get('humidity')
│        │                filtered_humidity = data.get('filtered_humidity')
│        │                soil_moisture = data.get('soil_moisture')
│        │                filtered_soil_moisture = data.get('filtered_soil_moisture')
│        │
│        │                if not DeviceID:
│        │                    return jsonify({"error": "Missing 'DeviceID' in payload"}), 400
│        │                if not DeviceName:
│        │                    return jsonify({"error": "Missing 'DeviceName' in payload"}), 400
│        │
│        │                print(f"Received payload: from {DeviceName}")
│        │
│        │                store_sensor_data(DeviceID, DeviceName, temperature, humidity, soil_moisture)
│        │
│        │                process_weighted_fusion()
│        │
│        │
│        │                action = action_based_on_sensor(DeviceName, temperature, humidity, soil_moisture)
│        │
│        │                if action == "VENTILATION_System_on":
│        │                    return jsonify({"DeviceName": "Ventilation_System_ESP", "action": action})
│        │
│        │                elif action == "Irrigation_System_on":
│        │                    return jsonify({"DeviceName": "Irrigation_System_ESP", "action": action})
│        │
│        │                elif action == "error":
│        │                    return jsonify({"error": "Failed to perform action"}), 500
│        │
│        │                else:
│        │                    return jsonify({"DeviceName": DeviceName, "action": "No action taken"}), 200
│        │
│        │
│        │            except Exception as e:
│        │                print(f"[ERROR] Exception in receive_sensor_data: {e}")
│        │                return jsonify({"error": "Internal Server Error"}), 500
│        │        ↑↑↑ END OF FILE ↑↑↑
│        
│        ├── webserver.code-workspace
│        └── weightedAverage.py
│             ↓↓↓ FILE CONTENT ↓↓↓
│             from datetime import datetime, timedelta
│             from sqlalchemy.orm import Session
│             from database_setup import KalmanFilterFusionData, WeightedAverageFusionData, SessionLocal
│        
│        
│             def weighted_average_fusion(values, weights):
│                 """Perform weighted average of given values with weights."""
│                 if len(values) != len(weights):
│                     raise ValueError("Length of values and weights must match.")
│                 return sum(v * w for v, w in zip(values, weights))
│        
│        
│             def fetch_recent_sensor_data(session, sensor_ids, window_seconds):
│                 """Fetch the most recent Kalman-filtered readings for given sensor_ids within time window."""
│                 now = datetime.utcnow()
│                 window_start = now - timedelta(seconds=window_seconds)
│                 latest_data = {}
│        
│                 for sensor_id in sensor_ids:
│                     entry = session.query(KalmanFilterFusionData)\
│                         .filter(KalmanFilterFusionData.SensorID == sensor_id)\
│                         .filter(KalmanFilterFusionData.Timestamp >= window_start)\
│                         .order_by(KalmanFilterFusionData.Timestamp.desc())\
│                         .first()
│                     if entry:
│                         latest_data[sensor_id] = entry.FusedValue
│        
│                 return latest_data
│        
│        
│             def process_weighted_fusion(sensor_ids, weights, sensor_type, fusion_window_seconds=60):
│                 """
│                 Run weighted average fusion on a given set of sensor IDs and weights.
│        
│                 Args:
│                     sensor_ids (list): List of sensor IDs.
│                     weights (list): Corresponding weights (same length as sensor_ids).
│                     sensor_type (str): Sensor type label (e.g., "Temperature", "Humidity").
│                     fusion_window_seconds (int): Time window in seconds to consider valid readings.
│                 """
│                 session: Session = SessionLocal()
│                 try:
│                     sensor_data = fetch_recent_sensor_data(session, sensor_ids, fusion_window_seconds)
│        
│                     if not sensor_data:
│                         print(f"[{sensor_type.upper()}] No recent readings available.")
│                         return
│        
│                     available_ids = list(sensor_data.keys())
│                     available_values = [sensor_data[sid] for sid in available_ids]
│        
│                     # Adjust weights to match available sensors
│                     weight_map = {sid: w for sid, w in zip(sensor_ids, weights)}
│                     available_weights = [weight_map[sid] for sid in available_ids]
│        
│        
│                     # Normalize weights
│                     total_weight = sum(available_weights)
│                     normalized_weights = [w / total_weight for w in available_weights]
│        
│                     fused_value = weighted_average_fusion(available_values, normalized_weights)
│        
│                     session.add(WeightedAverageFusionData(
│                         SensorType=sensor_type,
│                         Timestamp=datetime.utcnow(),
│                         FusedValue=fused_value
│                     ))
│                     session.commit()
│                     print(f"[{sensor_type.upper()}] Fused value: {fused_value:.2f} from {len(available_values)} sensors.")
│                 except Exception as e:
│                     session.rollback()
│                     print(f"[ERROR] Fusion failed for {sensor_type}: {e}")
│                 finally:
│                     session.close()
│             ↑↑↑ END OF FILE ↑↑↑
│        
│        PS D:\Documents\My AAST\Term 9\Graduation Project\Greenhouse\webdevelopment>
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── indexprev.html
│        ↓↓↓ FILE CONTENT ↓↓↓
│        {% extends "base.html" %}
│        
│        {% block content %}
│        <div class="container">
│            <h1>Welcome to the AI driven Greenhouse</h1>
│            <p>Monitor and control your greenhouse environment remotely.</p>
│        </div>
│        
│        <div class="container">
│            <h1>Surveillance</h1>
│            <p>Two cameras for monitoring.</p>
│        </div>
│        
│        <div class="container">
│            <img id="camera-stream" src="http://192.168.1.24:81/stream" width="400" height="400" alt="ESP32-CAM Stream" onerror="this.onerror=null; this.src='static/no-signal.jpg';">
│        </div>
│        
│        {% endblock %}
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── network.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from flask import request, jsonify
│        from database_setup import SessionLocal, SensorData, Device,UserInteraction
│        from datetime import datetime
│        
│        # Device (Microcontrollers) authentication credentials for sending sensor data to the server
│        credentials = {
│            "esp_Temp_humid_1": "esp_password",
│            "esp_Soil_moisture_1": "esp_password"
│        }
│        
│        def action_based_on_sensor(DeviceName, temperature=0, humidity=0, soil_moisture=0):
│            session = SessionLocal()
│            try:
│                if DeviceName == "esp_Temp_humid_1" and temperature > 30:
│                    session.add(UserInteraction(DeviceID=11, UserID=5000, Action="blink_led", Timestamp=datetime.utcnow()))
│                    session.commit()
│                    return "blink_led"
│        
│                elif DeviceName == "esp_Soil_moisture_1" and soil_moisture > 30:
│                    session.add(UserInteraction(DeviceID=12, UserID=5000, Action="blink_led", Timestamp=datetime.utcnow()))
│                    session.commit()
│                    return "blink_led"
│        
│                return "no_action"
│        
│            finally:
│                session.close()
│        
│        
│        
│        def store_sensor_data(device_id, DeviceName, temperature=None, humidity=None, soil_moisture=None):
│            session = SessionLocal()
│        
│            # Ensure device exists in the database
│            device = session.query(Device).filter_by(DeviceID=device_id).first()
│            if not device:
│                device = Device(DeviceID=device_id, DeviceName=DeviceName, Type="ESP32", Location="Unknown", Status="Active")
│                session.add(device)
│                session.commit()
│                session.refresh(device)  # Ensure we have the latest DeviceID
│        
│            # Store sensor readings for the specific device ID received from ESP
│            if temperature is not None and device_id in {1, 2, 3}:
│                session.add(SensorData(DeviceID=device_id, SensorType="temperature", Value=temperature, Timestamp=datetime.utcnow()))
│        
│            if humidity is not None and device_id in {4, 5, 6}:
│                session.add(SensorData(DeviceID=device_id, SensorType="humidity", Value=humidity, Timestamp=datetime.utcnow()))
│        
│            if soil_moisture is not None and device_id in {7, 8}:
│                session.add(SensorData(DeviceID=device_id, SensorType="soil_moisture", Value=soil_moisture, Timestamp=datetime.utcnow()))
│        
│            session.commit()
│            session.close()
│        
│        def receive_sensor_data(request):
│            # Get Authorization header
│            auth = request.authorization
│            if not auth or credentials.get(auth.username) != auth.password:
│                return jsonify({"error": "Unauthorized"}), 401
│        
│            try:
│                data = request.json
│                if not data:
│                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
│        
│                device_id = data.get('DeviceID')  # This is an integer
│                DeviceName = data.get('DeviceName')  # This is a string
│                temperature = data.get('temperature')
│                humidity = data.get('humidity')
│                soil_moisture = data.get('soil_moisture')  # Fixed key
│        
│                if not device_id or not DeviceName:
│                    return jsonify({"error": "Missing 'DeviceID' or 'DeviceName' in payload"}), 400
│        
│                print(f"Received JSON payload: {data}")
│        
│                # Store the data in the database
│                store_sensor_data(device_id, DeviceName, temperature, humidity, soil_moisture)
│        
│                # Determine action based on sensor data
│                action = action_based_on_sensor(DeviceName, temperature, humidity, soil_moisture)
│        
│                response = {"DeviceName": DeviceName, "action": action}
│                return jsonify(response)
│        
│            except Exception as e:
│                print(f"Error processing request: {e}")
│                return jsonify({"error": "Internal Server Error"}), 500
│        ↑↑↑ END OF FILE ↑↑↑

│   ├── newer_network.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from flask import request, jsonify
│        import time
│        from sqlalchemy import desc
│        from datetime import datetime
│        from sqlalchemy.orm import Session
│        from database_setup import (
│            SessionLocal, SensorData, Sensor, Device, UserInteraction,
│            Actuator, WeightedAverageFusionData, KalmanFilterFusionData
│        )
│        from weightedAverage import process_weighted_fusion
│        
│        # Authentication credentials for devices
│        credentials = {
│            "Ventilation_System_ESP": "password",
│            "Irrigation_System_ESP": "password",
│            "web_control": "web_password"
│        }
│        
│        # Constants
│        DEFAULT_USER_ID = 5000  # Server user
│        TEMP_THRESHOLD = 30
│        HUM_THRESHOLD = 40
│        SOIL_MOISTURE_THRESHOLD = 30
│        
│        TEMP_SENSOR_IDS = [2099, 2092, 3093]
│        HUM_SENSOR_IDS = [2091, 2034, 3027]
│        WEIGHTS = [0.5, 0.3, 0.2]
│        
│        # Actuator Names
│        INTAKE_SHUTTER = "intake_shutter"
│        WATER_PUMP = "water_pump"
│        VENTILATION_FAN = "ventilation_fan"
│        
│        # Device IDs
│        Ventilation_System_ESP_ID = 2000
│        Irrigation_System_ESP_ID = 3000
│        
│        soil_sensor_1id = 2005
│        soil_sensor_2id = 3002
│        
│        
│        def get_fused_values_by_sensors(session: Session, *sensor_ids: int):
│            fused_values = {}
│        
│            if not sensor_ids:
│                return fused_values  # No IDs provided → return empty
│        
│            for sensor_id in sensor_ids:
│                if sensor_id is None:
│                    continue
│                fusion = (
│                    session.query(KalmanFilterFusionData)
│                    .filter_by(SensorID=sensor_id)
│                    .order_by(desc(KalmanFilterFusionData.Timestamp))
│                    .first()
│                )
│                if fusion:
│                    fused_values[sensor_id] = fusion.FusedValue
│        
│            return fused_values
│        
│        
│        def log_user_action(session, device_id, action, user_id, actuator_id):
│            session.add(UserInteraction(
│                DeviceID=device_id,
│                Action=action,
│                UserID=user_id,
│                ActuatorID=actuator_id,
│                Timestamp=datetime.utcnow()
│            ))
│        
│        
│        def control_actuator(session, actuator_name, status, user_id):
│            actuator = session.query(Actuator).filter_by(ActuatorName=actuator_name).first()
│            if not actuator:
│                actuator = Actuator(
│                    ActuatorName=actuator_name,
│                    Status=status,
│                    LastUpdated=datetime.utcnow(),
│                    UserID=user_id
│                )
│                session.add(actuator)
│            else:
│                if actuator.Status != status:
│                    actuator.Status = status
│                    actuator.LastUpdated = datetime.utcnow()
│                    actuator.UserID = user_id
│                    log_user_action(
│                        session,
│                        device_id=actuator.ActuatorID,
│                        action=f"{actuator_name}_{status.lower()}",
│                        user_id=user_id,
│                        actuator_id=actuator.ActuatorID
│                    )
│            session.commit()
│            return actuator
│        
│        
│        def get_latest_fused_temperature_humidity(session):
│            latest_temp = session.query(WeightedAverageFusionData).filter_by(
│                SensorType="temperature").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
│            latest_hum = session.query(WeightedAverageFusionData).filter_by(
│                SensorType="humidity").order_by(desc(WeightedAverageFusionData.Timestamp)).first()
│        
│            return {
│                "temperature": latest_temp.FusedValue if latest_temp else None,
│                "humidity": latest_hum.FusedValue if latest_hum else None
│            }
│        
│        
│        def action_based_on_sensor(user_id=DEFAULT_USER_ID):
│            with SessionLocal() as session:
│                result = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
│                soil1 = result.get(soil_sensor_1id)
│                soil2 = result.get(soil_sensor_2id)
│        
│                soil_moisture = None
│                if soil1 is not None and soil2 is not None:
│                    average = (soil1 + soil2) / 2
│                    if 0 <= average <= 100:
│                        soil_moisture = average
│                elif soil1 is not None:
│                    if 0 <= soil1 <= 100:
│                        soil_moisture = soil1
│                elif soil2 is not None:
│                    if 0 <= soil2 <= 100:
│                        soil_moisture = soil2
│                # Else → soil_moisture stays None
│        
│                temperature=process_weighted_fusion(sensor_ids=TEMP_SENSOR_IDS, weights=WEIGHTS, sensor_type="Temperature")
│        
│                # Call for humidity
│                humidity=process_weighted_fusion(sensor_ids=HUM_SENSOR_IDS, weights=WEIGHTS, sensor_type="Humidity")
│        
│                actions = []
│        
│                try:
│                    if temperature is not None and humidity is not None:
│                        if temperature > TEMP_THRESHOLD or humidity > HUM_THRESHOLD:
│                            control_actuator(session, VENTILATION_FAN, "on", user_id)
│                            control_actuator(session, INTAKE_SHUTTER, "on", user_id)
│                            actions.append("Ventilation_ON")
│                        elif temperature < TEMP_THRESHOLD and humidity < HUM_THRESHOLD:
│                            control_actuator(session, VENTILATION_FAN, "off", user_id)
│                            control_actuator(session, INTAKE_SHUTTER, "off", user_id)
│                            actions.append("Ventilation_OFF")
│        
│                    if soil_moisture is not None:
│                        if soil_moisture < SOIL_MOISTURE_THRESHOLD:
│                            control_actuator(session, WATER_PUMP, "on", user_id)
│                            actions.append("Irrigation_ON")
│                        else:
│                            control_actuator(session, WATER_PUMP, "off", user_id)
│                            actions.append("Irrigation_OFF")
│        
│                    session.commit()
│                    return ", ".join(actions) if actions else "none"
│                except Exception as e:
│                    session.rollback()
│                    print(f"[ERROR] Failed to perform action: {e}")
│                    return "error"
│        
│        
│        
│        def get_or_create_device(session, device_id, device_name):
│            device = session.query(Device).filter_by(DeviceID=device_id).first()
│            if not device:
│                device = Device(DeviceID=device_id, DeviceName=device_name, Location="Unknown", Status="Active")
│                session.add(device)
│                session.commit()
│                session.refresh(device)
│            return device
│        
│        
│        def get_or_create_sensor(session,sensor_id, device_id, sensor_type):
│            sensor = session.query(Sensor).filter_by(SensorID=sensor_id, SensorType=sensor_type).first()
│            if not sensor:
│                sensor = Sensor(SensorID=sensor_id, DeviceID=device_id, SensorType=sensor_type, Location="Unknown", Status="Active")
│                session.add(sensor)
│                session.commit()
│                session.refresh(sensor)
│            return sensor
│        
│        
│        def store_sensor_value(session, sensor, value):
│            session.add(SensorData(SensorID=sensor.SensorID, Value=value, Timestamp=datetime.utcnow()))
│        
│        
│        def store_sensor_data(device_id, device_name,sensor_id,
│                              temperature=None, filtered_temperature=None,
│                              humidity=None, filtered_humidity=None,
│                              soil_moisture=None, filtered_soil_moisture=None):
│            with SessionLocal() as session:
│                try:
│                    get_or_create_device(session, device_id, device_name)
│        
│                    if temperature is not None:
│                        sensor = get_or_create_sensor(session, device_id, "temperature")
│                        store_sensor_value(session, sensor, temperature)
│        
│                    if filtered_temperature is not None:
│                        sensor = get_or_create_sensor(session, device_id, "temperature_filtered")
│                        store_sensor_value(session, sensor, filtered_temperature)
│        
│                    if humidity is not None:
│                        sensor = get_or_create_sensor(session, device_id, "humidity")
│                        store_sensor_value(session, sensor, humidity)
│        
│                    if filtered_humidity is not None:
│                        sensor = get_or_create_sensor(session, device_id, "humidity_filtered")
│                        store_sensor_value(session, sensor, filtered_humidity)
│        
│                    if soil_moisture is not None:
│                        sensor = get_or_create_sensor(session, device_id, "soil_moisture")
│                        store_sensor_value(session, sensor, soil_moisture)
│        
│                    if filtered_soil_moisture is not None:
│                        sensor = get_or_create_sensor(session, device_id, "soil_moisture_filtered")
│                        store_sensor_value(session, sensor, filtered_soil_moisture)
│        
│                    session.commit()
│                except Exception as e:
│                    session.rollback()
│                    print(f"[ERROR] Failed to store sensor data: {e}")
│        
│        
│        def receive_sensor_data(request):
│            auth = request.authorization
│            if not auth or credentials.get(auth.username) != auth.password:
│                return jsonify({"error": "Unauthorized"}), 401
│        
│            try:
│                data = request.get_json()
│                if not data:
│                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
│        
│                device_id = data.get('DeviceID')
│                device_name = data.get('DeviceName')
│                sensor_id = data.get('SensorID')
│                if not device_id or not device_name:
│                    return jsonify({"error": "Missing DeviceID or DeviceName"}), 400
│        
│                temperature = data.get('temperature')
│                filtered_temperature = data.get('filtered_temperature')
│                humidity = data.get('humidity')
│                filtered_humidity = data.get('filtered_humidity')
│                soil_moisture = data.get('soil_moisture')
│                filtered_soil_moisture = data.get('filtered_soil_moisture')
│        
│                store_sensor_data(device_id, device_name,sensor_id,
│                                  temperature, filtered_temperature,
│                                  humidity, filtered_humidity,
│                                  soil_moisture, filtered_soil_moisture)
│        
│                print(f"[INFO] Received data from DeviceID: {device_id}, SensorID: {sensor_id}")
│                # Optional: wait for fusion update to complete if it's not sync
│                time.sleep(5)
│        
│                action_result = action_based_on_sensor()
│        
│                with SessionLocal() as session:
│                    latest = get_latest_fused_temperature_humidity(session)
│                    soil_data = get_fused_values_by_sensors(session, soil_sensor_1id, soil_sensor_2id)
│                    avg_soil = None
│                    if soil_data:
│                        values = list(soil_data.values())
│                        avg_soil = sum(values) / len(values) if values else None
│        
│                return jsonify({
│                    "status": "success",
│                    "action": action_result,
│                    "temperature": latest["temperature"],
│                    "humidity": latest["humidity"],
│                    "soil_moisture": avg_soil
│                }), 200
│        
│            except Exception as e:
│                print(f"[ERROR] Failed to receive/process sensor data: {e}")
│                return jsonify({"error": "Internal Server Error"}), 500
│        ↑↑↑ END OF FILE ↑↑↑

│   └── old_network.py
│        ↓↓↓ FILE CONTENT ↓↓↓
│        from flask import request, jsonify
│        from webdevelopment.database_setup import SessionLocal, SensorData, Device, UserInteraction, Actuator, WeightedAverageFusionData
│        from datetime import datetime
│        from webdevelopment.weightedAverage import process_weighted_fusion
│        
│        # Authentication credentials for devices
│        credentials = {
│            "Ventilation_System_ESP ": "password",
│            "Irrigation_System_ESP": "password"
│        }
│        
│        # Constants
│        DEFAULT_USER_ID = 5000  # Server user
│        TEMP_THRESHOLD = 30
│        HUM_THRESHOLD = 40
│        SOIL_MOISTURE_THRESHOLD = 30
│        
│        # Actuator Names
│        INTAKE_SHUTTER = "intake_shutter"
│        WATER_PUMP = "water_pump"
│        VENTILATION_FAN = "ventilation_fan"
│        
│        # Device Names
│        Ventilation_System_ESP = 1111
│        Irrigation_System_ESP = 2222
│        
│        
│        def log_user_action(session, device_id, action, user_id):
│            interaction = UserInteraction(
│                DeviceID=device_id,
│                Action=action,
│                UserID=user_id,
│                Timestamp=datetime.utcnow()
│            )
│            session.add(interaction)
│        
│        
│        def control_actuator(session, actuator_name, status, user_id):
│            actuator = session.query(Actuator).filter_by(ActuatorName=actuator_name).first()
│            if not actuator:
│                actuator = Actuator(ActuatorName=actuator_name, Status=status, LastUpdated=datetime.utcnow(), UserID=user_id)
│                session.add(actuator)
│            else:
│                actuator.Status = status
│                actuator.LastUpdated = datetime.utcnow()
│                actuator.UserID = user_id
│        
│            # Log who triggered this actuator
│            log_user_action(session, device_id=actuator.ActuatorID, action=f"{actuator_name}_{status.lower()}", user_id=user_id)
│            return True
│        
│        
│        def action_based_on_sensor(DeviceName, temperature=0, humidity=0, soil_moisture=0, user_id=DEFAULT_USER_ID):
│            session = SessionLocal()
│        
│            try:
│                if  temperature > TEMP_THRESHOLD or humidity > HUM_THRESHOLD:
│        
│                    control_actuator(session, VENTILATION_FAN, "On", user_id)
│                    control_actuator(session, INTAKE_SHUTTER, "On", user_id)
│                    log_user_action(session, Ventilation_System_ESP,"On", user_id)
│                    log_user_action(session, INTAKE_SHUTTER,"On", user_id)
│                    action_taken = "VENTILATION_System_on"
│        
│        
│                elif soil_moisture < SOIL_MOISTURE_THRESHOLD:
│                    control_actuator(session, WATER_PUMP, "On", user_id)
│                    log_user_action(session, Irrigation_System_ESP, "On", user_id)
│                    action_taken = "Irrigation_System_on"
│        
│                session.commit()
│                return action_taken
│        
│            except Exception as e:
│                session.rollback()
│                print(f"[ERROR] Failed to perform action: {e}")
│                return "error"
│        
│            finally:
│                session.close()
│        
│        
│        def store_sensor_data(device_id, DeviceName, temperature=None, filtered_temperature=None, humidity=None, filtered_humidity=None, soil_moisture=None, filtered_soil_moisture= None):
│            session = SessionLocal()
│        
│            try:
│                # Ensure device exists
│                device = session.query(Device).filter_by(DeviceID=device_id).first()
│                if not device:
│                    device = Device(DeviceID=device_id, DeviceName=DeviceName, Type="ESP32", Location="Unknown", Status="Active")
│                    session.add(device)
│                    session.commit()
│                    session.refresh(device)
│        
│                # Store relevant sensor data
│                if temperature is not None and device_id in {1, 2, 3, 4}:
│                    session.add(SensorData(DeviceID=device_id, SensorType="temperature", Value=temperature, Timestamp=datetime.utcnow()))
│                if filtered_temperature is not None and device_id in {1, 2, 3, 4}:
│                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
│                if humidity is not None and device_id in {5, 6, 7, 8}:
│                    session.add(SensorData(DeviceID=device_id, SensorType="humidity", Value=humidity, Timestamp=datetime.utcnow()))
│                if filtered_humidity is not None and device_id in {5, 6, 7, 8}:
│                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
│                if soil_moisture is not None and device_id in {9,10}:
│                    session.add(SensorData(DeviceID=device_id, SensorType="soil_moisture", Value=soil_moisture, Timestamp=datetime.utcnow()))
│                if filtered_soil_moisture is not None and device_id in {9,10}:
│                    session.add(SensorData(DeviceID=device_id, FusedValue=temperature, Timestamp=datetime.utcnow()))
│                session.commit()
│        
│            except Exception as e:
│                session.rollback()
│                print(f"[ERROR] Failed to store sensor data: {e}")
│            finally:
│                session.close()
│        
│        
│        def receive_sensor_data(request):
│            # Basic HTTP Auth
│            auth = request.authorization
│            if not auth or credentials.get(auth.username) != auth.password:
│                return jsonify({"error": "Unauthorized"}), 401
│        
│            try:
│                data = request.json
│                if not data:
│                    return jsonify({"error": "Invalid or missing JSON payload"}), 400
│        
│                DeviceID = data.get('DeviceID')
│                DeviceName = data.get('DeviceName')
│                temperature = data.get('temperature')
│                filtered_temperature = data.get('filtered_temperature')
│                humidity = data.get('humidity')
│                filtered_humidity = data.get('filtered_humidity')
│                soil_moisture = data.get('soil_moisture')
│                filtered_soil_moisture = data.get('filtered_soil_moisture')
│        
│                if not DeviceID:
│                    return jsonify({"error": "Missing 'DeviceID' in payload"}), 400
│                if not DeviceName:
│                    return jsonify({"error": "Missing 'DeviceName' in payload"}), 400
│        
│                print(f"Received payload: from {DeviceName}")
│        
│                store_sensor_data(DeviceID, DeviceName, temperature, humidity, soil_moisture)
│        
│                process_weighted_fusion()
│        
│        
│                action = action_based_on_sensor(DeviceName, temperature, humidity, soil_moisture)
│        
│                if action == "VENTILATION_System_on":
│                    return jsonify({"DeviceName": "Ventilation_System_ESP", "action": action})
│        
│                elif action == "Irrigation_System_on":
│                    return jsonify({"DeviceName": "Irrigation_System_ESP", "action": action})
│        
│                elif action == "error":
│                    return jsonify({"error": "Failed to perform action"}), 500
│        
│                else:
│                    return jsonify({"DeviceName": DeviceName, "action": "No action taken"}), 200
│        
│        
│            except Exception as e:
│                print(f"[ERROR] Exception in receive_sensor_data: {e}")
│                return jsonify({"error": "Internal Server Error"}), 500
│        ↑↑↑ END OF FILE ↑↑↑

└── weightedAverage.py
     ↓↓↓ FILE CONTENT ↓↓↓
     from datetime import datetime, timedelta
     from sqlalchemy.orm import Session
     from database_setup import KalmanFilterFusionData, WeightedAverageFusionData, SessionLocal
     
     
     def weighted_average_fusion(values, weights):
         """Perform weighted average of given values with weights."""
         if len(values) != len(weights):
             raise ValueError("Length of values and weights must match.")
         return sum(v * w for v, w in zip(values, weights))
     
     
     def fetch_recent_sensor_data(session, sensor_ids, window_seconds):
         """Fetch the most recent Kalman-filtered readings for given sensor_ids within time window."""
         now = datetime.utcnow()
         window_start = now - timedelta(seconds=window_seconds)
         latest_data = {}
     
         for sensor_id in sensor_ids:
             entry = session.query(KalmanFilterFusionData)\
                 .filter(KalmanFilterFusionData.SensorID == sensor_id)\
                 .filter(KalmanFilterFusionData.Timestamp >= window_start)\
                 .order_by(KalmanFilterFusionData.Timestamp.desc())\
                 .first()
             if entry:
                 latest_data[sensor_id] = entry.FusedValue
     
         return latest_data
     
     
     def process_weighted_fusion(sensor_ids, weights, sensor_type, fusion_window_seconds=60):
         """
         Run weighted average fusion on a given set of sensor IDs and weights.
     
         Args:
             sensor_ids (list): List of sensor IDs.
             weights (list): Corresponding weights (same length as sensor_ids).
             sensor_type (str): Sensor type label (e.g., "Temperature", "Humidity").
             fusion_window_seconds (int): Time window in seconds to consider valid readings.
         """
         session: Session = SessionLocal()
         try:
             sensor_data = fetch_recent_sensor_data(session, sensor_ids, fusion_window_seconds)
     
             if not sensor_data:
                 print(f"[{sensor_type.upper()}] No recent readings available.")
                 return
     
             available_ids = list(sensor_data.keys())
             available_values = [sensor_data[sid] for sid in available_ids]
     
             # Adjust weights to match available sensors
             weight_map = {sid: w for sid, w in zip(sensor_ids, weights)}
             available_weights = [weight_map[sid] for sid in available_ids]
     
     
             # Normalize weights
             total_weight = sum(available_weights)
             normalized_weights = [w / total_weight for w in available_weights]
     
             fused_value = weighted_average_fusion(available_values, normalized_weights)
     
             session.add(WeightedAverageFusionData(
                 SensorType=sensor_type,
                 Timestamp=datetime.utcnow(),
                 FusedValue=fused_value
             ))
             session.commit()
             print(f"[{sensor_type.upper()}] Fused value: {fused_value:.2f} from {len(available_values)} sensors.")
         except Exception as e:
             session.rollback()
             print(f"[ERROR] Fusion failed for {sensor_type}: {e}")
         finally:
             session.close()
     ↑↑↑ END OF FILE ↑↑↑
